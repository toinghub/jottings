# 设计原则

*  单一职责原则表达实现类要**职责单一**
*  里氏替换原则表达**不要破坏继承体系**
*  依赖倒置原则表达**面向接口编程**
*  接口隔离原则表达在**设计接口**的时候要**精简单一**
*  迪米特法则表达要**降低耦合**
*  开闭原则是总纲，表达要**对扩展开放，对修改关闭**。 



## [单一职责原则(SRP)](https://makeoptim.com/training/single-responsibility-principle)

### 定义

 一个类应该**只有一个发生变化的原因**，即一个类**只负责一项职责** 

### 核心

 **解耦**和**增强内聚性**

### 优点

- 降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多。
- 提高类的可读性，提高系统的可维护性。
- 变更引起的风险降低，变更是必然的，如果 SRP 遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。



## [开闭原则(OCP)](https://makeoptim.com/training/open-closed-principle)

### 定义

* 软件中的**实体（类，模块，函数等等）**应该**对扩展开放，对修改封闭** 
* 一个实体是允许在**不改变它的源代码的前提下变更它的行为** 

### 优点

* 保持系统的**可维护性**和**代码的重用性** 

* 想遵守开闭原则 , 在**做系统设计（概要设计、详细设计）**的时候就要**考虑到未来的扩展和改变* 



## [里氏替换原则(LSP)](https://makeoptim.com/training/liskov-substitution-principle)

### 定义

 **派生类（子类）对象可以在程序中代替其基类（父类）对象**

### 优点

- **实现开闭原则的重要方式之一**
- **克服**了继承中重写父类造成的**可复用性变差的缺点** 
- **类的扩展不会给已有的系统引入新的错误**，降低了代码出错的可能性 

### 替换原则

*  **任何基类可以出现的地方，子类一定可以出现** 
*  子类必须**完全实现父类的抽象方法**，但**不能覆盖父类的非抽象方法**
*  子类可以实现自己**特有的方法**
*  当子类**覆盖或实现父类的方法时**，方法的**前置条件（即方法的形参）**要比父类方法的输入参数**更宽松**

- 当子类的方法**实现父类的抽象方法时**，方法的**后置条件（即方法的返回值）**要比父类**更严格**（**类向上转换是安全的，向下转换则不一定是安全**）
- 子类的实例可以替代任何父类的实例，**不成立则不符合替换原则** 

### 注意点

*  子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法
*  LSP 是**继承复用的基石** 
*  里氏代换原则是对开闭原则的补充 



## [依赖倒置原则(DIP)](https://makeoptim.com/training/dependence-inversion-principle)

### 定义

 **高层模块，低层模块，细节都应该依赖抽象** 

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象
- 细节 --  较为具体的东西，比如具体的类 
- 抽象 -- 具有**契约性、共同性、规范性的表达** 

### 优点

*  **减少类间的耦合性** 
*  降低**并行开发**引起的风险 
*  提高代码的**可读性**和**可维护性** 

### 注意点

*  **分清细节与抽象** 
*  **变量的声明类型尽量是抽象类或接口** 
*  **尽量不要覆写基类的方法** 
*  **继承要遵循里氏替换原则** 



## [迪米特法则(LOD)](https://makeoptim.com/training/law-of-demeter-principle)

### 定义

* 只和**对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数**等，这些对象同当前对象**存在关联、聚合或组合关系**，**可以直接访问**这些对象的方法 

* 两个软件实体**无须直接通信**，那么就**不应当发生直接的相互调用** ，可以通过第三方**转发**该调用 
* 依赖者的角度来说，**只依赖应该依赖的对象** 
* 被依赖者的角度说，**只暴露应该暴露的方法** 

### 优点

* 降低了类之间的**耦合度**，提高了模块的相对**独立性**。
* 由于亲合度降低，从而提高了**类的可复用率**和系统的**扩展性**

#### 实现原则

* **类的划分**：应当尽量**创建松耦合的类**，类之间的耦合度越低，就越有利于复用 
* **类的结构设计**： 每一个类都应当尽量**降低其成员变量和成员函数的访问权限** 
* **类的设计** ： 只要有可能，一个类型应当设计成**不变类** 
* **对其他类的引用**： 一个对象对其他对象的引用应当**降到最低** 
* **不暴露类的属性成员**，而应该提供相应的**访问器**（set 和 get 方法）

### 注意点

**过度使用迪米特法则**会系统产生**大量的中介类**，增加系统复杂性，模块之间的**通信效率降低**。所以，在釆用时需要**反复权衡**，确保高内聚和低耦合的同时，保证系统的**结构清晰**。 



## [接口隔离原则(ISP)](https://makeoptim.com/training/interface-segregation-principle)

### 定义

* 客户端**不应该依赖它不需要的接口** 
* 一个类对另一个类的依赖应该建立在**最小的接口**上

### 优点

*  建立**单一接口**， 不是该功能的功能不需要
*  **尽量细化接口，接口中的方法尽量少** 
*  提高系统的**灵活性**和**可维护性** 

### 区别

#### 单一职责原则

*  **注重的是职责**
*  主要是**约束类**，其次才是接口和方法 
*  针对的是程序中的**实现和细节** 

#### 接口隔离原则

*  **注重对接口依赖的隔离** 
*  主要**约束接口** , 主要针对**抽象**
*  针对程序**整体框架的构建** 

### 注意点

*  **接口尽量小，但是要有限度** 
*  **只暴露**给调用的类它**需要的方法** 
*  **提高内聚，减少对外交互**。使接口**用最少的方法去完成最多的事情** 
*  **运用接口隔离原则，一定要适度，接口设计的过大或过小都不好** 



## [组合/聚合复用原则(CARP)](https://makeoptim.com/training/composite-reuse-principle)

### 定义

* **尽量使用组合/聚合，尽量不要使用继承** 

### 复用方式

#### 组合 -- 任何环境

#####  将已有的对象纳入到新对象中，使之成为新对象的一部分，因此**新对象可以调用已有对象的功能** 

##### 优点：

* 新对象存取成分对象的唯一方法是通过**成分对象的接口**
* 复用是**黑箱复用**，因为成分对象的内部细节是新对象所看不见的 
* 复用所需的**依赖较少** 
* 每一个**新的类**可以将焦点**集中在一个任务上**
* **组合/聚合是动态行为** 

##### 缺点：

*  **有较多的对象需要管理**

#### 继承 -- 一些环境

 继承复用通过扩展一个已有对象的实现来得到新的功能 

##### 优点：

* **新的实现比较容易**，因为基类的大部分功能都可以通过继承自动的进入子类
* 修改或扩展继承而来的实现较为容易 

##### 缺点：

*  继承复用**破坏了包装**，因为继承超类的的实现细节暴露给子类。由于超类的内部细节常常对子类是透明的，因此这种复用是**透明的复用**，又称“白箱”复用 
*  如果**基类的实现发生改变**，那么**派生类的实现也不得不发生改变** 
*  从超类继承而来的实现是**静态的**，不可能在运行时间内发生改变，因此**没有足够的灵活性** 

#### 使用原则

*  **满足 “Is-A” 的关系是才可以使用继承** 
*  **组合却是一种 “Has-A”（整体与部分）的关系** 

### 注意点

*  **首选组合，然后才是继承** 
*  继承时**应该严格的遵守里氏替换原则**，**必须满足 “Is-A” 的关系**是才能使用继承