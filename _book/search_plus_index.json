{"./":{"url":"./","title":"前言","keywords":"","body":"node随笔 "},"node/":{"url":"node/","title":"node","keywords":"","body":"node基础 "},"node/node基础.html":{"url":"node/node基础.html","title":"node-基础","keywords":"","body":"一、nvm指令 nvm list //查看已安装的nodejs版本 nvm on // 启用node.js版本管理 nvm off // 禁用node.js版本管理(不卸载任何东西) nvm install // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0 nvm use //使用某一version的nodejs nvm uninstall // 卸载指定版本的nodejs nvm alias default //切换默认版本 代码工具 lodash npm搜索 官网lodash.com underscore 开源项目CDN 二、NPM知识 命令行 npm init -y //创建package文件 --sava //安装 -S 简写 --dev //开发环境使用 -D 简写 -g //全局安装 install //安装 i 简写 npm uninstall gulp -D //卸载包 npm list //显示包管理的关系 npm list | grep 包名 //显示指定包管理的关系 三层关系 npm i --production //只装生产环境的包 npm view 包名 versions //查看包版本号 -V 简写 npm i 包名@版本号 -S //安装包指定版本号 版本号可不写 npm outdated //查看那些包已过期 npm update //更新包 npm cache clean --force //强制清除缓存 npm config get registry //查看当前源 npm config set registry 地址 //切换源 npm i git+https://git@ (git地址) //下载git项目（当hhs时，把https改成ssh） 使用npm i可以重新直接安装package里的内容 package-lock 显示包依赖关系 __dirname //当前代码所在文件的物理路径 包类型 1.内置的包 2.第三方库 3.自己定义的包 上传包 npm init -y 初始化 npm adduser 添加账户 npm publish 上传包 三、package 文件解析 package中的 ^1.12.1的^表示当前版本号需要按语义做适配 major 主版本号 minor 次版本号 patch 补丁号 ^1.12.2 //锁定主版本号（major ） ~1.12.2 //锁定主版本号和次版本号（minor） 1.12.2 //锁定所有版本号（patch） * //最新版本 配置信息： \"name\": \"opipjl\", //发布包的名 \"version\": \"1.0.0\", //版本号 \"description\": \"\", //描述 \"main\": \"index.js\", //包的入口 \"keywords\": [], //关键字 \"author\": \"\", //作者 \"license\": \"MIT\", //许可证协议 \"repository\":{\"type\":\"Git\",\"url\":\"git+ \" } //包的git地址 NPM脚本 package.json中的 scripts 字段 ​ 全局 --> 本地 & //可以连接两个命令行 不分先后 && //依次执行 分先后 test start //可以简写，不写run process.env.npmpackage变量名 //能拿到package里的值(只能在脚本中访问) echo $npm_package_config_dev //window疑似不支持 Cross-env (命令兼容平台) npm install --sava-dev cross-env //安装 简写：npm i -S -D cross-env cross-env NODE_ENV=test1 node ./test1.js //NODE_ENV 为命令中的变量名和变量值 后面为执行命令 process.env.NODE_ENV //在./test1.js中获取NODE_ENV的值 四、NRM 管理源 npm的镜像源管理工具 npm i -g nrm //安装nrm nrm ls //查看可选源 nrm use taobao //切换源 nrm test //测试源响应速度 NPX npx gulp -D //当galp未安装时，会生成一个临时路径安装gulp npx --on--install http-server //强制使用本地模块 npx --ignore--existing http-server //强制安装远程模块 commonJs 解意：nodeJs的第三方规范 四步骤使用模块 定义模块 --创建文件且写入内容 暴露模块 --将写入内容暴露给外部 引入模块 --其他文件引入模块 使用模块 --使用定义的模块 module.export = {name,age} //对象写法 exprot.name = name //赋值写法 //衍生写法 exports.default = { } module.exports = { default } 五、nodeJs内置模块 JS日志工具(log4js) const log4js = require('log4js') log4js.configure({ appenders: { cheese: { type: 'file', filename: 'cheese.log' } }, categories: { default: { appenders: ['cheese'], level: 'error' } }, }) const logger = log4js.getLogger('cheese') logger.level = 'debug' logger.debug() 1、url const url = require('url') const urlString = 'https://www.baidu.com:443/pathh/index.html?id=1#tag=2' const urlObj = { parse解析出的对象 } url.parse(urlString,true) //parse 数据解析 (true时，query为对象格式) url.format(urlObj) //format 反向编译路径 url.resolve(\"http://www.baiducom/a\",\"../\") //回到上一层 url.resolve(\"http://www.baiducom/a\",\"/b\") //替换a为b const urlParams = new URLSearchParams(url.parse(urlString).search) urlParams.get('id') //获取search指定字段 2、qureySring const querystring = require('querystring') const query = 'id=2&name=tongy&from=上海' querystring.parse(query,':', '/') //解析 第一个参数key和value中的分隔符，第二个是value和key分隔符 querystring.escape(query) //编码 percent-encoded查询字符串 querystring.unescape(queryEscape) //解码 const queryObj = { id: 2, name: 'toingyi', from: '北京' } id=2&name=toingyi&from=%E5%8C%97%E4%BA%AC querystring.stringify(queryObj, ':', '/') //编译对象，后面两个参数替换的=和&符号 const newQuery = querystring.stringify(queryObj, null, null, { encodeURIComponent(string) { //中文保持不变 return querystring.unescape(string) }, }) 3、http //request 本地请求的函数 response服务器返回函数 http.createServer((request, response) => { response.writeHead(404, {\"content-type\":} ) //第一个返回状态码，第二个对象，返回头部的配置 response.write('home111') //返回内容 不会断开 response.end() //返回内容 会断开 }) ​ 3.1、get 请求 https.get( 'https://www.xiaomiyoupin.com/mtop/mf/resource/data/list', //请求的地址 (result) => { let data = '' result.on('data', (chunk) => { //chunk传回的数据 data += chunk }) result.on('end', () => { //利用response返回数据 }) } ) 3.2、post 请求 const postData = querystring.stringify({}) const options = { protocol: 'http:', //协议 hostname: 'localhost', //主机名 method: 'post', //方法类型 port: '3000', //端口号 path: '/data', //路径 headers: { //请求的首部字段 'content-type': 'application/x-www-form-urlencoded', 'content-length': Buffer.byteLength(postData), }, } const server = http.createServer((request, response) => { // const req = http.request(options, (result) => {}) req.write(postData) req.end() response.end() }) server.listen(80808,()=>{}) //监听端口号 请求头部信息 content-type : 对照表 node浏览器调试 // --inspect-brk 第一行打断点 node --inspect --inspect-brk server.js node进程管理工具 supervisor nodemon //热更启动 forever pm2 //部署 insomnia //调试工具 post请求 3.3、跨域（JSONP\\CORS\\middleware\\爬虫） JSONP 原理：利用在浏览器端请求js不跨域的特性 //前端代码 function getData(data){ console.log(data) } //后端代码 const server = http.createServer((request, response) => { let urlStr = request.url let urlObj = url.parse(urlStr, true) switch (urlObj.pathname) { case '/api/data': response.write(`${urlObj.query.cb}(\"hello\")`) //spanp中的p是填充的意思 break default: response.write('page no found') } response.end() }) CORS 原理：设置Access-Control-Allow-Origin白名单 response.writeHead(200, { 'content-type': 'application/json;charser=utf-8', 'Access-Control-Allow-Origin': '*', //后面的是白名单 }) proxy middleware(http-proxy-middleware) 文档地址 if (/\\/wph/.test(urlStr)) { const proxy = createProxyMiddleware('/wph', { //'/wph'确定应该将哪些请求代理到目标主机 target: 'https://mapi-rp.vip.com/', //要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { //路径重写 '^/wph': '', }, }) proxy(request, response) 爬虫 cheerio //爬到数据后，可以建立虚拟DOM树来解析 function filterData(data){ const $ = cheerio.load(data) $('.xxxx p').each((index,el)=>{}) //each == foreach } 4、event(自定义事件) const EventEmilter = require('events') class MyEventEmilter extends EventEmilter {} //继承EventEmilter const event = new MyEventEmilter() event.on('play', (value) => { //绑定事件（监听作用） console.log(value) }) event.emit('play', '执行') //触发事件 5、文件操作 注：错误优先的回调函数 5.1 文件夹操作 //创建文件 fs.mkdir('logs', (err) => { if (err) throw err }) // throw 抛出异常 //修改文件名/文件夹名 fs.rename('logs', 'log', (err) => {}) //待修改名 修改名 回调 //删除文件夹 fs.rmdir('./log', (err) => {}) //读取文件夹 fs.readdir('./logs', (err, result) => {}) 5.2 文件操作 //创建文件 fs.writeFile('./logs/log1.log', 'hello\\nwordd', (err) => {}) // 追加文件 fs.appendFile('./logs/log1.log', '!!!', (err) => {}) // 删除文件 fs.unlink('./logs/log1.log', (err) => {}) // 读取文件 fs.readFile('./logs/log1.log', 'utf-8', (err, content) => {}) //读取文件路径 返回内容格式 回调 // 同步读取文件 const content = fs.readFileSync('./logs/log1.log', 'utf-8', (err, content) => {}) //promise同步读取(node版本10以上) const fsPromises = require('fs').promises ;async () => { let result = await fsPromises.readFile('./logs/log1.log') } //判断某个文件是否存在 fs.existsSync(\"./index.html\") 5.3 遍历目录所有文件 function readdir(dir) { fs.readdir(dir, (err, content) => { //读取文件夹 content.forEach((value, index) => { let joinDir = `${dir}/${value}` fs.stat(joinDir, (err, stats) => { // stat获取文件或目录的信息 if (stats.isDirectory()) { //isDirectory 是否为目录 readdir(joinDir) } else { fs.readFile(joinDir, 'utf-8', (err, content) => { console.log(content) }) } }) }) }) } 5.4 监听文件 //文件路径 是否监听文件 是否监视所有子目录 字符编码 //eventType:rename或change（文件名出现或者消失时，触发rename） filename:触发事件的文件名称 fs.watch('./logs/log0',true,true,'utf8' (eventType,filename) => {}) //文件路径 是否为二进制 是否监听文件 监听间隔 fs.watchFile('./logs/log0',true,true,5000 (err) => {}) fs.watch //有一小部分平台文件名出现或者消失时,不触发rename，但是效率更高 fs.watchFile //没有上面的平台问题 5.5 文件流 （zlib压缩文件） const fs = require('fs') const zlib = require('zlib') const gizp = zlib.createGzip() const readStream = fs.createReadStream('./logs.txt') //读取流 const writeStream = fs.createWriteStream('./logs.gzip') //写入流 readStream.pipe(gizp).pipe(writeStream) //pipe 管道注入内容 5.6 逐行读取 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('What do you think of Node.js? ', (answer) => { // TODO：记录答案到数据库中 console.log(`Thank you for your valuable feedback: ${answer}`); rl.close(); }); 6、加密（crypto） const crypto = require('crypto') const passsword = 'abc' const hash = crypto .createHash('sha256') //sha256 加密的算法也可以是md5 .update(passsword) //加密谁 .digest('hex') //加密的形式 hex：十六进制 dec：十进制 oct：八进制 bin：二进制 36集 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue2 vue3 "},"vue/vue2.html":{"url":"vue/vue2.html","title":"vue2","keywords":"","body":"vue2 基础 创建项目 npm install -g @vue/cli 安装vuecli vue create vue 创建vue项目 知识 查兼容性 caniuse.com vue3生命周期销毁名字改动 vue修饰符keyup后面可以直接跟键位值 keyup.65 可以给input标签加上vlaue来通过$event 获取 多选框可以直接通过value通过model添加进数组 方法可以直接写到标签内，getData() 直接return出去了， betterScroll 实现页面中拖动滚动拉动等属性功能 window 远程桌面连接 动态添加对象属性 vue2 无法直接拦截，vue3可以直接改 vue.set(对象,属性,true) vue set(vm.classObj,\"dd\",true) 组件： //中央事件主线 var bus = new Vue //通过new vue 创建实例 bus.$emit(\"kerwin\",data) //传入数据 bus.$On(\"kerwin\",(data)=>{}) //接受数据 插槽： 指令： 自定义指令 this默认指向是window // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { inserted(el,binding) { // inserted 被绑定元素插入父节点时调用 } }) vue.directive('focus',(el,binding)=>{}) //简写 创建或更新都会执行 //局部指令 directives: { focus: { inserted (el) { } }， focus: (el){}，//简写 } v-focus=\"{index:1,name:q}\" //只有一个参数，但是可以传数组和对象 vue3中，指令的生命周期名字改成和组件生命周期一致了 $nextTick() 页面渲染完毕之后再加载 进阶 vue.config.js 文件配置 @ 别名 =》永远指向src的绝对路径 module.exports={ devServer :{ proxy :{ //配置反向代理 '/ajax':{ //确定应该将哪些请求代理到目标主机 target:\"https://baidu.com\",//要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { '^/ajax': '',}, ///路径重写 } }, }, configureWebpack:{ resolve:{ alias:{ //配置别名 'assets':'@/assets', 'components':'@/components' } } } } 路由： router.js Vue.use(VueRouter) //注册路由插件，两个全局组件 router-view router-link routers:[ { path: '/bill', component: Layout, //跳转路径 redirect: '/bill/equipmentList', //路由重定向 alwaysShow: true, //是否显时 name: '账单管理', meta:{isShhow:true} children: [ //嵌套路由 { path: 'billList', name: '账单列表', component: () => import('@/shopViews/bill/billList'), }, ] }, { //路由重定向 path:\"*\", redirect:\"/index\" //未匹配到时 重定向到index } ] const touter = new VueRouter({ mode:\"history\",//路由模式 routes }) 声明式导航 编程式导航 this.$router.push('/index') //路由跳转 router路由大对象 route当前匹配的路由 //动态路由 path:'/index/:myId' //动态路由 router.js文件 this.$router.push(`/index/${id}`) this.$toute.params.myId //拿到当前路由参数 //命名路由 name:'kerwin' //router.js 路由中命名 this.$router.push({ //跳转到名字为kerwi的路由 name:'kerwi', params:{ id, } }) //返回上一级 router.back() 路由模式 hash 默认 window.onhashchange 监听路径是否改变 history 无#号 后端需要配置，当url无匹配资源时，返回同一个index.html页面 全局路由守卫 meta:{isShhow:true} //to可以获取到meta的值 to.meta.isShhow router.beforEach(to,from,next)=>{ //to 即将进入的路由对象 from 正要离开的路由对象 next() //直接放行 next('/login') //也可重定向 next({ path:'/login', query:{path:'index'} //可以拼接参数 }) } 独享路由守卫 { path: '/bill', component: Layout, redirect: '/bill/equipmentList', alwaysShow: true, name: '账单管理', meta:{isShhow:true}, beforEach(to,from,next)=>{ //写在路由内部，为独享路由守卫 next() } }, 局部路由守卫 本质上是路由的生命周期 beforeRouteEnter(to,from,next)=>{}组件创建前调用，不能使用组件实例this beforeRouteUpdate(to,from,next)=>{}路由被改变，但是组件被复用时调用 beforeRouteLeave(to,from,next)=>{}导航离开时该组件调用 路由懒加载 按需加载 component: () => import('@/shopViews/bill/billList'), 组件UI库 elmentUi pc端 饿了吗开发 地址 Vant 移动端 有赞开发 地址 axios 请求 import axios from \"axios\"; const service = axios.create({ //创建axios实例 baseURL: '', timeout: 10000 }); service.interceptors.request.use( //发请求前拦截 config => {}, error => {} ); service.interceptors.response.use( //响应后拦截 response => {}, error => {} ); export default service; Vuex 状态管理模式 文档地址 vue devtools 小工具 vuex 默认管理在内存，刷新页面后公共状态会丢失 vuex 持久化 todo 后端数据的缓存快照，较少重复数据请求 actions、mutations 中的方法可以相互调用 state import { mapState,mapActions,mapMutations } from 'vuex' state:{id:1} //公共状态 类似data this.$store.state.id //查看state的公共状态 this.id //查看state的公共状态 computed: { ...mapState(['id']) ...mapState({ //取别名 userId:(state) => state.id }) } getters getters:{ //类似计算属性 getdoosId:state.id=>(id)=>{ return state.id == id ? true :false } } computed: { ...mapGetter(['getdoosId']) } actions actions:{ //支持异步和同步 requert（store, data）{} //store 下面的为解构的 requert（{ commit, state }, data）{ http().then(id=>{ //异步请求 commit.changeId(id) //实质上还是通过store.commit,更改state值 }) } } this.$store.dispatch('requert',data )//触发actions方法 分发 this.$store.dispatch('requert',data ).then()//有返回值，就可以then this.requert(data) //同上面分发语法一致 methods: { ...mapActions([ 'requert', ]), } mutations mutations:{ //统一管理，可以被devtools记录 只支持同步函数 changeId(state,enterId){ state.id = enterId //更改state的公共状态 } } this.$store.commit('changeId',2) //触发mutations方法 交付 import { mapMutations } from 'vuex' this.changeId(2) // 同上面交付语法一致 methods: { ...mapMutations([ 'changeId', ]), } modules 将需要写的内容模块化出去 import demo from './demo' export default new Vuex.Store({ modules:{ demo //模块的名称 } ) Vuex 持久化 vuex-persistedstate vuex-persist npm 1 vuex-persistedstate --save //安装 import createPersistedState from \"vuex-persistedstate\" //在需要的地方安装使用 const store =newVuex.Store({ plugins: [createPersistedState()] //缓存vuex所有数据 plugins: [createPersistedState({ //缓存配置 storage:'localStorage', //存储的位置 key:'vuexData', //键位名字，默认vuex reducer:(state){ //需要保存的值。默认情况下，保存整个状态。 id:state.id } })] }) mixins 混入 地址 var mixin = new Vue({ created () { this.$store.commit('changeId',1) },//当没有cerated才会生效 mounted(){ this.$store.commit('changeId',2) } methods:{ //当没有相同的时，会添加进去，有不添加 a(){} } }) mixins: [mixin] //混入文件写了后，可以引入需要功能的文件中 "},"vue/vue3.html":{"url":"vue/vue3.html","title":"vue3","keywords":"","body":"vue3 注意 filters过滤器被删除 页面生命周期函数名换了 vue2是类写法，vue3函数写法(没有this了) 文件template下可以放多个根节点，而不像vue2只能放一个根节点 Composition Api介绍 指令 //全局指令 createApp(App).directive('focus', { mounted(el,binding) { //生命周期名字换了 } }) 路由 import { useRouter,useRoute } form 'vue-router' const router = useRouter() //router == this.$router const route = useRoute() //route == this.$route 取值 路由模式 const router = createRouter({ history: createWebHistory(), //history模式 history: createWebHashHistory(), //hash模式 routes }) 声明式导航 生命周期 VUE2 vue3 beforeCreate setup Created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeUpdate updated onUpdate beforeDestroy onBeforeUnmount destroyed onUnmounted import { reactive,onBeforeMount,onMounted } from \"vue\" setup(){ onBeforeMount(()=>{}) onMounted(()=>{}) } reactive 创建响应式对象 reactive参数不能是字符串或者数字，否则会警告 {{obj.myname}} change import { reactive } from \"vue\" setup () { const obj = reactive({ //可以写多个reactive函数 myname: \"toing\" //类似data中的值 }) const data = reactive({}) //可以直接创建空对象、空数组 const handleClick = () => { //触发的方法 obj.myname = \"changeToing\" } return {obj,handleClick,data} //要返回 }, ref 访问原生dom节点 import { ref } from \"vue\" setup () { const myref = ref() //创建ref函数 const handleClick = () => { //触发的方法 console.log(myref.value) } return {myref} }, ref拦截字符串 有reactive一样的功能，可以拦截数据 {{refText}} 此处默认省略了value 实际上refText.value--> change import { ref } from \"vue\" setup () { const refText= ref(\"kerwin\") //可以直接拦截字符串 const handleClick = () => { //触发的方法 refText.value = \"changeToing\" } return {refText,handleClick} }, toRefs 把reactive里的每个属性，转化成ref对象，再通过...展开，变成多个ref对象 在template中，用ref语法，js中用reactive语法 {{myname}}--{{myage}} import { reactive,toRefs } from \"vue\" setup () { const obj = reactive({ myname: \"toing\", myage:\"100\" }) return { ...toRefs(obj),//在template中不用写obj.了 } }, props&emit props:['myname'] setup(props,{emit}){ const myname = props.myname //接受父组件数据 const handleClick=()=>{ emit(\"isShow\",11) //子传父 } return{myname,handleClick} } 计算属性 setup(){ const computedList = computed(()=>{ return 1 }) return{computedList} } watch watch(()=>obj.name,(newValue,oldValue)=>{ console.log(newValue,oldValue) }) 自定义hooks 将逻辑代码分离页面，写在外部的js文件中 //页面vue文件 import {getData} from './app.js' //引入逻辑js文件 setup(){ const obj = getData() return { obj } } //app.js文件 逻辑代码 import {onMouted} from \"vue\" function getData() // const obj = ref([]) cosnt obj = reactive({ list.[] }) onMouted(()=>{ obj.list = [1,2,3] }) return obj } exprot { getData } vuex import { useStore } from 'vuex' //引入逻辑js文件 setup(){ const store = useStore() //store == this.$store } 依赖注入功能 provide、inject 共享后，所有子组件都可以访问到 //主要文件 const isShow = ref(true) provide(\"kerwin\",isShow) //提供一个名为kerwin的服务 //下级所有子组件，不限层级 const isShow = inject(\"kerwin\")//将一个名为kerwin服务的地址栈注入到isShow中 "},"git/":{"url":"git/","title":"git","keywords":"","body":"git "},"git/git随笔.html":{"url":"git/git随笔.html","title":"git","keywords":"","body":"git git init //初始化仓库 git add . //添加到暂存区 git status //查看git此时提交状态 git commit -m '提交备注' //提交到本地仓库 git log //查看提交记录 git reset --hard HEAD~1 //回退上一个版本，~2就是回退两个版本 git reflog //操作记录 git reset --hard 6位版本号 //切换提交版本 操作记录处获取版本号 git remote add 别名(origin) 远程仓库地址 //绑定git远程仓库 git push -u origin 推送的分支名称 //将内容推送到远程仓库，-u记住地址，下次直接git push origin 推送的分支名称 git clone 仓库地址 //项目克隆 git pull 远程仓库地址 分支名称 //拉取远程仓库 git branch -a //查看所有分支 git checkout -b aa //创建新的分支aa git checkout aa //切换到aa分支的 git push origin aa //推送aa分支到远程仓库aa分支 git push origin master:aa //推送master分支到远程仓库aa分支 git push origin :aa //删除远程仓库aa分支 git branch -d aa //删除本地aa分支 .gitigonre 忽略文件 node_modules //忽略node_modules 文件夹 /dist //忽略dist 文件夹 "},"WXgroup/":{"url":"WXgroup/","title":"微信公众号","keywords":"","body":"微信公众号 "},"WXgroup/微信公众号.html":{"url":"WXgroup/微信公众号.html","title":"微信公众号","keywords":"","body":"微信公众号 "},"webpack/":{"url":"webpack/","title":"webpack","keywords":"","body":"webpack "},"server/":{"url":"server/","title":"server","keywords":"","body":"server "},"server/ngin.html":{"url":"server/ngin.html","title":"ngin","keywords":"","body":"nginx nginx服务器 nginx-服务器文件夹目录中不能有中文目录 dist 打包文件夹 放入nginx服务器 文件夹目录中 每次改完文件，都需要重新加载 需要在 阿里云 加入安全组 添加80端口 命令行 .\\nginx.exe -c conf\\kerwin.conf //加载kerwin.conf 并启动服务器 .\\nginx.exe -s stop //关闭nginx服务器 .\\nginx.exe -s reload //重新加载 conf/kerwin.conf 文件夹 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream kerwin-server { server localhost:3001 weight=1; server localhost:3002 weight=1; } server { listen 80; //访问域名 server_name localhost; //访问协议 location / { root dist; //加载的文件夹名 index index.html index.htm; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location /ajax/ { //反向代理配置 proxy_pass https://m.maoyan.com; } } } "},"Ts/":{"url":"Ts/","title":"typeSctipt","keywords":"","body":"typeSctipt "},"Ts/基础篇.html":{"url":"Ts/基础篇.html","title":"基础篇","keywords":"","body":"基础篇 命令行 tsc xxx //执行ts文件，编译成js文件 tsc --init //生成ts配置文件 tsc --watch //ts自动编译成js文件 tsc --noEmitOnError --watch //当ts文件有错误时，不自动编译 tsconfig.json \"target\":\"es5\" //降级编译 编译后的js文件符合es5标准 \"strict\": true //打开严格模式 这个包括下面两个功能 \"noImplicitAny\": true //类型隐患检查 \"strictNullChecks\": true //严格的Null检查 \"rootDir\":\"./src\" //根目录 \"outDir\":\"./dist\" //输出目录 类型 string //字符串 number //数字 boolean //布尔 null //不存在 undefined //未初始化的值 never //不应该存在的状态 只能分配给任何类型 //数组 type[] //arr:number[] 数字类型数组 Array //Array 数字类型数组 //任何 any //obj: any = {} 任何值都可以赋值 类型注释 如果未注释类型，则会根据首次赋值来自动注释类型 匿名函数自动根据传入的值自动注释 //参数注释 let person: number = 1 //冒号+类型 //函数注释 function gteer(name: string) {} //: string 表示形参类型注释 function gteer(): string {} //string表示返回值类型注释(void表示没有返回值) () => string //箭头函数返回值类型 //对象注释 function gteer(pt:{x:number, y?:number}) //问好表示可不传y值 //联合类型 let id: number | string 类型别名 //使用type定义类型 type Point = { x:number,y:number } function getData(pt:Point) { } type ID = number | string function getData(id:ID) {} //扩展类型别名 type Bear = Point & { z:number } //通过&扩展 接口 //使用interface定义类型 interface Point { x:number y:number } const point:Point = {x:1,y:2} //扩展接口 interface Bear extends Point { z:number } const bear:Bear = {x:1,y:2,z:3} //添加新字段 interface Point { a:numbe } //重复定义，就可以新增加字段 类型断言 cosnt myCanvas = document.getElementById(\"canvas\") as HTMLCancasElement cosnt myCanvas = document.getElementById(\"canvas\") //string不能直接断言成number,需要有覆盖关系 const x = ('hello' as unknown) as number //unknown 未知的 //固定类型 let x = {} as const x! //断言x不是null或者undefined 文字类型 //字符串文字类型 let x: 'true'|'false' = \"true\" //数字文字类型 let x:-1 | 1 | 0 = 0 //布尔文字类型 let x: true | false = true 枚举 enum direction { a = 1, b, c, d } console.log(direction.a，direction.b) //1 2 3 4 会在每个后面依次加1 原语 bigint //非常大的整数 let a:bigint = 100n symbol //全局唯一引用 let a = Symbol(1) let b = Symbol(1) a == b //答案为false,因为symbol具有全局唯一性 类型缩小 typeof 类型守卫 object \\ string \\ number \\ bigint \\ boolean \\ symbol \\undefined \\ function if(typeof strs === \"object\") {} 真值缩小 条件、&&、||、if语句、！ 通过对上方的使用，过滤null和undefined 等值缩小 ===, !===, ==, != function example (x:string | number,y:string | boolean){ if(x === y){} //当两者都是string时执行里面内容 } let a: number | null | undefined if( a != null ){ } //当a等于null或undefined时，都不会执行里面内容 in 操作符缩小 type a1 = { a: ()=> void } type b1 = { b: ()=> void } type c1 = { a?: ()=> void; b?: ()=> void } function test( value: a1 | b1 | c1 ){ if( 'a' in a1 ){ //a1对象中是否有a属性 return (a as a1 ).a() //因为c1也有a属性，所以加个 as a1 缩小范围 } } instanceof 操作符缩小 x instanceof Foo //检查Foo是否是X的实例 if( x instanceof Date ){] //是否是Date上的实例 分配缩小 let x = Math.randow() 类型谓词 type Fish = { name:string swim: ()=> void } type Bird = { name: string fly: ()=> void } function isFish(pet: Fish | Bird):pet is Fish { return (pet as Fish).swim !== undefined } 联合类型 unions interface a { name:\"a\" radius:number } interface b{ name:\"b\" leftLength:number } type c = a | b //联合类型 function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength } } 穷进性检查 type c = a | b function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength default: //never 任何类型都不能分配给never let d: never = shape //never 不应该存在的状态 可以分配给任何类型 return d } } 函数 函数类型表达式 //fn : (a: string) => void type fnType = (a: string) => void function greeter(fn : fnType) { fn(\"hello\") } function prinTo(s:string){ console.log(s) } greeter(prinTo) //结果为 \"hello\" 调用签名 创建一个含有普通类型和函数类型的类型别名 type funType = { a: string (b: number) : booleam //参数列表和返回类型之间是：而不是=> } function getData(fn:funType){ cosnole.log(fn.a + fn(6)) } function fn1(n:number){ return true } fn1.a = 'hello' getData(fn1) //结果 hello true 构造签名 class ctor { s: string newfun(s: string) { this.s = s } } type funType = { new (a: string) : ctor //返回类或者构造函数 } function fn(ctor: funType){ return new ctor('hello') } const f = fn(ctor) console.log(f.s) //结果 hello "}}