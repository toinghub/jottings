{"./":{"url":"./","title":"前言","keywords":"","body":" 工作随笔 css js 功能技巧 补充 javaScript js 补充 vue vue2 vue3 vue 补充 typeSctipt 基础篇 ts 补充 node node-基础 设计原则 类之间的关系 设计原则 设计模式 数据加密 crypto-js git 微信公众号 webpack vite server ngin mock Linux 前端技巧功能 SSR websocket storage "},"jobRecord/":{"url":"jobRecord/","title":"工作随笔","keywords":"","body":"工作随笔 "},"jobRecord/css.html":{"url":"jobRecord/css.html","title":"css","keywords":"","body":"css随笔 position: sticky; //粘性布局 background: linear-gradient(180deg, #f2f2f2, #ffffff); //背景渐变 width:calc(100% - 100px) //单位换算计算 visibility:hidden; 隐藏元素（位置保留） :src=\"require('./1.jpg')\" uniapp 使用本地路径加require border-bottom: 50px solid transparent; //transparent 透明 user-select //用户选择文本 node:禁止 all:选中所有 filter:grayscale() //让网站变灰 伪类 | 伪元素 :empty //当节点为空时，执行此样式 :focus-within //元素获得焦点，或该元素的后代元素获得焦点，就会匹配 ::placeholder //修改placeholder的样式 ::selection //自定义选中样式 有限制样式 鼠标事件穿透当前层 pointer-events:none //鼠标事件穿透当前层 | 禁止鼠标事件 pointer-events:auto //鼠标不会穿透当前层 苹果底部边距 padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); 字体渐变色 background-image: linear-gradient(right, #7a492f, #cb7e3c); // 为元素提供渐变色背景 background-clip: text; // 用文本剪辑背景 -webkit-text-fill-color: transparent; //使用透明颜色填充文本 撑满子元素高度 overflow: hidden ; //父元素 margin-bottom:-200px;padding--bottom:200px //子元素 文本溢出 //单行 overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 white-space: nowrap; // 规定段落中的文本不进行换行 //多行 overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 display: -webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列 -webkit-line-clamp: 2; // 显示的行数 css变量 :root{ //web是:root 小程序是page --size:100 } div{ //var 读取 calc 计算 width:calc(var(--size)*2px) } @padding-md:15px padding:@padding-md css 类绑定 让每个元素之间隔开px display: flex | grid； gap: 20px; "},"jobRecord/js.html":{"url":"jobRecord/js.html","title":"js","keywords":"","body":"JavaScript随笔 location.reload(); //刷新页面 this.$route.query //获取路由参数 window.location //获取网址信息 Object.values(a) // 枚举a对象所有的属性值 arr.flat(Infinity) // 扁平化数组,Infinity默认深度最深，也可指定深度 [a,b] = [b,a] //使用解构，快速交互ab值 window.location.href=url //(动态输出跳转) 跳转链接 click.once //方法只执行一次 this.$nextTick //数据渲染完毕后执行 array.at(-1 ) //数组负索引（-1为最后一位） let b = a !== 0 ? ( a ? a: \"-\") : 0 //括号可省略 @Watch(\"$route\", { immediate: true }) //监听route可以获取页面显示 单行代码 //数组去重 const uniqueArr = (arr) => [...new Set(arr)]; //从url获取参数并转为对象 const getParameters = URL => JSON.parse(`{\"${decodeURI(URL.split(\"?\")[1]).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"')}\"}`) //检查对象是否为空 const isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object; //反转字符串 const reverse = str => str.split('').reverse().join(''); //生成随机十六进制颜色 const randomHexColor = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \"0\")}` //检查当前选项卡是否在后台 const isTabActive = () => !document.hidden; //两日期之间相差的天数 const dayDiff = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000); //将 RGB 转换为十六进制 const rgbToHex = (r, g, b) => \"#\" + ((1 知识 $attrs // 封装第三方库文件 使用attrs数据会及时响应 扩展运算符 let aobj = {a:1,b:2} let bobj = {a:3,b:4,c:5} aobj = {...aobj,...bobj} //{a:3,b:4,c:5} 操作符 cat?.name //可选链操作符 可以读取cat深处的值，不用担心是否有效 a ?? b //空值合并操作符 左侧为 null 或者 undefined 时，返回右侧数据 a ??= b //空值赋值运算符 左侧为 null 或者 undefined 时,右侧数据赋值给左侧 !. //非空断言操作符 ts内容 暂不解释 防抖动 debounce (wait, fun,data) { if (this.timer) { clearInterval(this.timer) } this.timer = setTimeout(() => { fun(data) }, wait) }, 节流 throttling (wait, fun) { let _this = this let now = +new Date() if (!this.last || (now - this.last) > wait) { _this.last = now fun() } }, 截取视频指定帧图片( 上传并保存在阿里云服务器 ) ?x-oss-process=video/snapshot,t_0,f_jpg,w_0,h_0,m_fast,ar_auto t：指定截图时间 w：指定截图宽度 h：指定截图高度 m：指定截图模式（默认模式，根据时间精确截图，fast则截取该时间点之前的最近的关键帧） f：图片的格式 ar：是否根据视频信息自动旋转图片 多字节替换 let searchStr = this.search searchStr = searchStr.replace(new RegExp(\" \", \"gm\"), \"|\"); searchStr = searchStr.replace(new RegExp(\",\", \"gm\"), \"|\"); 查找数组最大最小值 let data = [1,20,20,33,55,33,66,77] let maxNum = Math.max(...data); let minNum = Math.min(...data); uniapp 刷新页面 // 获取当前页面栈实例 const pages = getCurrentPages() // 获取当前页面 const curPage = pages[pages.length - 1] // 声明一个当前页面 curPage.onLoad(curPage.options) // 传入参数 浏览器关闭提醒 window.onbeforeunload = function (e) { e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) { e.returnValue = '关闭提示'; } // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示'; }; 时间格式 Vue.filter('formatDate1', function (value, fmt) { let getDate = new Date(value); let o = { 'M+': getDate.getMonth() + 1, //月份 'd+': getDate.getDate(),//日 'h+': getDate.getHours(),//小时 'm+': getDate.getMinutes(),//分钟 's+': getDate.getSeconds(),//秒数 'q+': Math.floor((getDate.getMonth() + 3) / 3),//季度 'S': getDate.getMilliseconds()//毫秒 }; if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (getDate.getFullYear() + '').substr(4 - RegExp.$1.length)) } for (let k in o) { if (new RegExp('(' + k + ')').test(fmt)) { fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length))) } } return fmt; }) "},"jobRecord/功能技巧.html":{"url":"jobRecord/功能技巧.html","title":"功能技巧","keywords":"","body":"功能技巧 微信小程序 微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 直播组件：直播拉流(live-player) + 直播推流(live-pusher) uni.setNavigationBarTitle 更改头部标题 webpack对于小于8k的图片，会将图片转成base64 直接插入图片 阻止用户截图 1.阻止右键保存和拖拽 2.失焦后加遮罩层 3.高速动态马赛克 "},"jobRecord/补充.html":{"url":"jobRecord/补充.html","title":"补充","keywords":"","body":"补充 命令行 npm cache clear --force //清楚缓存 "},"Js/":{"url":"Js/","title":"javaScript","keywords":"","body":""},"Js/js补充.html":{"url":"Js/js补充.html","title":"js 补充","keywords":"","body":"js 补充 文章地址 尾调用优化 当函数调用时,会在内存中形成调用记录, 又称\"调用帧\"（call frame） 当在文章末尾调用函数时，可以使用 return,来删除外层函数的调用记录，只保留内层函数的调用记录 function f() { let m = 1; let n = 2; return g(m + n); } 尾递归 因为仅有 1 个调用记录 ，所以不会存在内存溢出问题 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5); // 120 while 循环 只要指定条件为 true，循环就可以一直执行代码块 while (条件){ 需要执行的代码 } Object.is 和 ===的区别 object.is 可以区别-0和+0 object.is NaN等于另一个NaN值 Object.assign 和 扩展运算符... 的区别 Object.assign 会直接改变原数据的值 扩展运算符只能通过赋值都方式改变数据的值 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue2 ##vue3 "},"vue/vue2.html":{"url":"vue/vue2.html","title":"vue2","keywords":"","body":"基础 创建项目 npm install -g @vue/cli 安装vuecli vue create vue 创建vue项目 知识 查兼容性 caniuse.com vue3生命周期销毁名字改动 vue修饰符keyup后面可以直接跟键位值 keyup.65 可以给input标签加上vlaue来通过$event 获取 多选框可以直接通过value通过model添加进数组 方法可以直接写到标签内，getData() 直接return出去了， betterScroll 实现页面中拖动滚动拉动等属性功能 window 远程桌面连接 动态添加对象属性 vue2 无法直接拦截，vue3可以直接改 vue.set(对象,属性,true) vue set(vm.classObj,\"dd\",true) 组件： //中央事件主线 var bus = new Vue //通过new vue 创建实例 bus.$emit(\"kerwin\",data) //传入数据 bus.$On(\"kerwin\",(data)=>{}) //接受数据 对象组件传值 post: { id: 1, title: 'My Journey with Vue' } 组件使用v-model searchText = newValue\" /> value: { get() { return this.modelValue }, set(value) { this.$emit('update:modelValue', value) } } 透传 可以在js中访问组件的所有透传 this.$attrs ... //changeValue 将会透传到main根标签上 ... ... 插槽： 父组件通过插槽问子组件属性 默认插槽 具名插槽 Here's some contact info 指令： 自定义指令 this默认指向是window // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { inserted(el,binding) { // inserted 被绑定元素插入父节点时调用 } }) vue.directive('focus',(el,binding)=>{}) //简写 创建或更新都会执行 //局部指令 directives: { focus: { inserted (el) { } }， focus: (el){}，//简写 } v-focus=\"{index:1,name:q}\" //只有一个参数，但是可以传数组和对象 vue3中，指令的生命周期名字改成和组件生命周期一致了 $nextTick() 页面渲染完毕之后再加载 vue.config.js 文件配置 @ 别名 =》永远指向src的绝对路径 module.exports={ devServer :{ proxy :{ //配置反向代理 '/ajax':{ //确定应该将哪些请求代理到目标主机 target:\"https://baidu.com\",//要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { '^/ajax': '',}, ///路径重写 } }, }, configureWebpack:{ resolve:{ alias:{ //配置别名 'assets':'@/assets', 'components':'@/components' } } } } 路由： router.js Vue.use(VueRouter) //注册路由插件，两个全局组件 router-view router-link routers:[ { path: '/bill', component: Layout, //跳转路径 redirect: '/bill/equipmentList', //路由重定向 alwaysShow: true, //是否显时 name: '账单管理', meta:{isShhow:true} children: [ //嵌套路由 { path: 'billList', name: '账单列表', component: () => import('@/shopViews/bill/billList'), }, ] }, { //路由重定向 path:\"*\", redirect:\"/index\" //未匹配到时 重定向到index } ] const touter = new VueRouter({ mode:\"history\",//路由模式 routes }) 声明式导航 编程式导航 this.$router.push('/index') //路由跳转 router路由大对象 route当前匹配的路由 this.$router.replace('/') //和push功能一样，但是不会留下历史记录 //返回上一级 router.back() //动态路由 path:'/index/:myId' //动态路由 router.js文件 this.$router.push(`/index/${id}`) this.$toute.params.myId //拿到当前路由参数 //命名路由 name:'kerwin' //router.js 路由中命名 this.$router.push({ //跳转到名字为kerwi的路由 name:'kerwi', params:{ id, } }) 路由模式 hash模式（location.hash + hashchange 事件） window.onhashchange 监听路径是否改变 hash 模式的实现方式就是通过监听 URL 中的 hash 部分的变化，触发haschange事件，页面做出不同的响应。但是 hash 模式下，URL 中会带有 #，不太美观。 history模式 后端需要配置，当url无匹配资源时，返回同一个index.html页面 history 路由模式的实现，基于 HTML5 提供的 History 全局对象 history.pushState() //向当前浏览器会话的历史堆栈中添加一个状态，会改变当前页面url，但是不会伴随这刷新 history.replaceState()//将当前的会话页面的url替换成指定的数据，replaceState 会改变当前页面的url，但也不会刷新页面 全局路由守卫 meta:{isShhow:true} //to可以获取到meta的值 to.meta.isShhow router.beforEach(to,from,next)=>{ //to 即将进入的路由对象 from 正要离开的路由对象 next() //直接放行 next('/login') //也可重定向 next({ path:'/login', query:{path:'index'} //可以拼接参数 }) } 独享路由守卫 { path: '/bill', component: Layout, redirect: '/bill/equipmentList', alwaysShow: true, name: '账单管理', meta:{isShhow:true}, beforEach(to,from,next)=>{ //写在路由内部，为独享路由守卫 next() } }, 局部路由守卫 本质上是路由的生命周期 beforeRouteEnter(to,from,next)=>{}组件创建前调用，不能使用组件实例this beforeRouteUpdate(to,from,next)=>{}路由被改变，但是组件被复用时调用 beforeRouteLeave(to,from,next)=>{}导航离开时该组件调用 路由懒加载 按需加载 component: () => import('@/shopViews/bill/billList'), 组件UI库 elmentUi pc端 饿了吗开发 地址 Vant 移动端 有赞开发 地址 axios 请求 import axios from \"axios\"; const service = axios.create({ //创建axios实例 baseURL: '', timeout: 10000 }); service.interceptors.request.use( //发请求前拦截 config => {}, error => {} ); service.interceptors.response.use( //响应后拦截 response => {}, error => {} ); export default service; mixins 混入 地址 var mixin = new Vue({ created () { this.$store.commit('changeId',1) },//当没有cerated才会生效 mounted(){ this.$store.commit('changeId',2) } methods:{ //当没有相同的时，会添加进去，有不添加 a(){} } }) mixins: [mixin] //混入文件写了后，可以引入需要功能的文件中 动态绑定 动态属性 当值为 null 意为显式移除该绑定 在 HTML attribute 名称中都是不合法的都不可以，如空格、引号 避免在名称中使用大写字母，因为浏览器会强制将其转换为小写 不能使用复杂的动态参数 ... //等同于 :B=\"url\" //等同于 @B=\"change\" let A = 'B' 通过计算属性绑定class computed: { classObject() { return { active: this.isActive, text-danger: this.error } } } 通过对象绑定:style styleObject: { color: 'red', fontSize: '13px' } 依赖注入 为组件后代提供数据（provide） //提供静态数据 provide: { message: 'hello!' } //提供响应式数据 provide() { return { // 显式提供一个计算属性 message: computed(() => this.message) } } 获取上层组件提供的数据（inject） //声明需要的数据 inject: ['message'] //注入别名 inject: { message: { /* 本地属性名 */ from: 'message', // 注入来源名 当与原注入名同名时，这个属性是可选的 default: 'default' //注入默认值 } 内置组件 Transition v-enter-from 进入动画的起始状态 v-enter-active 进入动画的生效状态 v-enter-to 进入动画的结束状态 v-leave-from 离开动画的起始状态 v-leave-active 离开动画的生效状态 v-leave-to 离开动画的结束状态 //有名字的class名会以name为头 hello /* 进入和离开动画可以使用不同 持续时间和速度曲线。 */ .slide-fade-enter-active { transition: all 0.3s ease-out; } .slide-fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); } .slide-fade-enter-from, .slide-fade-leave-to { transform: translateX(20px); opacity: 0; } TransitionGroup 用于对 v-for 列表中的元素或组件的插入、移除和顺序改变添加动画效果。 每个元素都必须有一个独一无二的 key .list-move, /* 对移动中的元素应用的过渡 */ .list-enter-active, .list-leave-active { transition: all 0.5s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateX(30px); } /* 确保将离开的元素从布局流中删除 以便能够正确地计算移动的动画。 */ .list-leave-active { position: absolute; } Teleport 将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 Open Modal Hello from the modal! Close "},"vue/vue3.html":{"url":"vue/vue3.html","title":"vue3","keywords":"","body":"注意 filters过滤器被删除 页面生命周期函数名换了 vue2是类写法，vue3函数写法(没有this了) 文件template下可以放多个根节点，而不像vue2只能放一个根节点 生命周期 VUE2 vue3 beforeCreate setup Created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeUpdate updated onUpdate beforeDestroy onBeforeUnmount destroyed onUnmounted import { reactive,onBeforeMount,onMounted } from \"vue\" setup(){ onBeforeMount(()=>{}) onMounted(()=>{}) } vue3 功能介绍 副作用： 执行会直接或间接影响其他函数的执行 指令 //全局指令 createApp(App).directive('focus', { mounted(el,binding) { //生命周期名字换了 } }) 路由 import { useRouter,useRoute } form 'vue-router' const router = useRouter() //router == this.$router const route = useRoute() //route == this.$route 取值 路由模式 const router = createRouter({ history: createWebHistory(), //history模式 history: createWebHashHistory(), //hash模式 routes }) 声明式导航 自定义hooks 将逻辑代码分离页面，写在外部的js文件中 //页面vue文件 import {getData} from './app.js' //引入逻辑js文件 setup(){ const obj = getData() return { obj } } //app.js文件 逻辑代码 import {onMouted} from \"vue\" function getData() // const obj = ref([]) cosnt obj = reactive({ list.[] }) onMouted(()=>{ obj.list = [1,2,3] }) return obj } exprot { getData } CSS 功能 深度选择器 -- :deep() .a :deep(.b) {} css获取js变量 -- v-bind const theme = { color: 'red' } p { color: v-bind('theme.color'); } vue3 API介绍 app.config.globalProperties 注册能够被应用内所有组件实例访问到的全局属性的对象 app.config.globalProperties.mes = '111' this.$mes //111 reactive() 创建响应式对象 reactive参数不能是字符串或者数字，否则会警告 change import { reactive } from \"vue\" setup () { const obj = reactive({ //可以写多个reactive函数 myname: \"toing\" //类似data中的值 }) const data = reactive({}) //可以直接创建空对象、空数组 const handleClick = () => { //触发的方法 obj.myname = \"changeToing\" } return {obj,handleClick,data} //要返回 }, shallowReactive() reactive() 的浅层作用形式 只有属性的值会被原样存储和暴露 ref 的属性不会被自动解包 isReactive() 检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理 ref 访问原生dom节点 import { ref } from \"vue\" setup () { const myref = ref() //创建ref函数 const handleClick = () => { //触发的方法 console.log(myref.value) } return {myref} }, ref() 接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向属性.value 当 ref 赋值或者被赋值 reactive 时，ref会被解包（响应栈地址改变） 当在某个响应式数组或 Map 这样的原生集合类型中时， ref 元素不会解包 此处默认省略了value 实际上refText.value--> change import { ref } from \"vue\" setup () { const refText= ref(\"kerwin\") //可以直接拦截字符串 const handleClick = () => { //触发的方法 refText.value = \"changeToing\" } return {refText,handleClick} }, isRef() 检查某个值是否为 ref isRef(foo) unref() 参数是 ref，则返回内部值，否则返回参数本身 val = isRef(val) ? val.value : val 计算的一个语法糖 function useFoo(x: number | Ref) { const unwrapped = unref(x) // unwrapped 现在保证为 number 类型 } shallowRef() ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。 只对 .value 的访问是响应式的 triggerRef() 强制触发依赖于一个浅层 ref 的副作用 , 通常在对浅引用(shallowRef)的内部值进行深度变更后使用 const shallow = shallowRef({ greet: 'Hello, world' }) // 这次变更不应触发副作用，因为这个 ref 是浅层的 shallow.value.greet = 'Hello, universe' // 打印 \"Hello, universe\" triggerRef(shallow) toRef() 基于响应式对象上的一个属性，创建一个对应的 ref。 创建的 ref 与其源属性保持同步，改变源属性的值将更新 ref 的值，反之亦然。 const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, 'foo') // 更改该 ref 会更新源属性 fooRef.value++ console.log(state.foo) // 2 // 更改源属性也会更新该 ref state.foo++ console.log(fooRef.value) // 3 toRefs() 把reactive里的每个属性，转化成ref对象，再通过...展开，变成多个ref对象 在template中，用ref语法，js中用reactive语法 -- import { reactive,toRefs } from \"vue\" setup () { const obj = reactive({ myname: \"toing\", myage:\"100\" }) return { ...toRefs(obj),//在template中不用写obj.了 } }, 将一个响应式对象转换为一个普通对象 普通对象的每个属性都是指向源对象相应属性的 ref 每个单独的 ref 都是使用 toRef() 创建的 从组合式函数中返回响应式对象时 , 使用它，外部可以解构/展开返回的对象而不会失去响应性： function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // 在返回时都转为 ref return toRefs(state) } // 可以解构而不会失去响应性 const { foo, bar } = useFeatureX() isProxy() 查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理 computed() 只读 const plusOne = computed(() => count.value + 1) 可写 const plusOne = computed({ get: () => count.value + 1, set: (val) => { count.value = val - 1 } }) readonly() 返回一个原值的只读代理 const copy = readonly(original) shallowReadonly() readonly() 的浅层作用形式 只有根层级的属性变为了只读 ref 的属性不会被自动解包 const state = shallowReadonly({ foo: 1, nested: { bar: 2 } }) // 更改状态自身的属性会失败 state.foo++ // ...但可以更改下层嵌套对象 isReadonly(state.nested) // false isReadonly() 检查传入的值是否为只读对象 watch() 监听器 //监听一个 const count = ref(0) watch(count, (count, prevCount) => {},{deep:true}) //监听多个 watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {}) immediate 立即触发回调 deep 深层级变更时触发回调 flush:‘post’ 回调中能访问被 Vue 更新后的 DOM props&emit props:['myname'] setup(props,{emit}){ const myname = props.myname //接受父组件数据 const handleClick=()=>{ emit(\"isShow\",11) //子传父 } return{myname,handleClick} } watch watch(()=>obj.name,(newValue,oldValue)=>{ console.log(newValue,oldValue) }) 依赖注入功能 provide() 提供一个值，可以被后代组件注入 import { ref, provide } from 'vue' import { fooSymbol } from './injectionSymbols' // 提供静态值 provide('foo', 'bar') // 提供响应式的值 const count = ref(0) provide('count', count) // 提供时将 Symbol 作为 key provide(fooSymbol, count) inject() 注入一个由祖先组件或整个应用 提供的值 import { inject } from 'vue' import { fooSymbol } from './injectionSymbols' // 注入值的默认方式 const foo = inject('foo') // 注入响应式的值 const count = inject('count') // 通过 Symbol 类型的 key 注入 const foo2 = inject(fooSymbol) // 注入一个值，若为空则使用提供的默认值 const bar = inject('foo', 'default value') // 注入时为了表明提供的默认值是个函数，需要传入第三个参数 const fn = inject('function', () => {}, false) TypeScript 标注类型 组合式api 组合式函数约定用驼峰命名法命名，并以“use”作为开头 尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数 组合式函数中使用 ref() props 标注类型 传递给 defineProps 的泛型参数本身不能是一个导入的类型 interface Props { foo: string bar?: number } const props = defineProps() Props 解构默认值 withDefaults 帮助程序为默认值提供类型检查 确保返回的 props 类型删除了已声明默认值的属性的可选标志 export interface Props { msg?: string labels?: string[] } const props = withDefaults(defineProps(), { msg: 'hello', labels: () => ['one', 'two'] }) 通过 响应性语法糖开启，这个需要手动开启 interface Props { name: string count?: number } // 对 defineProps() 的响应性解构 // 默认值会被编译为等价的运行时选项 const { name, count = 100 } = defineProps() emits 标注类型 带调用签名的类型字面量 // 运行时 const emit = defineEmits(['change', 'update']) // 基于类型 const emit = defineEmits() ref 标注类型 const year: Ref = ref('2020') //上下两个方法等同 const year = ref('2020') year.value = 2020 // 成功！ reactive 标注类型 不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 import { reactive } from 'vue' interface Book { title: string year?: number } const book: Book = reactive({ title: 'Vue 3 指引' }) computed 标注类型 const double = computed(() => { // 若返回值不是 number 类型则会报错 }) 事件处理函数 标注类型 function handleChange(event: Event) { (event.target as HTMLInputElement).value } provide / inject 标注类型 provide 提供 InjectionKey 接口，继承自 Symbol 的泛型类型 , 用来在提供者和消费者之间同步注入值的类型 key 的类型放在单独的文件中，这样可以被多个组件导入 import { provide, inject } from 'vue' import type { InjectionKey } from 'vue' const key = Symbol() as InjectionKey provide(key, 'foo') // 若提供的是非字符串值会导致错误 inject // 第二个bar为默认值，没有的话类型则是 string | undefined const foo = inject('foo', 'bar') const foo = inject('foo') as string //强制转换类型 模板引用 标注类型 import { ref, onMounted } from 'vue' const el = ref(null) onMounted(() => { el.value?.focus() }) 组件模板引用 标注类型 如果想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的 Takeover 模式。 import { ref } from 'vue' const isContentShown = ref(false) const open = () => (isContentShown.value = true) defineExpose({ //定义暴露 open }) 为了获取 MyModal 的类型，需要通过 typeof 得到类型，再使用 TypeScript 内置的 InstanceType 工具类型获取实例类型 import MyModal from './MyModal.vue' const modal = ref | null>(null) const openModal = () => { modal.value?.open() } "},"vue/vuex.html":{"url":"vue/vuex.html","title":"vuex","keywords":"","body":"vuex 文档地址 vue devtools 小工具 vuex 默认管理在内存，刷新页面后公共状态会丢失 vuex 持久化 todo 后端数据的缓存快照，较少重复数据请求 actions、mutations 中的方法可以相互调用 vue2 state import { mapState,mapActions,mapMutations } from 'vuex' state:{id:1} //公共状态 类似data this.$store.state.id //查看state的公共状态 this.id //查看state的公共状态 computed: { ...mapState(['id']) ...mapState({ //取别名 userId:(state) => state.id }) } getters getters:{ //类似计算属性 getdoosId:state.id=>(id)=>{ return state.id == id ? true :false } } computed: { ...mapGetter(['getdoosId']) } actions actions:{ //支持异步和同步 requert（store, data）{} //store 下面的为解构的 requert（{ commit, state }, data）{ http().then(id=>{ //异步请求 commit.changeId(id) //实质上还是通过store.commit,更改state值 }) } } this.$store.dispatch('requert',data )//触发actions方法 分发 this.$store.dispatch('requert',data ).then()//有返回值，就可以then this.requert(data) //同上面分发语法一致 methods: { ...mapActions([ 'requert', ]), } mutations mutations:{ //统一管理，可以被devtools记录 只支持同步函数 changeId(state,enterId){ state.id = enterId //更改state的公共状态 } } this.$store.commit('changeId',2) //触发mutations方法 交付 import { mapMutations } from 'vuex' this.changeId(2) // 同上面交付语法一致 methods: { ...mapMutations([ 'changeId', ]), } modules 将需要写的内容模块化出去 namespaced //命名空间 当有多个模块时，需要定义命名空间 import demo from './demo' export default new Vuex.Store({ modules:{ demo //模块的名称 } ) Vuex 持久化 vuex-persistedstate vuex-persist npm 1 vuex-persistedstate --save //安装 import createPersistedState from \"vuex-persistedstate\" //在需要的地方安装使用 const store =newVuex.Store({ plugins: [createPersistedState()] //缓存vuex所有数据 plugins: [createPersistedState({ //缓存配置 storage:'localStorage', //存储的位置 key:'vuexData', //键位名字，默认vuex reducer:(state){ //需要保存的值。默认情况下，保存整个状态。 id:state.id } })] }) vue3 import { useStore } from 'vuex' //引入逻辑js文件 setup(){ const store = useStore() //store == this.$store const count = computed(() => store.state.count), const double = computed(() => store.getters.double) const increment = () => store.commit('increment'), const asyncIncrement = () => store.dispatch('asyncIncrement') } "},"vue/pinia.html":{"url":"vue/pinia.html","title":"pinia","keywords":"","body":"pinia 定义store 可以对defineStore的返回值进行任意命名 最好以 use 开头且以 Store 结尾。比如：useUserStore defineStore 的第二个参数可接受两类值：Setup 函数 和 Option 对象 import { defineStore } from 'pinia' // 第一个参数是你的应用中 Store 的唯一 ID。 export const useStore = defineStore('main', {}) Option 对象 类型 export const useCounterStore = defineStore('counter', { state: () => ({ count: 0 }), getters: { double: (state) => state.count * 2, }, actions: { increment() { this.count++ }, }, }) State 定义为一个返回初始状态的函数， 可以同时支持服务端和客户端。 state: () => { return { // 所有这些属性都将自动推断出它们的类型 count: 0, name: 'Eduardo', } }, TypeScript interface State { name: string age: number } const useStore = defineStore('storeId', { state: (): State => { return { name: '123', age: 123, } }, }) 访问 通过 store 实例访问 state，直接对其进行读写 const store = useStore() store.count++ 重置 -- $reset() 调用 store 的 $reset() 方法将 state 重置为初始值 const store = useStore() store.$reset() 变更/替换 -- $patch 补丁对象在同一时间更改多个属性 const store = useStore() store.$patch({ count: store.count + 1, age: 120, }) 函数方法来修改元素集合 store.$patch((state) => { state.items.push({ name: 'shoes', quantity: 1 }) state.hasChanged = true }) 订阅 -- $subscribe() 更改内容后，触发一次 const cartStore = useSomeStore() cartStore.$subscribe((mutation, state) => { mutation.type // 和 cartStore.$id 一样 mutation.storeId // 'cart' // 只有 mutation.type === 'patch object'的情况下才可用 mutation.payload // 传递给 cartStore.$patch() 的补丁对象。 // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem('cart', JSON.stringify(state)) }) 当组件被卸载时，将被自动删除 组件卸载后依旧保留它们，将 { detached: true } 作为第二个参数，将 state subscription 从当前组件中分离 const someStore = useSomeStore() // 在组件被卸载后，该订阅依旧会被保留。 someStore.$subscribe(callback, { detached: true }) 可以直接在pinia实例上侦听整个state watch( pinia.state, (state) => { // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem('piniaState', JSON.stringify(state)) }, { deep: true } ) Getter typescript 必须设置函数返回类型 可以 通过 this 访问到整个 store 实例 getters: { doubleCount(state) { return state.count * 2 }, doublePlusOne(): number { return this.doubleCount + 1 }, }, 访问 const store = useStore() store.doubleCount 访问其他store中的getter import { useOtherStore } from './other-store' getters: { otherGetter(state) { const otherStore = useOtherStore() }, }, Action 通过 this 访问整个 store 实例 action可以是异步的 actions: { async increment() { const preferences = await fetchPreferences() this.count++ }, }, 访问 const main = useMainStore() main.randomizeCounter() 访问其他 store 的 action import { useAuthStore } from './auth-store' actions: { fetch() { const auth = useAuthStore() } }, 订阅 -- $onAction() 监听 action 和它们的结果 after 表示在 promise 解决后，在 action 解决后执行回调函数 nError 在 action 抛出错误或 reject 时执行回调函数 const unsubscribe = someStore.$onAction( ({ store, // store 实例，类似 `someStore` args, // 传递给 action 的参数数组 after, // 在 action 返回或解决后的钩子 onError, // action 抛出或拒绝的钩子 }) => { // 这将在 action 成功并完全运行后触发。 // 它等待着任何返回的 promise after((result) => {}) // 如果 action 抛出或返回一个拒绝的 promise，这将触发 onError((error) => {}) } ) // 手动删除监听器 unsubscribe() 当组件被卸载时，将被自动删除 组件卸载后依旧保留它们，将 { detached: true } 作为第二个参数，将 state subscription 从当前组件中分离 const someStore = useSomeStore() // 在组件被卸载后，该订阅依旧会被保留。 someStore.$onAction(callback, true) Setup 函数 类型 export const useCounterStore = defineStore('counter', () => { const count = ref(0) const plusOne = computed(() => count.value + 1) function increment() { count.value++ } return { count, increment } }) State const count = ref(0) 访问 computed: { // 与从 store.count 中读取的数据相同 ...mapState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapState(useCounterStore, { myOwnName: 'count', // 你也可以写一个函数来获得对 store 的访问权 double: store => store.count * 2, // 它可以访问 `this`，但它没有标注类型 magicValue(store) { return store.someGetter + this.count + this.double }, }), }, 修改 -- mapWritableState() computed: { // 可以访问组件中的 this.count，并允许设置它。 ...mapWritableState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapWritableState(useCounterStore, { myOwnName: 'count', }), }, this.count++ //修改state.count属性 Getter const plusOne = computed(() => count.value + 1) 访问 computed: { ...mapGetter(useCounterStore, ['count']) }, Action function increment() { count.value++ } 访问 const store = useStore() store.randomizeCounter() methods: { ...mapActions(useCounterStore, ['increment']) // 与上述相同，但将其注册为this.myOwnName() ...mapActions(useCounterStore, { myOwnName: 'doubleCount' }), }, 响应式解构(storeToRefs) 使用 storeToRefs 将为每一个响应式属性创建引用 同时会跳过任何 action 或非响应式(非 ref/响应式)属性 const { name, doubleCount } = storeToRefs(store) "},"vue/vue补充.html":{"url":"vue/vue补充.html","title":"vue 补充","keywords":"","body":"vue 中动态引入图片为什么要是 require 为什么无法编译？ 动态引入时,编译的是 src 后面的变量，就导致与图片资源编译过后的资源地址不一致， 导致无法正确的引入资源 为什么加上 require 就好了? 通过 require 方法拿到的文件地址，是资源文件编译过后的文件地址 静态的引入时，为什么返回的是编译过后的文件地址？ 在 webpack 编译的 vue 文件的时候，遇见 src 等属性会默认的使用 require 引入资源路径 "},"Ts/":{"url":"Ts/","title":"typeSctipt","keywords":"","body":"typeSctipt "},"Ts/基础篇.html":{"url":"Ts/基础篇.html","title":"基础篇","keywords":"","body":"命令行 tsc xxx //执行ts文件，编译成js文件 tsc --init //生成ts配置文件 tsc --watch //ts自动编译成js文件 tsc --noEmitOnError --watch //当ts文件有错误时，不自动编译 tsconfig.json \"target\":\"es5\" //降级编译 编译后的js文件符合es5标准 \"strict\": true //打开严格模式 这个包括下面两个功能 \"noImplicitAny\": true //类型隐患检查 \"strictNullChecks\": true //严格的Null检查 \"rootDir\":\"./src\" //根目录 \"outDir\":\"./dist\" //输出目录 一、类型 类型一般大写字母开头 基本类型 string //字符串 number //数字 boolean //布尔 null //不存在 undefined //未初始化的值 //数组 type[] //arr:number[] 数字类型数组 Array //Array 数字类型数组 //任何 any //obj: any = {} 任何值都可以赋值 其他类型 never //不应该存在的状态 当函数异常\\中止\\死循环就是never void // 没有返回值函数的返回值 object // 任何的不是基本类型的值 object !== Object\\ unknown //代表任何的值，但是不能进行任何访问 function //描述所有函数值的属性，它的返回值总是any 原语 bigint //非常大的整数 let a:bigint = 100n symbol //全局唯一引用 let a = Symbol(1) let b = Symbol(1) a == b //答案为false,因为symbol具有全局唯一性 二、类型注释 如果未注释类型，则会根据首次赋值来自动注释类型 匿名函数自动根据传入的值自动注释 //参数注释 let person: number = 1 //冒号+类型 //函数注释 function gteer(name: string) {} //: string 表示形参类型注释 function gteer(): string {} //string表示返回值类型注释(void表示没有返回值) () => string //箭头函数返回值类型 //对象注释 function gteer(pt:{x:number, y?:number}) //问好表示可不传y值 //联合类型 let id: number | string 类型别名 //使用type定义类型 type Point = { x:number,y:number } function getData(pt:Point) { } type ID = number | string function getData(id:ID) {} //扩展类型别名 type Bear = Point & { z:number } //通过&扩展 也可以扩展接口 接口 //使用interface定义类型 interface Point { x:number y:number } const point:Point = {x:1,y:2} //扩展接口 interface Bear extends Point1，Point2 { //此处扩展可以合并多个其他接口 z:number } const bear:Bear = {x:1,y:2,z:3} //添加新字段 interface Point { a:numbe } //重复定义，就可以新增加字段 泛型类型 interface Box{ contents: Type } let box: Box = { contents:\"hello\" } 类型断言 //string不能直接断言成number,需要有覆盖关系 const x = ('hello' as unknown) as number //unknown 未知的 const B = A //断言A为number类型 //固定类型 let x = {} as const x! //断言x不是null或者undefined 文字类型 //字符串文字类型 let x: 'true'|'false' = \"true\" //数字文字类型 let x:-1 | 1 | 0 = 0 //布尔文字类型 let x: true | false = true 枚举 enum direction { a = 1, b, c, d } console.log(direction.a，direction.b) //1 2 3 4 会在每个后面依次加1 三、类型缩小 typeof 类型守卫 object \\ string \\ number \\ bigint \\ boolean \\ symbol \\undefined \\ function if(typeof strs === \"object\") {} 真值缩小 条件、&&、||、if语句、！ 通过对上方的使用，过滤null和undefined 等值缩小 ===, !===, ==, != function example (x:string | number,y:string | boolean){ if(x === y){} //当两者都是string时执行里面内容 } let a: number | null | undefined if( a != null ){ } //当a等于null或undefined时，都不会执行里面内容 in 操作符缩小 type a1 = { a: ()=> void } type b1 = { b: ()=> void } type c1 = { a?: ()=> void; b?: ()=> void } function test( value: a1 | b1 | c1 ){ if( 'a' in a1 ){ //a1对象中是否有a属性 return (a as a1 ).a() //因为c1也有a属性，所以加个 as a1 缩小范围 } } instanceof 操作符缩小 x instanceof Foo //检查Foo是否是X的实例 if( x instanceof Date ){] //是否是Date上的实例 分配缩小 let x = Math.randow() 类型谓词 type Fish = { name:string swim: ()=> void } type Bird = { name: string fly: ()=> void } function isFish(pet: Fish | Bird):pet is Fish { return (pet as Fish).swim !== undefined } 联合类型 unions interface a { name:\"a\" radius:number } interface b{ name:\"b\" leftLength:number } type c = a | b //联合类型 function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength } } 穷进性检查 type c = a | b function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength default: //never 任何类型都不能分配给never let d: never = shape //never 不应该存在的状态 可以分配给任何类型 return d } } 四、函数类型 函数类型表达式 //fn : (a: string) => void type fnType = (a: string) => void function greeter(fn : fnType) { fn(\"hello\") } function prinTo(s:string){ console.log(s) } greeter(prinTo) //结果为 \"hello\" 调用签名 创建一个除了函数类型外还有其他类型的对象 也可以使用 interface 创建 type funType = { a: string (b: number) : booleam //参数列表和返回类型之间是：而不是=> } function getData(fn:funType){ cosnole.log(fn.a + fn(6)) } function fn1(n:number){ return true } fn1.a = 'hello' getData(fn1) //结果 hello true 构造签名 class ctor { s: string newfun(s: string) { this.s = s } } type funType = { new (a: string) : ctor //这里返回类或者构造函数 也可填写其他返回值类型 } function fn(ctor: funType){ return new ctor('hello') } const f = fn(ctor) console.log(f.s) //结果 hello 泛型函数 类型推断 数组元素是什么类型，Type就是什么类型 保持输入和输出类型一致 Type 名可以随意取 function getData(arr: Type[]): Type | undefined { return arr[0] } getData(['a','b']) //返回值类型string 一般不写 TS会自行推断 getData([1,2]) //返回值类型number getData([]) //返回值类型undefined function getArray(arr: Input[], func: (arg: Input) => Output): Output[] { return arr.map(func) //map直接放函数是map的语法 } const parsed = getArray(['1','2','3'],(n) => parseInt(n)) 限制条件 // 传入a或b的参数，必须要有length这个属性 function longest( a: Type, b: Type ){ return a.length + b.length } const logestAttay = longest([1,2],[3,4]) const logestString = longest('11','22') 使用受限值 function getData( obj:Type, num: number ):Type { if(obj.length>num){ return obj }else{ // 当返回值不是Type时，可以在前面加一个泛型就好了 return { length: num } } } const arr = getData([1,2,3],6) 指定类型参数 function getData(arr1: Type[], arr2: Type[]): Type[] { return {...arr1,...arr2} } // 这儿强制分别规定泛型类型 const att = getData([1,2,3],['string']) 约束准则 1、尽可能使用类型参数本身，而不是对其约束 function getData(arr: Type[]){ return arr[0] } //correct function getData(arr Type){ return arr[0] } //error 2、尽可能少的使用类型参数 function getData(arr:Type[], func:(arg:Type)=> boolean){} //correct function getData( //error arr: type[], func: func ) 3、一个类型参数只出现在一个地方时，若非必要则尽量不写 function gerData(s:string){} //correct function getData(s :str){} //error 4、当函数里传递回调函数时，永远不要写一个可选参数 函数重载 基本语法 多人合作时，重载签名相当于是定义好了的函数，实现签名就是我们将重载签名拿来使用 尽可能使用联合类型的参数，而不是重载参数 ts可以把this当作参数名（注意不能使用箭头函数） //重载签名 function makeDte(timestamp: number): Date function makeDte(m: number, d:number , y:number): Date //实现签名 function makeDte(mOrtTimestamp: number, d?: number, y?:number): Date { if(d !== undefined && y !== undefined){ return new Date(y, mOrtTimestamp,d) }else{ return new Date(mOrtTimestamp) } } 函数形参展开 function getData(...a: number[]){ return a[0] } getData(1,2,3,4) 参数解构 type abc = {a: number, b: number, c: number} function sum({a, b, c}: abc){ console.log(a + b + c) } sum({a: 10, b: 3, c: 32}) 五、对象类型 只读属性（readonly） interface someType{ readonly prop: string //readonly 写了后，属性就变成了只读 readonly list: { //内部的属性可以修改，list不能修改 name: 'a' } } 索引签名 interface stringArray { //string 表示index必须是string number 是表示数组，可以使用数子得到对应的参数 [idnex: number]: string //index相当于数组索引的意思 } cosnt myArray:stringArray = ['a','b'] cosnt item = myArray[0] interface TextString { // string 是表示props必须是string，可以使用属性得到对应的属性值 [props: string]: number } cosnt textString: TextString = { x:100, y:200 } cosnt item = textString['x'] 六、从类型中创建类型 泛型 基本语法 function getData(arg: Type): Type { } let data = getData(\"hello\") //定义了泛型类型 let data = getData(\"hello\") //自动推断类型为string 泛型接口 interface a{ (arg: Type): Type } function c(arg:Type):Type{ return arg } let b:a = c 泛型类 calss a{ b: numType add:(x：numType) => numType } let mya = new a() //此处的number就是给泛型类属性加类型 约束中使用类型参数 // Key extends keyof Type 意思是 key是包含在type中 function getData(obj: Type, key: Key) { return obj[key] } let x = { a:1, b:2, c:3 } getData(x,'a') //主要是a,b,c就没有问题 泛型中使用类类型 function create(c: { new (): Type }): Type { retuQ YHGB VNrn new c() } keyof 类型操作符 将类型对象属性解析成属性联合类型 type point = { x:number, y:number } type P = keyof point //等同于 'x' | 'y' const p1:P = 'x' const p2:P = 'y' type map = { [k: string]: boolean } //因为js[]语法底层会把number转换成string，所以m的类型是number | string type M = keyof map const myArray = [ { name:'a', age:11 }, { name:'b', age:12 }, ] // Person类型 {name: string,age:number} type Person = typeof myArray[number] //number代表是任何一个数组下标，占位符 typeof 类型操作符 解析属性属于什么类型 是对象则返回对象的返回值类型 let s = \"hello\" let n: typeof s //此时n的类型就是s的类型 string //ReturnType 获取函数返回值类型 ts内置函数 type Predicate = (x: unkown)=> boolean type K = ReturnType 索引访问类型 type List = { a: number; b:string; c:boolean } type A = List['a' | 'b'] 条件类型 举例 interface a { live():void } interface b extends a { woof():void } type c = b extends a ? number : string //a被b约束，语法类似三元表达式 约束 //T 是否存在 {message: unknown } type MessageOf = T extends {message: unknown } ? T['message'] : never interface a { message: string } type b = MessageOf //结果为string 条件类型内推理 infer 定义泛型变量 获取返回值类型 七、类 类属性 class point { //class 关键词定义类 a: number constructor(){ //当point实例化时，会执行此函数，进行数据初始化 this.a = 0 //this默认指向类的实例 } } const p = new point() //()表示实例化类 readonly 修饰符 防止在构造函数之外进行赋值 class point { readonly name:string = 'hello' constructor(enterNmae?: string){ //只能在constructor中修改只读属性 if(enterNmae !== undefined){ this.name = enterNmae } } } const g = new point('通过传值进行更改') console.log(g) 构造器 -- constructor 构造函数不能有类型参数 构造函数不能有返回类型注释 class point { //class 关键词定义类 a: number; b: number; //有默认值可以不写类型，会自动推断。 //不写默认值实例化不传值是会报错 constructor(x:number = 0 , y:number = 0){ this.a = x this.b = y } } const p = new point(1,2) //类继承必须使用super函数 class base { k = 4 } class point extends base { constructor(){ super() } } 类的方法 class point { a: number = 10 b: number = 11 scale(n: number): void { //和外部函数使用没区别 this.a *= n this.b *= n } } const p = new point() p.scale(10) console.log(p.a,p.b) Getters/Serters 存取器 如果只存在get，没有set，则该属性自动是只读的 如果没有指定setter参数的类型，则从getter的返回类型推断出来 访问器和设置器必须是相同的成员可见性 class C { _length = 0 get length(){ return this._length } set length(value) { this._length = value } } let c: C = new C() let a = c.length //会执行类里get关键字的函数 c.length = 100 //会执行类里set关键字的函数 索引签名 class myClass { [s: string]: boolean | ((s: string) => boolean) x = true check(s: string) { return this[s] as boolean } } 类继承 - implements 子句 一个类去继承或者实现一个接口 实现父级类的公共内容 父级类不会改变类的类型，子级类可以进行兼容 父类可选属性，继承的子类可以选择不实现 interface A { x: number y: number } class B implements A { //除了A中的可选属性，其他属性必须写上 x = 0 y = 0 } 类继承 - extends 子句 一个类继承另外一个类 继承的类具备父类所有的属性和方法，并且还可以定义自己的一些属性和方法 class A { x:number = 1 } class B extends A { y:number = 2 } 类重写 覆盖类的时候，类型需要兼容 class base { greet() { console.log(\"hello\") } } class Derived extends base { greet(name?: string) { //直接覆盖父类greet方法 if (name === undefined) { super.greet() //super 指向父类的方法 this指向属性 } else { console.log(name) } } } const d = new Derived() d.greet() d.greet(\"子类的方法\") 初始化顺序 父类: 基类 子类：派生类 1、基类的字段被初始化 2、基类构造函数运行 3、派生类的字段被初始化 4、派生类构造函数运行 class Base { name = 'base' constructor() { console.log(this.name) } } class Derived extends Base { name = 'derived' } const d = new Derived() 继承内置类型 class MsgError extends Error {} //Error 内置类型 成员的可见性 -- public 公开的，默认值。任何对象在任何地方都可以访问 class Base { public name = 'base' //public 默认值，可不写 } const d = new Base() d.name 成员的可见性 -- protected protected 受保护的。只能在当前类和子类中进行访问 派生类可以暴露基类受保护的成员 二次赋值即可 class Base { protected base() { return 'base' } } class Derived extends Base { title = super.base() test() { console.log(super.base()) } } const d = new Derived() d.test() 成员的可见性 -- private 私有的。只能在当前类中进行访问 class Base { private x = 1 base() { console.log(this.x) } } const d = new Base() d.base() TypeSctipr 允许跨实例的私有访问 class A { private x = 10 public sameAs(other: A) { //通过函数暴露私有化变量 return other.x } } const a = new A() console.log(a.sameAs(a)) 静态成员 -- static 静态名称避免使用：name,length,call等特殊名字 TypeScript 没有静态类的概念，因为有函数和普通对象 修饰符可以连着使用，这儿也可以加上成员可见性 基类可以被派生类继承 class myClass { static x = 0; static printX() { myClass.x //可以直接获取 } } const a = myClass.x 类里的static区块 把静态成员私有化，类私有域 class myClass { static #x = 0; //加了#号就只能在类内部使用 static printX() { return myClass.#x } static { //静态区块，默认会执行 console.log(\"hell\") } } 泛型类 静态成员不能使用泛型 class Box{ contents: Type constructor(value: Type) { this.contents = value } } const a = new Box(`1111`) const b: Box = new Box(`1111`) const c = new Box(`1111`) 类运行时的this class MyClass { name: 'MyClass' //原代码 getName() { //这样写，下面obj里c.getNam调用时this指向会边 return this.name } //解决方法1 //利用箭头函数，固定this指向 //会浪费更多的内存，不能在派生类中调用这个函数 getName = ()=>{ return this.name } //解决方法2 //this: MyClass 作用是告诉这个函数this指向地方，提前报错 getName(this: MyClass) { return this.name } } const c = new MyClass() const obj = { name: 'obj', getName: c.getName } console.log(obj.getName()) this 类型 class Box { content: string = '' sameAS(other: this) { //通过传入的值来固定this的指向 return other.content === this.content } } class DerivedBox extends Box { otherContent: string = '?' } const bsse = new Box() const derived = new DerivedBox() derived.sameAS(derived) 基于类型守卫的this ？ 类和方法返回值的位置使用 this is 类型 前面的是固定写法 class Box{ value?: T hasValue(): this is { value: T } { return this.value !== undefined } } const box = new Box() box.value = 'hello' if (box.hasValue()) { console.log(box.value) } 参数属性 class Box { //x加了public后，外部也可以访问了 constructor(public x: number) { this.x = x } } const p = new Box(100) p.x = 200 类表达式 const box = class { content: Type constructor(value: Type) { this.content = value } } const m = new box('hello') console.log(m.content) 抽象类和成员 -- abstract 不能被实例化，只能当作基类，派生类继承 abstract class Base { abstract getNmae(): string //抽象成员 不能被实现 printName() { console.log(this.getNmae) } } class Derived extends Base { getNmae() { return 'world' } } const b = new Derived() b.getNmae() b.printName() 类之间的关系 内部类型一样，可以相互兼容 class A { x = 0 y = 0 } class B { x = 0 y = 0 } const p: A = new B 类可以包含使用 class A { x = 0 y = 0 } class B { x = 0 y = 0 z = 0 } const p: A = new B //b当成了a的继承类 一个空的类可以传入任何参数 class A {} function fn(x:A){ } fn(window) //这儿传入什么，A就会有什么参数 八、模块 模块在自己的范围内执行 ES模块语法 export default function A() { //导出模块 return 'hello' } import hell from './hell' // 引入模块， 一般不写后缀，ts后缀不能写 heel() export let a = 1 export let b = 1 import {a,b} from './hell' console.log(a,b) 额外的导入语法 export let a = 1 export default class B {} //默认的导出 //B1 是类B的别名，as 启用别名 import B1, {a as a1} from './hell' // * 导入所有的东西 import * as math from './hell' // default() 导出默认的导出 const C = new math.default() TS特定的ES模块语法 export type dataType = { a: string b: number c: boolean } export interface dataInterface { a: string b: number c: boolean } import type { dataType,dataInterface } from './hell' export let a = 1 import { a, type dataType, type dataInterface } from './hell' commonJs语法 function getData(): void { } let a = 1 module.exports = { //导出 a, getData } exports.getData = getData //导出 cosnt data = require('./test')//导入 "},"Ts/ts补充.html":{"url":"Ts/ts补充.html","title":"ts 补充","keywords":"","body":"ts 补充 注意事项 不确定类型 , 应该使用unknown 当属性可选时，应该用类继承的方式去书写 vue2 补充 @Watch('message',{ immediate:true, // immediate表示在watch中首次绑定的时候，是否执行handler， // 值为true则表示在watch中声明的时候，就立即执行handler方法， // 值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。 }) "},"node/":{"url":"node/","title":"node","keywords":"","body":"node基础 "},"node/node基础.html":{"url":"node/node基础.html","title":"node-基础","keywords":"","body":"一、nvm指令 nvm list //查看已安装的nodejs版本 nvm on // 启用node.js版本管理 nvm off // 禁用node.js版本管理(不卸载任何东西) nvm install // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0 nvm use //使用某一version的nodejs nvm uninstall // 卸载指定版本的nodejs nvm alias default //切换默认版本 代码工具 lodash npm搜索 官网lodash.com underscore 开源项目CDN 二、NPM知识 命令行 npm init -y //创建package文件 --sava //安装 -S 简写 --dev //开发环境使用 -D 简写 -g //全局安装 install //安装 i 简写 npm uninstall gulp -D //卸载包 npm list //显示包管理的关系 npm list | grep 包名 //显示指定包管理的关系 三层关系 npm i --production //只装生产环境的包 npm view 包名 versions //查看包版本号 -V 简写 npm i 包名@版本号 -S //安装包指定版本号 版本号可不写 npm outdated //查看那些包已过期 npm update //更新包 npm cache clean --force //强制清除缓存 npm config get registry //查看当前源 npm config set registry 地址 //切换源 npm i git+https://git@ (git地址) //下载git项目（当hhs时，把https改成ssh） 使用npm i可以重新直接安装package里的内容 package-lock 显示包依赖关系 __dirname //当前代码所在文件的物理路径 包类型 1.内置的包 2.第三方库 3.自己定义的包 上传包 npm init -y 初始化 npm adduser 添加账户 npm publish 上传包 三、package 文件解析 package中的 ^1.12.1的^表示当前版本号需要按语义做适配 major 主版本号 minor 次版本号 patch 补丁号 ^1.12.2 //锁定主版本号（major ） ~1.12.2 //锁定主版本号和次版本号（minor） 1.12.2 //锁定所有版本号（patch） * //最新版本 配置信息： \"name\": \"opipjl\", //发布包的名 \"version\": \"1.0.0\", //版本号 \"description\": \"\", //描述 \"main\": \"index.js\", //包的入口 \"keywords\": [], //关键字 \"author\": \"\", //作者 \"license\": \"MIT\", //许可证协议 \"repository\":{\"type\":\"Git\",\"url\":\"git+ \" } //包的git地址 NPM脚本 package.json中的 scripts 字段 ​ 全局 --> 本地 & //可以连接两个命令行 不分先后 && //依次执行 分先后 test start //可以简写，不写run process.env.npmpackage变量名 //能拿到package里的值(只能在脚本中访问) echo $npm_package_config_dev //window疑似不支持 Cross-env (命令兼容平台) npm install --sava-dev cross-env //安装 简写：npm i -S -D cross-env cross-env NODE_ENV=test1 node ./test1.js //NODE_ENV 为命令中的变量名和变量值 后面为执行命令 process.env.NODE_ENV //在./test1.js中获取NODE_ENV的值 四、NRM 管理源 npm的镜像源管理工具 npm i -g nrm //安装nrm nrm ls //查看可选源 nrm use taobao //切换源 nrm test //测试源响应速度 NPX npx gulp -D //当galp未安装时，会生成一个临时路径安装gulp npx --on--install http-server //强制使用本地模块 npx --ignore--existing http-server //强制安装远程模块 commonJs 解意：nodeJs的第三方规范 四步骤使用模块 定义模块 --创建文件且写入内容 暴露模块 --将写入内容暴露给外部 引入模块 --其他文件引入模块 使用模块 --使用定义的模块 module.export = {name,age} //对象写法 exprot.name = name //赋值写法 //衍生写法 exports.default = { } module.exports = { default } 五、nodeJs内置模块 JS日志工具(log4js) const log4js = require('log4js') log4js.configure({ appenders: { cheese: { type: 'file', filename: 'cheese.log' } }, categories: { default: { appenders: ['cheese'], level: 'error' } }, }) const logger = log4js.getLogger('cheese') logger.level = 'debug' logger.debug() 1、url const url = require('url') const urlString = 'https://www.baidu.com:443/pathh/index.html?id=1#tag=2' const urlObj = { parse解析出的对象 } url.parse(urlString,true) //parse 数据解析 (true时，query为对象格式) url.format(urlObj) //format 反向编译路径 url.resolve(\"http://www.baiducom/a\",\"../\") //回到上一层 url.resolve(\"http://www.baiducom/a\",\"/b\") //替换a为b const urlParams = new URLSearchParams(url.parse(urlString).search) urlParams.get('id') //获取search指定字段 2、qureySring const querystring = require('querystring') const query = 'id=2&name=tongy&from=上海' querystring.parse(query,':', '/') //解析 第一个参数key和value中的分隔符，第二个是value和key分隔符 querystring.escape(query) //编码 percent-encoded查询字符串 querystring.unescape(queryEscape) //解码 const queryObj = { id: 2, name: 'toingyi', from: '北京' } id=2&name=toingyi&from=%E5%8C%97%E4%BA%AC querystring.stringify(queryObj, ':', '/') //编译对象，后面两个参数替换的=和&符号 const newQuery = querystring.stringify(queryObj, null, null, { encodeURIComponent(string) { //中文保持不变 return querystring.unescape(string) }, }) 3、http //request 本地请求的函数 response服务器返回函数 http.createServer((request, response) => { response.writeHead(404, {\"content-type\":} ) //第一个返回状态码，第二个对象，返回头部的配置 response.write('home111') //返回内容 不会断开 response.end() //返回内容 会断开 }) ​ 3.1、get 请求 https.get( 'https://www.xiaomiyoupin.com/mtop/mf/resource/data/list', //请求的地址 (result) => { let data = '' result.on('data', (chunk) => { //chunk传回的数据 data += chunk }) result.on('end', () => { //利用response返回数据 }) } ) 3.2、post 请求 const postData = querystring.stringify({}) const options = { protocol: 'http:', //协议 hostname: 'localhost', //主机名 method: 'post', //方法类型 port: '3000', //端口号 path: '/data', //路径 headers: { //请求的首部字段 'content-type': 'application/x-www-form-urlencoded', 'content-length': Buffer.byteLength(postData), }, } const server = http.createServer((request, response) => { // const req = http.request(options, (result) => {}) req.write(postData) req.end() response.end() }) server.listen(80808,()=>{}) //监听端口号 请求头部信息 content-type : 对照表 node浏览器调试 // --inspect-brk 第一行打断点 node --inspect --inspect-brk server.js node进程管理工具 supervisor nodemon //热更启动 forever pm2 //部署 insomnia //调试工具 post请求 3.3、跨域（JSONP\\CORS\\middleware\\爬虫） JSONP 原理：利用在浏览器端请求js不跨域的特性 //前端代码 function getData(data){ console.log(data) } //后端代码 const server = http.createServer((request, response) => { let urlStr = request.url let urlObj = url.parse(urlStr, true) switch (urlObj.pathname) { case '/api/data': response.write(`${urlObj.query.cb}(\"hello\")`) //spanp中的p是填充的意思 break default: response.write('page no found') } response.end() }) CORS 原理：设置Access-Control-Allow-Origin白名单 response.writeHead(200, { 'content-type': 'application/json;charser=utf-8', 'Access-Control-Allow-Origin': '*', //后面的是白名单 }) proxy middleware(http-proxy-middleware) 文档地址 if (/\\/wph/.test(urlStr)) { const proxy = createProxyMiddleware('/wph', { //'/wph'确定应该将哪些请求代理到目标主机 target: 'https://mapi-rp.vip.com/', //要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { //路径重写 '^/wph': '', }, }) proxy(request, response) 爬虫 cheerio //爬到数据后，可以建立虚拟DOM树来解析 function filterData(data){ const $ = cheerio.load(data) $('.xxxx p').each((index,el)=>{}) //each == foreach } 4、event(自定义事件) const EventEmilter = require('events') class MyEventEmilter extends EventEmilter {} //继承EventEmilter const event = new MyEventEmilter() event.on('play', (value) => { //绑定事件（监听作用） console.log(value) }) event.emit('play', '执行') //触发事件 5、文件操作 注：错误优先的回调函数 5.1 文件夹操作 //创建文件 fs.mkdir('logs', (err) => { if (err) throw err }) // throw 抛出异常 //修改文件名/文件夹名 fs.rename('logs', 'log', (err) => {}) //待修改名 修改名 回调 //删除文件夹 fs.rmdir('./log', (err) => {}) //读取文件夹 fs.readdir('./logs', (err, result) => {}) 5.2 文件操作 //创建文件 fs.writeFile('./logs/log1.log', 'hello\\nwordd', (err) => {}) // 追加文件 fs.appendFile('./logs/log1.log', '!!!', (err) => {}) // 删除文件 fs.unlink('./logs/log1.log', (err) => {}) // 读取文件 fs.readFile('./logs/log1.log', 'utf-8', (err, content) => {}) //读取文件路径 返回内容格式 回调 // 同步读取文件 const content = fs.readFileSync('./logs/log1.log', 'utf-8', (err, content) => {}) //promise同步读取(node版本10以上) const fsPromises = require('fs').promises ;async () => { let result = await fsPromises.readFile('./logs/log1.log') } //判断某个文件是否存在 fs.existsSync(\"./index.html\") 5.3 遍历目录所有文件 function readdir(dir) { fs.readdir(dir, (err, content) => { //读取文件夹 content.forEach((value, index) => { let joinDir = `${dir}/${value}` fs.stat(joinDir, (err, stats) => { // stat获取文件或目录的信息 if (stats.isDirectory()) { //isDirectory 是否为目录 readdir(joinDir) } else { fs.readFile(joinDir, 'utf-8', (err, content) => { console.log(content) }) } }) }) }) } 5.4 监听文件 //文件路径 是否监听文件 是否监视所有子目录 字符编码 //eventType:rename或change（文件名出现或者消失时，触发rename） filename:触发事件的文件名称 fs.watch('./logs/log0',true,true,'utf8' (eventType,filename) => {}) //文件路径 是否为二进制 是否监听文件 监听间隔 fs.watchFile('./logs/log0',true,true,5000 (err) => {}) fs.watch //有一小部分平台文件名出现或者消失时,不触发rename，但是效率更高 fs.watchFile //没有上面的平台问题 5.5 文件流 （zlib压缩文件） const fs = require('fs') const zlib = require('zlib') const gizp = zlib.createGzip() const readStream = fs.createReadStream('./logs.txt') //读取流 const writeStream = fs.createWriteStream('./logs.gzip') //写入流 readStream.pipe(gizp).pipe(writeStream) //pipe 管道注入内容 5.6 逐行读取 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('What do you think of Node.js? ', (answer) => { // TODO：记录答案到数据库中 console.log(`Thank you for your valuable feedback: ${answer}`); rl.close(); }); 6、加密（crypto） const crypto = require('crypto') const passsword = 'abc' const hash = crypto .createHash('sha256') //sha256 加密的算法也可以是md5 .update(passsword) //加密谁 .digest('hex') //加密的形式 hex：十六进制 dec：十进制 oct：八进制 bin：二进制 36集 "},"设计原则/":{"url":"设计原则/","title":"设计原则","keywords":"","body":"设计原则 "},"设计原则/类之间的关系.html":{"url":"设计原则/类之间的关系.html","title":"类之间的关系","keywords":"","body":"类之间的关系 泛化关系 -- 继承 对已有类型进行扩展 派生类继承非抽象类的基类，并且对基类进行一个更细致化的扩展 suv是小汽车的一个泛化关系，suv是小汽车的一个派生类 class Car { showType() { console.log(\"基类的方法\") } } class SvuCar extends Car{ showType(): void { console.log('对基类的二次扩展') } } 实现关系 -- 继承 实现了基类定义了但是不能实现的功能 基类属于一个抽象类，需要派生类进行一个继承，去实现对应的功能 车则是一个抽象的定义，而小汽车则是对车进行了二次的定义并且实现了，所以小汽车是对车进行了一个实现定义的关系 abstract class Transfrom { abstract move(): void } class Bike extends Transfrom { move() { return '实现transfrom' } } const a = new Bike a.move() //'实现transfrom' 聚合关系 -- 非强关联 由几个类进行组合一个类，进行一个方法的实现 类A和类B，类A包含类B， 类B是类A的成员变量 双方不是平级的，是整体和部分的关系 学生聚合起来，组成学习小组，xx学习小组撤销了，学生并不会因此消失 class Student { //学生 name: string constructor(name: string) { this.name = name } } class Group { //小组 member: Array constructor() { this.member = new Array() } add(item: Student) { this.member = [...this.member, item] } } const group = new Group() group.add(new Student('小x')) //添加小组成员 组合关系 -- 强关联 由多个类组成一个类，进行一个方法的实现 A类由B类C类组成,A类消失，B类C类也随之消失 双方不是平级的，是整体和部分的关系 若干个班级组成xx学校，xx学校消失了，xx学校xx班级也随之消失 class School { //学校 grades: Array = new Array() initGrades(...grade: Grade[]) { this.grades = [...this.grades, ...grade] } deinit() { this.grades = new Array() } } class Grade { //班级 name: string constructor(name: string) { this.name = name } } const school = new School() school.initGrades(new Grade('一年级x班'), new Grade('二年级x班')) 关联关系 -- 强关联 A类中使用B类，A类就对B类进行一个关联 A类销毁时，A类对类的关联也随之消失 关联关系双方是平级的，是个体和个体的关系 class IdCar { //身份证 id: number constructor(id: number) { this.id = id } } class Civics { //公民信息 name: string idCard: IdCar constructor(name: string, id: number) { this.name = name this.idCard = new IdCar(id) } ShowMeYourCard(): IdCar { return this.idCard } } 依赖关系 -- 临时性 -- 动态性 当A类某个参数依赖于B类，当A类需要某个参数时，B类则对A类进行依赖注入 class IdCar { //身份证 id: number constructor(id: number) { this.id = id } } class Civics { //公民身份信息 name: string idCard: IdCar constructor(name: string, idCar: IdCar) { this.name = name this.idCard = idCar } } let a = new Civics('张三',new IdCar(123))//公民内部的IdCar就是初始化的注入 "},"设计原则/设计原则.html":{"url":"设计原则/设计原则.html","title":"设计原则","keywords":"","body":"设计原则 单一职责原则表达实现类要职责单一 里氏替换原则表达不要破坏继承体系 依赖倒置原则表达面向接口编程 接口隔离原则表达在设计接口的时候要精简单一 迪米特法则表达要降低耦合 开闭原则是总纲，表达要对扩展开放，对修改关闭。 单一职责原则(SRP) 定义 一个类应该只有一个发生变化的原因，即一个类只负责一项职责 核心 解耦和增强内聚性 优点 降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多。 提高类的可读性，提高系统的可维护性。 变更引起的风险降低，变更是必然的，如果 SRP 遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 开闭原则(OCP) 定义 软件中的实体（类，模块，函数等等）应该对扩展开放，对修改封闭 一个实体是允许在不改变它的源代码的前提下变更它的行为 优点 保持系统的可维护性和代码的重用性 想遵守开闭原则 , 在做系统设计（概要设计、详细设计）的时候就要*考虑到未来的扩展和改变 里氏替换原则(LSP) 定义 派生类（子类）对象可以在程序中代替其基类（父类）对象 优点 实现开闭原则的重要方式之一 克服了继承中重写父类造成的可复用性变差的缺点 类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性 替换原则 任何基类可以出现的地方，子类一定可以出现 子类必须完全实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类可以实现自己特有的方法 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格（类向上转换是安全的，向下转换则不一定是安全） 子类的实例可以替代任何父类的实例，不成立则不符合替换原则 注意点 子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法 LSP 是继承复用的基石 里氏代换原则是对开闭原则的补充 依赖倒置原则(DIP) 定义 高层模块，低层模块，细节都应该依赖抽象 高层模块不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 细节 -- 较为具体的东西，比如具体的类 抽象 -- 具有契约性、共同性、规范性的表达 优点 减少类间的耦合性 降低并行开发引起的风险 提高代码的可读性和可维护性 注意点 分清细节与抽象 变量的声明类型尽量是抽象类或接口 尽量不要覆写基类的方法 继承要遵循里氏替换原则 迪米特法则(LOD) 定义 只和对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法 两个软件实体无须直接通信，那么就不应当发生直接的相互调用 ，可以通过第三方转发该调用 依赖者的角度来说，只依赖应该依赖的对象 被依赖者的角度说，只暴露应该暴露的方法 优点 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性 实现原则 类的划分：应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用 类的结构设计： 每一个类都应当尽量降低其成员变量和成员函数的访问权限 类的设计 ： 只要有可能，一个类型应当设计成不变类 对其他类的引用： 一个对象对其他对象的引用应当降到最低 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法） 注意点 过度使用迪米特法则会系统产生大量的中介类，增加系统复杂性，模块之间的通信效率降低。所以，在釆用时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 接口隔离原则(ISP) 定义 客户端不应该依赖它不需要的接口 一个类对另一个类的依赖应该建立在最小的接口上 优点 建立单一接口， 不是该功能的功能不需要 尽量细化接口，接口中的方法尽量少 提高系统的灵活性和可维护性 区别 单一职责原则 注重的是职责 主要是约束类，其次才是接口和方法 针对的是程序中的实现和细节 接口隔离原则 注重对接口依赖的隔离 主要约束接口 , 主要针对抽象 针对程序整体框架的构建 注意点 接口尽量小，但是要有限度 只暴露给调用的类它需要的方法 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好 组合/聚合复用原则(CARP) 定义 尽量使用组合/聚合，尽量不要使用继承 复用方式 组合 -- 任何环境 将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能 优点： 新对象存取成分对象的唯一方法是通过成分对象的接口 复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的 复用所需的依赖较少 每一个新的类可以将焦点集中在一个任务上 组合/聚合是动态行为 缺点： 有较多的对象需要管理 继承 -- 一些环境 继承复用通过扩展一个已有对象的实现来得到新的功能 优点： 新的实现比较容易，因为基类的大部分功能都可以通过继承自动的进入子类 修改或扩展继承而来的实现较为容易 缺点： 继承复用破坏了包装，因为继承超类的的实现细节暴露给子类。由于超类的内部细节常常对子类是透明的，因此这种复用是透明的复用，又称“白箱”复用 如果基类的实现发生改变，那么派生类的实现也不得不发生改变 从超类继承而来的实现是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性 使用原则 满足 “Is-A” 的关系是才可以使用继承 组合却是一种 “Has-A”（整体与部分）的关系 注意点 首选组合，然后才是继承 继承时应该严格的遵守里氏替换原则，必须满足 “Is-A” 的关系是才能使用继承 "},"设计原则/设计模式.html":{"url":"设计原则/设计模式.html","title":"设计模式","keywords":"","body":"创建型模式 简单工厂模式 应用场景 如 ui库中的按钮，可以根据不同的传值显示不同的样式 这里按钮源于同一个基类，不同的子类通过简单的参数控制呈现不同的外观 定义 又名静态工厂模式 根据参数的不同返回不同类的实例 此模式通常专门定义一个类来负责创建其他的类的实例，被创建的实例也通常具有共同的基类 模式结构 工厂角色(factory) -- 负责实现创建所有实例的内部的逻辑 抽象产品角色(product) -- 创建的所有对象的基类，负责描述所有实例所共有的公共接口 具体产品角色(concreteProduct) --创建派生类，对抽象产品角色的实现 代码实例 //工厂，一般提供一个静态方法，根据传递进来的简单参数决定返回的具体实例 class Factory { static factory(type: number): Product | undefined { /** * 1 角凳 * 2 马扎 */ switch (type) { case 1: return new ProductJiaodeng() case 2: return new ProductMazha() } } } //抽象的产品，这个的定义产品的基本功能 //定义产品为凳子 abstract class Product { } //角凳 - 普通用户 class ProductJiaodeng extends Product { } //马扎 - 户外用户 class ProductMazha extends Product { } const array: number[] = [1, 2, 2, 2, 1, 1, 1, 1, 2] let list: any = array.map((num: number) => { Factory.factory(num) }) 优点 将对象创建和对象业务逻辑部分分离，降低系统的耦合性，使修改更加容易 工厂方法是静态的，可以直接通过类名调用 工厂类包必要的判断，进行产品类的实例，实现了对责任的分割 调用者无需知道有多少类，只需要传入具体产品类的具体参数即可 缺点 工厂方法是静态的，不能被派生类继承 如果工厂需要加入新的产品，会对工厂类进行修改，违背了开闭原则 "},"encrypt/":{"url":"encrypt/","title":"数据加密","keywords":"","body":"数据加密 "},"encrypt/crypto-js.html":{"url":"encrypt/crypto-js.html","title":"crypto-js","keywords":"","body":"crypto-js "},"git/git随笔.html":{"url":"git/git随笔.html","title":"git","keywords":"","body":"git git init //初始化仓库 git add . //添加到暂存区 git status //查看git此时提交状态 git commit -m '提交备注' //提交到本地仓库 git log //查看提交记录 git reset --hard HEAD~1 //回退上一个版本，~2就是回退两个版本 git reflog //操作记录 git reset --hard 6位版本号 //切换提交版本 操作记录处获取版本号 git remote add 别名(origin) 远程仓库地址 //绑定git远程仓库 git push -u origin 推送的分支名称 //将内容推送到远程仓库，-u记住地址，下次直接git push origin 推送的分支名称 git clone 仓库地址 //项目克隆 git pull 远程仓库地址 分支名称 //拉取远程仓库 git branch -a //查看所有分支 git checkout -b aa //创建新的分支aa git checkout aa //切换到aa分支的 git push origin aa //推送aa分支到远程仓库aa分支 git push origin master:aa //推送master分支到远程仓库aa分支 git push origin :aa //删除远程仓库aa分支 git branch -d aa //删除本地aa分支 .gitigonre 忽略文件 node_modules //忽略node_modules 文件夹 /dist //忽略dist 文件夹 "},"WXgroup/微信公众号.html":{"url":"WXgroup/微信公众号.html","title":"微信公众号","keywords":"","body":"微信公众号 注意 JS-SDK说明文档 微信内置浏览器WeixinJSBridge 微信浏览器内部尚未初始化 sendMessage 进行绑定 if(document.addEventListener){ document.addEventListener('WeixinJSBridgeReady',sendMessage,false); }else if(document.attachEvent){ document.attachEvent('WeixinJSBridgeReady' , sendMessage); document.attachEvent('onWeixinJSBridgeReady' , sendMessage); } 常用参数 WeixinJSBridge.call('closeWindow'); //关闭当前浏览器 WeixinJSBridge.call(‘hideToolbar’); //隐藏右下面工具栏 WeixinJSBridge.call(‘showToolbar’); //显示右下面工具栏 WeixinJSBridge.call(‘hideOptionMenu’); //隐藏右上角三个点按钮。 WeixinJSBridge.call(‘showOptionMenu’); //显示右上角三个点按钮。 分享好友 （menu:share:appmessage） WeixinJSBridge.on('menu:share:appmessage', function(argv){ WeixinJSBridge.invoke('sendAppMessage',{ \"appid\":\"\", //appid 设置空就好了。 \"img_url\": imgUrl, //分享时所带的图片路径 \"img_width\": \"120\", //图片宽度 \"img_height\": \"120\", //图片高度 \"link\":url, //分享附带链接地址 \"desc\":\"我是一个介绍\", //分享内容介绍 \"title\":\"标题，再简单不过了。\" }, function(res){ /*** 回调函数，最好设置为空 ***/ }); }); 分享朋友圈 （menu:share:timeline） WeixinJSBridge.on('menu:share:timeline', function(argv){ WeixinJSBridge.invoke('shareTimeline',{ \"appid\":\"\", //appid 设置空就好了。 \"img_url\": imgUrl, //分享时所带的图片路径 \"img_width\": \"120\", //图片宽度 \"img_height\": \"120\", //图片高度 \"link\":url, //分享附带链接地址 \"desc\":\"我是一个介绍\", //分享内容介绍 \"title\":\"标题，再简单不过了。\" }, function(res){ /*** 回调函数，最好设置为空 ***/}); }); }); 分享到微博（menu:share:weibo） WeixinJSBridge.on('menu:share:weibo', function(argv){ WeixinJSBridge.invoke('shareWeibo',{ \"content\":dataForWeixin.title+' '+dataForWeixin.url, \"url\":dataForWeixin.url }, function(res){ /*** 回调函数，最好设置为空 ***/ }); }); 获取网络状态 WeixinJSBridge.invoke('getNetworkType',{},function(e){ // 在这里拿到e.err_msg，这里面就包含了所有的网络类型 e.err_msg }); //wifi wifi网络 //edge 非wifi,包含3G/2G //fail 网络断开连接 //wwan 2g或者3g "},"webpack/webpack.html":{"url":"webpack/webpack.html","title":"webpack","keywords":"","body":"webpack 命令行 webpack-cil 命令行 npx webpack --help //查看参数 npx webpack --watch //会一直监听文件变化 webpack.config.js // [contenthash] 根据文件的内容生产一个哈希的字符串 // [ext] 表示原有的扩展名 const HtmlWebpackPlugin = require('html-webpack-plugin') // webpack构建后生成html文件 const MiniCssExtractPlugin = require('mini-css-extract-plugin') // 抽离css文件 const CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin') // 抽离css文件 module.exports = { entry, //入口文件 output: { //输出文件 filename, //文件名，也可以编辑路径 srtipt/[name].[contenthash].js path, //打包的输出路径 必须为绝对路径 clean: true, //删除上一次的打包内容 assetModuleFilename: 'image/[contenthash][ext]', //设置资源模块文件名和路径 pubicPath, //html中link标签上引入的域名 }, mode, //打包环境类型 production development devtoll: 'evel', //错误定位 plugins: [ //插件 new HtmlWebpackPlugin({ //必须实例化 template, //模板的路径 fileName, //文件名 inject, //文件里 script 标签生成地方 }), new MiniCssExtractPlugin() //参数和上面一样 ], devServe: { //基础的服务 static, //需要启动的路径 }, module: { //配置模块 rules: [ //配置规则 { test: /\\.png$/, //匹配规则 //asset/resource 可以加载全部文件 type: 'asset/resource', //发送单独的文件，并且导出url 本地的图片资源 generator: { filename, //设置资源的文件名 优先级高于assetModuleFilename } }, { test: /\\.svg$/, type: 'asset/lnline', // 导出资源的data的url，bese64 }, { test: /\\.text$/, type: 'asset/source', // 导出资源的源代码 }, { test: /\\.jpg$/, type: 'asset', //resource和lnline选择,默认情况下 大于8k就会生成一个资源文件,否则则是bese64 parser: { //解析器 dataUrlCondition: { //条件 maxSize, //更改asset生产资源的判断条件，默认是8k } } }, { test: /\\.(css | less)/, //当匹配到时，执行下方use // 注意：下方数组中有执行顺序，从后到前，先执行的less-loader use: [miniCssExtractPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.js/, exclude: /node_modules/, //排除条件 use: { loader: 'babel-lader', options: { parser: ['@babel/perser-env'], plugins: [ [ \"@babel/plugin-transform-runtime\" ] ] } } } ] }, optimization: { //优化 minimizer: [ //压缩 new CssMinimizerWebpackPlugin() ], splitChunks: { //将公共的方法分离成一个文件 cacheGroups: { //缓存组 vendor: { test: /[\\\\]node_modules[\\\\]/, name: 'vendors', //打包的名 chunks: 'all' } } } }, performance: { //性能配置 hints: false, //提示关闭 }, resolve: { //模块解析 alias: { //配置别名 'assets': '@/assets', 'components': '@/components' }, extensions: ['.json', 'js', 'vue'], //配置扩展名优先级，从前往后 }, externalsType: 'script', //下方链接放入的标签类型 externals: { //定义外部的第三方包 //$ 表示暴露的Jquery别名 jquery: ['JQuery的链接', '$'] }, } 代码分离 入口起点 使用entry配置手动的分离代码 entry: { //配置多入口 index: './index.js', another: './another.js', }, output: { //输出文件 //[name]根据入口名，自动生成出口文件名 filename:'[name].js', //文件名 path, //输出路径 必须为绝对路径 }, 防止重复 使用Entry dependencies 或者 SplitChunksPlugin 去重和分离代码 Entry dependencies entry: { index: { import: 'index.js', //入口文件路径 dependOn: 'shared', //将共享的文件定义出来,shared为文件名 }, output: { import: 'output.js', //入口文件路径 dependOn: 'shared', //将共享的文件定义出来 }, shared: 'lodash', //将lodash分离出来，单独为一个文件 }, SplitChunksPlugin optimization: { splitChunks: { //将公共的方法分离成一个文件 chunks: 'all' } } 动态导入 通过模块的内调函数来分离代码 function getInfo(){ import('lodash') //动态导入 .then(res){ return res } } 懒加载 //当执行add这个方法时，才加载index.js这个文件，并且index.js会被打包成一个包 // /*webpackChunkName:'indexInt'*/ 修改index.js打包后的文件名 function add(){ import( /*webpackChunkName:'indexInt'*/ './index.js') .then(res=>{}) } 预获取/预加载模块 //预获取(prfetch) //webpackPrfetch 首页内容加载完毕，在网络空闲的时候，提前下载好index.js文件 function add(){ import( /*webpackPrfetch:true*/ './index.js').then(res=>{}) } //预加载(preload) //webpackPrfetch 和懒加载类似,但是页面模块会并行加载 function add(){ import( /*webpackPrfetch:true*/ './index.js').then(res=>{}) } 缓存 当文件内容改变，文件名没有变化时，浏览器则会使用上一次的缓存 [contenthash] 根据文件的内容生产一个哈希的字符串 缓存第三方库 optimization: { splitChunks: { //将公共的方法分离成一个文件 cacheGroups: { //缓存组 vendor: { test: /[\\\\]node_modules[\\\\]/, name: 'vendors', //打包的名,保持文件名不变化，浏览器下次访问直接使用缓存 chunks: 'all' } } } } 拆分开发和生产环境配置 深合并 const { merge } = require('webpack-merge') module.exports = (env)=>{ switch(true){ case env.dev; return merge(commonConfig,devConfig) //代码合并 } } source-map devtoll: 'evel' evel 默认值 每个module都会封装在evel中【 末尾有注释 、能锁定代码错误行数 】 source-map 生成一个sourceMap文件【 末尾有注释 、能锁定代码错误行数 】 hidden-source-map 和上方一样 【 末尾没有注释 、不能锁定代码错误行数 】 inline-source-map DataUrl形式的map文件链接 【 末尾有注释 、能锁定代码错误行数 】 evel-source-map module都会封装在evel中,后方生成DataUrl的map文件链接 【 末尾有注释 、能锁定代码错误行数 】 cheap-source-map 只保留代码行数的map文件【不能锁定代码错误行数 】 cheap-module-source-map 只保留代码行数的map文件,对于外部的混入,也可以剔除出去【 、能锁定代码错误行数 】 推荐使用 devServe const path = qeruire('path') module.exports = { mode: 'development', entry: './main.js', devServe: { static: path.resolve(__dirname, './dist'), //指向当前的物流路径 compress: true, //是否进行代码压缩 port: 3000, //配置端口号 headers: {}, //请求头信息配置 proxy: {}, //设置代理 https: true, //将http改成https http2: true, //和上面一样，自带有https自签名证书 //当是单页面应用时，路由可能识别不了，可以配置historyApiFallback来避免报错 historyApiFallback: true, host: '0.0.0.0', //开发服务器主机, hot: true, //模块热替换，默认true liveReload: true, //热更新功能，默认true } } 模块解析 resolve: { //模块解析 alias: { //配置别名 'assets': '@/assets', 'components': '@/components' }, extensions: ['.json', 'js', 'vue'], //配置扩展名优先级，从前往后 } webWorks index.js const worker = new Worker(new URL('./work.js',import.meta.url)) worker.postMessage({}) //数据传给worker中 worker.onmessage = (message)=>{} //worker返回的结果 work.js self.onmessage = (message)=>{ //接受主线程发过来的信息 self.postMessage({ //把信息返回给主线程 info:111 }) } 外部扩展 externalsType: 'script', //下方链接放入的标签类型 externals: { //定义外部的第三方包 //$ 表示暴露的Jquery别名 jquery: ['JQuery的链接', '$'] } sideEffects 文件是否具体副作用 package.json sideEffects:true //保留所有未引用的文件 sideEffects:false //删除所有未引用的文件 css文件注入后不会被引用 sideEffects:['*.css','index.js'] //指定保留的文件名 shimming 预置依赖 兼容 第三方库的全局变量 实现follify(运行时环境的垫片) 按需加载 预置全局变量 const webpack = require('webpack') module.exports = { plugins: [ new webpack.ProvidePlugin({ //将下方的lodsh和jquery配置成全局变量 _: 'lodsh', $: 'JQuery' }) ], } 覆盖打包后文件的this指向 当模块运行在common.js上下文时，this指向的是module.exports中 module: { rules: { rest: require.resolve('./index.js'),// require.resolve 路径解析 use: 'imports-loader?wrapper=window' //覆盖this指向为window } } 模块联邦（Module Federation） 待引用应用 const { ModuleFederationPlugin } = require('webpack').container module.exports = { plugins: [ new ModuleFederationPlugin({ name: 'anv', //模块联邦的名字，后续其他模块用名字来访问知道模块 filename: 'index.js', //使用此模块联邦的应用名 remotes, //引用其他应用的模块联邦名字 exposes: { //暴露给外部使用的组件 './Header': './sec/head.js', //前面是key值，外部应用使用时拼接用的 }, shared: {}, //共享的模块 }) ] } 引用应用 module.exports = { plugins: [ new ModuleFederationPlugin({ //使用上面的模块联邦 //nav为上面的模块联邦名 name: 'anv', //index.js为上面的应用名 filename: 'index.js', remotes: { nav: 'nav@http://xxxxx:3000/index.js' } }) ] } //这儿的haider就是上面的 './Header': './sec/head.js' import('nav/Header').then(message=>{}) babel transformRuntime 全部辅助函数，兼容 await和async 语法糖 \"babel-loader\": \"^6.26.0\",//webpack中babel解析es6的桥梁，解析成低版本js代码 \"@babel/core\": \"^7.8.4\",//babel核心模块 \"@babel/plugin-transform-runtime\": \"^7.18.5\", //需要transformRuntime时，自动require打包 \"@babel/preset-env\": \"^7.18.2\",//babel预设 babel插件的集合 \"@babel/register\": \"^7.8.3\", 补充 绝对路径 const path = qeruire('path') //__dirname 获取到当前文件的绝对路径 //./dist 基于上面的路径，获取到dist的绝对路径 path.resolve(__dirname,'./dist') 查看模块依赖图 --- webpack-bundle-analyzer "},"server/":{"url":"server/","title":"server","keywords":"","body":"server "},"server/ngin.html":{"url":"server/ngin.html","title":"ngin","keywords":"","body":"nginx nginx服务器 nginx-服务器文件夹目录中不能有中文目录 dist 打包文件夹 放入nginx服务器 文件夹目录中 每次改完文件，都需要重新加载 需要在 阿里云 加入安全组 添加80端口 命令行 .\\nginx.exe -c conf\\kerwin.conf //加载kerwin.conf 并启动服务器 .\\nginx.exe -s stop //关闭nginx服务器 .\\nginx.exe -s reload //重新加载 conf/kerwin.conf 文件夹 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream kerwin-server { server localhost:3001 weight=1; server localhost:3002 weight=1; } server { listen 80; //访问域名 server_name localhost; //访问协议 location / { root dist; //加载的文件夹名 index index.html index.htm; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location /ajax/ { //反向代理配置 proxy_pass https://m.maoyan.com; } } } "},"mock/mockjs.html":{"url":"mock/mockjs.html","title":"mock","keywords":"","body":"mockjs 使用mockjs 项目安装mock npm install mockjs 项目中新建mock文件 //引入mock模块 import Mock from 'mockjs' 将mock文件在main.js中导入 import Vue from 'vue' import App FROM './App.vue' import './mock/index.js' Vue.config.productionTip = false new Vue({ render:h => h(App), }).$mount('#app') mock语法 生成字符串 生成指定次数字符串 import Mock from 'mockjs' const data = Mock.mock({ \"string|4\":\"哈哈\" }) 生成指定范围长度字符串 const data = Mock.mock({ \"string|1-8\":\"哈哈\" }) 生成文本 生成一个随机字符串 const data = Mock.mock({ \"string\":\"@cword\" }) 生成指定长度和范围 const data = Mock.mock({ string:\"@cword(1)\" str :\"@cword(10,15)\" }) 生成标题和句子 生成标题和句子 const data = Mock.mock({ title:\"@ctitle(8)\" sentence:\"@csentence\" }) 生成指定长度的标题和句子 const data = Mock.mock({ title:\"@ctitle(8)\" sentence:\"@csentence(50)\" }) 生成指定范围的 const data = Mock.mock({ title:\"@ctitle(5,8)\" sentence:\"@csentence(50,100)\" }) 生成段落 随机生成段落 const data = Mock.mock({ content:\"@cparagraph()\" }) 生成数字 生成指定数字 const data = Mock.mock({ \"number|80\":1 }) 生成范围数字 const data = Mock.mock({ \"number|1-99\":1 }) 生成自增id 随机生成标识 const data = Mock.mock({ id:\"@increment\" }) 生成姓名-地址-身份证 随机生成姓名-地址-身份证 const data = Mock.mock({ name:\"@cname()\" idCard:\"@id()\" address:\"@city(true)\" }) 随机生成图片 生成图片：@image（“300*200”，‘#ff0000','#fff','gif','坤坤'） 参数1：图片大小 [ '300*250','250*250','240*400','336*280' '180*150','720*300','468*60','234*60' '388*31','250*250','240*400','120*40' '125*125','250*250','240*400','336*280' ] 参数2：图片背景色 参数3：图片前景色 参数4：图片格式 参数5：图片文字 生成时间 @Date 生成指定格式时间：@date(yyyy-MM-dd hh:mm:ss) 指定数组返回的参数 指定长度：‘date|5’ 指定范围:'data|5-10' const data = Mock.mock({ 'list|50-99':[ { name:'@cname' address:'@city(true)' id:'@increment()' } ] }) mock拦截请求 定义get请求 Mock.mock('api/get/news','get',()=>{ return{ status:200, message:\"获取数据成功\" } }) 定义post请求 Mock.mock('api/post/news','post',()=>{ return{ status:200, message:\"获取数据成功\" } }) 实现新闻管理案例 获取数据 接口地址：：/api/get/news 接口参数： pageindex：页码 pagesize:每页的条数 请求类型：get 返回的数据： { status:200, message:\"获取新闻列表成功\", list:[ { \"id\":1, \"title\":\"解忧杂货店\", \"content\":\"《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年《小说野性时代》连载，于2012年3月由角川书店发行单行本\", \"img_url\":\"http://t15.baidu.com/it/u=2090705107,20534764&fm=224&app=112&f=JPEG?w=500&h=500&s=61D0718656561FFFE504A51703000067\", \"add_time\":\"1984-04-03 11:43:37\"} ], total:50 } } 添加新闻 接口地址：：/api/add/news 接口参数： title：'标题' content：内容 请求类型：post 返回的数据： { status:200, message:\"获取新闻列表成功\", list:[ { \"id\":1, \"title\":\"解忧杂货店\", \"content\":\"《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年《小说野性时代》连载，于2012年3月由角川书店发行单行本\", \"img_url\":\"http://t15.baidu.com/it/u=2090705107,20534764&fm=224&app=112&f=JPEG?w=500&h=500&s=61D0718656561FFFE504A51703000067\", \"add_time\":\"1984-04-03 11:43:37\"} ], total:50 } } 删除新闻 接口地址：：/api/delete/news 接口参数： id；新闻id 请求类型：post 返回的数据： { status:200, message:\"获取新闻列表成功\", list:[ { \"id\":1, \"title\":\"解忧杂货店\", \"content\":\"《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年《小说野性时代》连载，于2012年3月由角川书店发行单行本\", \"img_url\":\"http://t15.baidu.com/it/u=2090705107,20534764&fm=224&app=112&f=JPEG?w=500&h=500&s=61D0718656561FFFE504A51703000067\", \"add_time\":\"1984-04-03 11:43:37\"} ], total:50 } } "},"Linux/Linux.html":{"url":"Linux/Linux.html","title":"Linux","keywords":"","body":"Linux "},"vite/vite.html":{"url":"vite/vite.html","title":"vite","keywords":"","body":"vite 注意： 命令行界面 功能 导入 支持裸模块导入 import { someMethod } from 'my-dep' 静态资源处理 服务时引入一个静态资源会返回解析后的公共路径 import imgUrl from './img.png' //./img.png //显式加载资源 未被包含在内部列表或 assetsInclude 中的资源，可以使用 ?url 后缀显式导入为一个 URL import assetAsURL from './asset.js?url' // 在构建时 Web Worker 内联为 base64 字符串 import InlineWorker from './worker.js?worker&inline' JSON // 导入整个对象 import json from './example.json' // 对一个根字段使用具名导入 import { field } from './example.json' Glob 导入 匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk Vite 独有的功能 const modules = import.meta.glob('./dir/*.js') // vite 编译后等用于 const modules = { './dir/foo.js': () => import('./dir/foo.js'), './dir/bar.js': () => import('./dir/bar.js'), } 倾向于直接引入所有的模块，可以传入第二个参数 { eager: true } const modules = import.meta.glob('./dir/*.js', { eager: true }) // vite 生成的代码 import * as __glob__0_0 from './dir/foo.js' import * as __glob__0_1 from './dir/bar.js' const modules = { './dir/foo.js': __glob__0_0, './dir/bar.js': __glob__0_1, } 动态导入 变量仅代表一层深的文件名 const module = await import(`./dir/${file}.js`) "},"webDemo/":{"url":"webDemo/","title":"前端技巧功能","keywords":"","body":"前端技巧视频 "},"webDemo/SSR.html":{"url":"webDemo/SSR.html","title":"SSR","keywords":"","body":"SSR "},"webDemo/websocket.html":{"url":"webDemo/websocket.html","title":"websocket","keywords":"","body":"websocket "},"webDemo/storage.html":{"url":"webDemo/storage.html","title":"storage","keywords":"","body":"storage 文章地址 const config = { type: \"loaclStorage\",// 本地存储类型 localStorage/sessionStorage prefix: 'CBD_1.0.0',// 名称前缀 建议：项目名 + 项目版本 expire: 60 * 60 * 24 * 30,//过期时间 单位：秒 isEncrypt: true, // 是否加密 } interface indexObj { [key: string]: any } // 名称前自动添加前缀 function autoAddPrefix(key: string) { const prefix = config.prefix ? config.prefix + '_' : ''; return prefix + key; } // 移除已添加的前缀 function autoRemovePrefix(key: string) { const len: number = config.prefix ? config.prefix.length + 1 : 0; return key.substr(len); } // 设置storage // { key:键值,value:数据,expire:过期时间,noRenewal:是否不续期 } export function setStorage(key: string, value: any, expire?: number, noRenewal?: boolean) { if (!value) value = null expire = (expire ? expire : config.expire) * 1000 let data: (object | string) = { value: value,//存储值 time: Date.now(),//存储时间戳 expire: expire, //过期时间 noRenewal, } data = JSON.stringify(data); key = autoAddPrefix(key); // if (config.isEncrypt) data = encrypt(data) //加密 (window)[config.type].setItem(key, data) } // 获取storage // { key:键值 } export function getStorage(key: string) { key = autoAddPrefix(key) let data = (window)[config.type].getItem(key) if (!data || JSON.stringify(data) === \"null\") return null // if (config.isEncrypt) data = decrypt(data) //解密 const nowTime = Date.now() if (data.expire && data.expire window)[config.type].removeItem(autoAddPrefix(key)); } // 清空 clearStorage export const clearStorage = () => { (window)[config.type].clear(); } // 判断是否可用 JSON.parse export function isJson(value: any) { if (Object.prototype.toString.call(value) === '[object String]') { try { const obj = JSON.parse(value); const objType = Object.prototype.toString.call(obj); return objType === '[object Object]' || objType === '[object Array]'; } catch (e) { return false; } } return false; } // 派发storage的数据变化 export function dispatchEventStroage() { const signSetItem = localStorage.setItem localStorage.setItem = function (key, val) { signSetItem.apply(this, arguments) //更改setItem的this指向，arguments传入的参数数组（name,value） let setEvent: any = new Event('setItemEvent') //构造函数 setEvent.key = key setEvent.value = val window.dispatchEvent(setEvent) //发送事件到监听器上 } } // 监听storage的数据变化 // window.addEventListener(\"setItemEvent\", function (e: any) { // const newdata = JSON.parse(e.value); // }); "}}