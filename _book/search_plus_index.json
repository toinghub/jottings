{"./":{"url":"./","title":"前言","keywords":"","body":"Summary 前言 "},"jobRecord/":{"url":"jobRecord/","title":"工作随笔","keywords":"","body":"工作随笔 "},"jobRecord/工作随笔.html":{"url":"jobRecord/工作随笔.html","title":"工作随笔","keywords":"","body":"开发注意 iOS&Safari 不兼容 正则表达式的断言匹配 vue2+Ts @Watch('message',{ immediate:true, // immediate表示在watch中首次绑定的时候，是否执行handler， // 值为true则表示在watch中声明的时候，就立即执行handler方法， // 值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。 }) 不确定类型 , 应该使用unknown 当属性可选时，应该用类继承的方式去书写 CSS随笔 position: sticky; //粘性布局 background: linear-gradient(180deg, #f2f2f2, #ffffff); //背景渐变 width:calc(100% - 100px) //单位换算计算 visibility:hidden; 隐藏元素（位置保留） :src=\"require('./1.jpg')\" uniapp 使用本地路径加require background: url(\"~@/assets/xxx.jpg\" //~符号作为前缀的路径视作依赖模块而去解析 border-bottom: 50px solid transparent; //transparent 透明 user-select //用户选择文本 node:禁止 all:选中所有 filter: grayscale(.95); //让网站变灰 word-break: break-all; //英文强制换行 伪类 | 伪元素 :empty //当节点为空时，执行此样式 :focus-within //元素获得焦点，或该元素的后代元素获得焦点，就会匹配 ::placeholder //修改placeholder的样式 ::selection //自定义选中样式 有限制样式 鼠标事件穿透当前层 pointer-events:none //鼠标事件穿透当前层 | 禁止鼠标事件 pointer-events:auto //鼠标不会穿透当前层 苹果底部边距 padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); 字体渐变色 background-image: linear-gradient(right, #7a492f, #cb7e3c); // 为元素提供渐变色背景 background-clip: text; // 用文本剪辑背景 -webkit-text-fill-color: transparent; //使用透明颜色填充文本 撑满子元素高度 overflow: hidden ; //父元素 margin-bottom:-200px;padding--bottom:200px //子元素 文本溢出 //单行 overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 white-space: nowrap; // 规定段落中的文本不进行换行 //多行 overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 display: -webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列 -webkit-line-clamp: 2; // 显示的行数 css变量 :root{ //web是:root 小程序是page --size:100 } div{ //var 读取 calc 计算 width:calc(var(--size)*2px) } @padding-md:15px padding:@padding-md css 类绑定 让每个元素之间隔开px display: flex | grid； gap: 20px; 动画 .img_rotate { animation: changeright 50s linear infinite; } @keyframes changeright { 0% { -webkit-transform: rotate(0deg); } 50% { -webkit-transform: rotate(180deg); } 100% { -webkit-transform: rotate(360deg); } } css特性 在flex子元素中设置不同方向的，子元素就可偏移 当在定位中同时设置lert和right时，就隐式的设置的宽度 JavaScript随笔 location.reload(); //刷新页面 window.location //获取网址信息 Object.values(a) // 枚举a对象所有的属性值 arr.flat(Infinity) // 扁平化数组,Infinity默认深度最深，也可指定深度 [a,b] = [b,a] //使用解构，快速交互ab值 window.location.href=url //(动态输出跳转) 跳转链接 click.once //方法只执行一次 array.at(-1 ) //数组负索引（-1为最后一位）微信内部不支持此语法 let b = a !== 0 ? ( a ? a: \"-\") : 0 //括号可省略 @Watch(\"$route\", { immediate: true }) //监听route可以获取页面显示 &nbsp; //空格 navigator.userAgent.toLowerCase() //返回当前用户所使用的是什么浏览器 try {} catch (error) {} finally {} //错误反馈 Navigator //浏览器的相关信息的对象 const data = { [key]:value } //属性名变量传入 eval() //字符串改成表达式 data.payFrom = array.join() //get请求传数组 监听手机返回 created() { if (window.history && window.history.pushState) { history.pushState(null, \"\", document.URL); window.addEventListener(\"popstate\", this.goBack, false); } this.init(); } destroyed() { window.removeEventListener(\"popstate\", this.goBack, false); } goBack() { (this).$router.go(this.backspace); } app返回退出软件问题 document.addEventListener('plusready', function () { var webview = plus.webview.currentWebview(); plus.key.addEventListener('backbutton', function () { webview.canBack(function (e) { if (e.canBack) { webview.back(); } else { //webview.close(); //hide,quit //plus.runtime.quit(); //首页返回键处理 //处理逻辑：1秒内，连续两次按返回键，则退出应用； var first = null; plus.key.addEventListener('backbutton', function () { //首次按键，提示‘再按一次退出应用’ if (!first) { first = new Date().getTime(); console.log('再按一次退出应用'); setTimeout(function () { first = null; }, 1000); } else { if (new Date().getTime() - first 单行代码 //数组去重 const uniqueArr = (arr) => [...new Set(arr)]; //从url获取参数并转为对象 const getParameters = URL => JSON.parse(`{\"${decodeURI(URL.split(\"?\")[1]).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"')}\"}`) //检查对象是否为空 const isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object; //反转字符串 const reverse = str => str.split('').reverse().join(''); //生成随机十六进制颜色 const randomHexColor = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \"0\")}` //检查当前选项卡是否在后台 const isTabActive = () => !document.hidden; //两日期之间相差的天数 const dayDiff = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000); //将 RGB 转换为十六进制 const rgbToHex = (r, g, b) => \"#\" + ((1 知识 $attrs // 封装第三方库文件 使用attrs数据会及时响应 扩展运算符 let aobj = {a:1,b:2} let bobj = {a:3,b:4,c:5} aobj = {...aobj,...bobj} //{a:3,b:4,c:5} 循环判断 while (判断条件){ 执行代码 } //先判断，后执行; do{ 执行代码 }while( 判断条件 ) //先执行，后判断 操作符 cat?.name //可选链操作符 可以读取cat深处的值，不用担心是否有效 a ?? b //空值合并操作符 左侧为 null 或者 undefined 时，返回右侧数据 a ??= b //空值赋值运算符 左侧为 null 或者 undefined 时,右侧数据赋值给左侧 !. //非空断言操作符 ts内容 2**10 //幂运算 1024 1_000_000 // 使用数字分隔符 原意不变 a ||= b //或等于 a || (a = b) a ||= b //与等于 a && (a = b) 防抖动 debounce (wait, fun,data) { if (this.timer) { clearInterval(this.timer) } this.timer = setTimeout(() => { fun(data) }, wait) }, //vue3+ts let timer = ref(0); const debounce = (wait: number, fun: any, data?: any) => { if (timer) { clearInterval(timer); } timer = setTimeout(() => { fun(data); }, wait); }; 节流 //vue2 throttling (wait, fun) { let _this = this let now = +new Date() if (!this.last || (now - this.last) > wait) { _this.last = now fun() } }, //vue3+ts let last = ref(0); const throttling = (wait: number, fun: any) => { let now: any = +new Date(); if (!last.value || now - last.value > wait) { last.value = now; fun(); } }; 截取视频指定帧图片( 上传并保存在阿里云服务器 ) ?x-oss-process=video/snapshot,t_0,f_jpg,w_0,h_0,m_fast,ar_auto t：指定截图时间 w：指定截图宽度 h：指定截图高度 m：指定截图模式（默认模式，根据时间精确截图，fast则截取该时间点之前的最近的关键帧） f：图片的格式 ar：是否根据视频信息自动旋转图片 多字节替换 let searchStr = this.search searchStr = searchStr.replace(new RegExp(\" \", \"gm\"), \"|\"); searchStr = searchStr.replace(new RegExp(\",\", \"gm\"), \"|\"); 查找数组最大最小值 let data = [1,20,20,33,55,33,66,77] let maxNum = Math.max(...data); let minNum = Math.min(...data); uniapp 刷新页面 // 获取当前页面栈实例 const pages = getCurrentPages() // 获取当前页面 const curPage = pages[pages.length - 1] // 声明一个当前页面 curPage.onLoad(curPage.options) // 传入参数 浏览器关闭提醒 window.onbeforeunload = function (e) { e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) { e.returnValue = '关闭提示'; } // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示'; }; 存储监听 const setItem = localStorage.setItem localStorage.setItem = function (name, value) { setItem.apply(this, arguments) //更改setItem的this指向，arguments传入的参数数组（name,value） var event = new Event('setItem') //构造函数 event.key = name event.value = value window.dispatchEvent(event); //发送事件到监听器上 } // 页面使用 window.addEventListener('setItem', function (e) {//注册监听setItem事件 document.querySelector('.view').innerText = `${e.key}： ${e.value}` }) 时间格式 Vue.filter('formatDate1', function (value, fmt) { let getDate = new Date(value); let o = { 'M+': getDate.getMonth() + 1, //月份 'd+': getDate.getDate(),//日 'h+': getDate.getHours(),//小时 'm+': getDate.getMinutes(),//分钟 's+': getDate.getSeconds(),//秒数 'q+': Math.floor((getDate.getMonth() + 3) / 3),//季度 'S': getDate.getMilliseconds()//毫秒 }; if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (getDate.getFullYear() + '').substr(4 - RegExp.$1.length)) } for (let k in o) { if (new RegExp('(' + k + ')').test(fmt)) { fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length))) } } return fmt; }) 表格导出 file-saver //文件 XLSX //表格转json // 文件名 let filename = `${this.title}.xlsx`; /* 或者用id */ let wb = XLSX.utils.table_to_book( document.getElementById(\"tableExport\") ); console.log(els, wb); /* get binary string as output */ let wbout = XLSX.write(wb, { bookType: \"xlsx\", bookSST: true, type: \"array\" }); try { FileSaver.saveAs( new Blob([wbout], { type: \"application/octet-stream\" }), filename ); } catch (e) { console.log(e); } 数组处理 //并集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var union = new Set([...a, ...b]); // {1, 2, 3, 4} //交集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3} //差集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var difference =new Set([...[...a].filter(x => !b.has(x)),...[...b].filter(x => !a.has(x))]); // {1,4} 正则替换 const setGitCode = ( row: any, column: ColumnProps, cellValue: any, index: number ) => { var str: any = /(? 规则 rules:[ { required: true, message: '请输入密码' }, { pattern:/\\d{6}/, message: '请输入6位数字密码'}, { validator: (val: string) => return boolean, message: '两次密码输入不一致' }], 功能技巧 工具 vue-clipboard2 //剪切板 @chenfengyuan/vue-qrcode //生成二维码 vue3 vue2可用 mobile-detect //获取手机设备信息 moment //日期处理类库 vConsole //手机端测试打开控制台 vue-class-component && vue-property-decorator //class风格开发组件 image-conversion //图片压缩 qs库 //编码 命令 npm cache clear --force //清楚缓存 pwd //打开当前目录的绝对路径 阻止用户截图 1.阻止右键保存和拖拽 2.失焦后加遮罩层 3.高速动态马赛克 注意 微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 直播组件：直播拉流(live-player) + 直播推流(live-pusher) uni.setNavigationBarTitle 更改头部标题 webpack对于小于8k的图片，会将图片转成base64 直接插入图片 items.push(...newItems) 会有爆栈风险 router-view加个唯一的key，来保证路由切换时都会重新渲染触发钩子 "},"jobRecord/功能技巧.html":{"url":"jobRecord/功能技巧.html","title":"功能技巧","keywords":"","body":"功能技巧 微信小程序 微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 直播组件：直播拉流(live-player) + 直播推流(live-pusher) uni.setNavigationBarTitle 更改头部标题 webpack对于小于8k的图片，会将图片转成base64 直接插入图片 阻止用户截图 1.阻止右键保存和拖拽 2.失焦后加遮罩层 3.高速动态马赛克 "},"jobRecord/Vscode.html":{"url":"jobRecord/Vscode.html","title":"Vscode","keywords":"","body":"Vscode 主题 主题名 Monokia 通用插件 Path Intellisense 路径提示插件 open in browser 浏览器中打开html文件 Code Spell Checker 单词拼写检查 Path Autocomplete 路径提示的插件 Prettier - Code formatter 自动格式化 Sass/Less/Stylus/Pug/Jade/Typescript/Javascript Compile Hero Pro 识别出代码的关键词并进行关键词美化 Auto Close Tag 补齐标签 Auto Rename Tag 同步修改标签 Blue Light Theme 括号颜色高亮 Code Spell Checker 单词拼写检查 CSS Peek 快速找到css定义 koroFileHeader 头部注释插件 Path Autocomplete 路径检查提醒 特色插件 Vuter vue2 代码提示 vue-helper vue 代码提示 TypeScript Vue Plugin (Volar) vue3 ts 代码提示 Vue Language Features (Volar) vue3 代码提示 "},"basics/":{"url":"basics/","title":"三剑客","keywords":"","body":""},"basics/javaScript.html":{"url":"basics/javaScript.html","title":"javaScript","keywords":"","body":"js 补充 文章地址 尾调用优化 当函数调用时,会在内存中形成调用记录, 又称\"调用帧\"（call frame） 当在文章末尾调用函数时，可以使用 return,来删除外层函数的调用记录，只保留内层函数的调用记录 function f() { let m = 1; let n = 2; return g(m + n); } 尾递归 因为仅有 1 个调用记录 ，所以不会存在内存溢出问题 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5); // 120 while 循环 只要指定条件为 true，循环就可以一直执行代码块 while (条件){ 需要执行的代码 } Object.is 和 ===的区别 object.is 可以区别-0和+0 object.is NaN等于另一个NaN值 Object.assign 和 扩展运算符... 的区别 Object.assign 会直接改变原数据的值 扩展运算符只能通过赋值都方式改变数据的值 "},"basics/ES6.html":{"url":"basics/ES6.html","title":"ES6","keywords":"","body":"ES6 解构 数组解构 //级别 let [a, b, c] = [1, 2, 3]; //嵌套 let [a, [[b], c]] = [1, [[2], 3]]; //可忽略 let [a, , b] = [1, 2, 3]; //不完全解构 let [a = 1, b] = []; //剩余运算符 let [a, ...b] = [1, 2, 3];//b=[2, 3] //字符串等 let [a, b, c, d, e] = 'hello'; //解构默认值 let [a = 2] = [undefined]; // a = 2 对象解构 基本 let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; //别名 let { baz : foo } = { baz : 'ddd' };// foo = 'ddd' 嵌套 let {p: [x, { y }] } = {p: ['hello', {y: 'world'}] }; // x = 'hello' // y = 'world' 忽略 let {p: [x, { }] } = {p: ['hello', {y: 'world'}] }; // x = 'hello' 不完全解构 let {p: [{ y }, x ] } = {p: [{y: 'world'}] }; // x = undefined // y = 'world' 剩余运算符 let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; // a = 10 // b = 20 // rest = {c: 30, d: 40} 解构默认值 let {a = 10, b = 5} = {a: 3}; // a = 3; b = 5; //别名 + 默认值 let {a: aa = 10, b: bb = 5} = {a: 3}; // aa = 3; bb = 5; Symbol 没有两个 Symbols 永远相等 对象键可以是 Symbols Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问 类似永不重合的字符串 定义 //普通定义 let hd1 = Symbol(\"描述\") let hd2 = Symbol(\"描述\") hd1 === hd2 //false hd1.description //提取hd1描述 //for定义 -- 全局保存 let hd1 = Symbol.for(\"描述\") let hd2 = Symbol.for(\"描述\") hd1 === hd2 //true Symbol.keyFor(hd1) //获取hd1的描述 Map 与 Set Map 对象 任何值(对象或者原始值) 都可以作为一个键或一个值 方法 new Map() //创建 .set(key,value)//设置 .get(key)//获取 遍历 var myMap = new Map(); myMap.set(0, \"zero\"); myMap.set(1, \"one\"); //for for (var [key, value] of myMap) { console.log(key + \" = \" + value); } //forEach myMap.forEach(function(value, key) { console.log(key + \" = \" + value); }) 对象操作 //数组转换 var kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]]; var myMap = new Map(kvArray);//数组转换map var outArray = Array.from(myMap); //map转换数组 //克隆 var myMap1 = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]); var myMap2 = new Map(myMap1); let boolean = myMap1 === myMap2 //false //合并 var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]); var second = new Map([[1, 'uno'], [2, 'dos']]); var merged = new Map([...first, ...second]); Set 对象 Set 对象存储的值总是唯一的 +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复 undefined 与 undefined 是恒等的，所以不重复 NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。 对象之间引用不同，即使值相同，也能存储 方法 new Set() .add(val) 作用 //去重 var mySet = new Set([1, 2, 3, 4, 4]); [...mySet]; // [1, 2, 3, 4]; //并集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var union = new Set([...a, ...b]); // {1, 2, 3, 4} //交集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3} //差集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var difference =new Set([...[...a].filter(x => !b.has(x)),...[...b].filter(x => !a.has(x))]); // {1,4} Reflect 与 Proxy Proxy 对目标对象的读取、函数调用等操作进行拦截 ，进行操作处理 由 target 和 handler 两个部分组成（将 target 对象操作拦截到 handler 中进行处理） let target = { name: 'Tom', age: 24 } //代理陷阱：对象的操作 let handler = { get( target, key ) { return target[key] }, set( target, key, value ) { target[key] = value } } let proxy = new Proxy(target, handler) proxy.name // 实际执行 handler.get proxy.age = 25 // 实际执行 handler.set Reflect Object 的一些明显属于语言内部的方法 get //查找并返回 target 对象的 name 属性 Reflect.get(target, name, receiver) //当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会指向 receiver //实际计算的值的receiver中的 Reflect.get(target, name, receiver) set //将 target 的 name 属性设置为 value Reflect.set(target, name, value, receiver) // 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 指向receiver //实际修改的是 receiver 的属性, //当receiver没有对应修改值时，则添加一个 Reflect.set(exam, 'info', 1, receiver); has //用于查找 name 属性在 obj 对象中是否存在。 Reflect.has(obj, name) let exam = { name: \"Tom\", age: 24 } Reflect.has(exam, 'name'); // true deleteProperty //用于删除 obj 对象的 property 属性，返回值为 boolean Reflect.deleteProperty(obj, property) let exam = { name: \"Tom\", age: 24 } Reflect.deleteProperty(exam , 'name') //{age: 24} getPrototypeOf //读取 obj 的 _proto_ 属性,obj 不是对象时会报错 Reflect.getPrototypeOf(obj) class Exam{} let obj = new Exam() Reflect.getPrototypeOf(obj) === Exam.prototype // true setPrototypeOf //设置目标对象的 prototype Reflect.setPrototypeOf(obj, newProto) let obj ={} Reflect.setPrototypeOf(obj, Array.prototype); // true apply //改变调用方法中的this指向 //func 表示目标函数 //thisArg 表示目标函数绑定的 this 对象 //rgs 表示目标函数调用时传入的参数列表 Reflect.apply(func, thisArg, args) Reflect.apply(Math.max, Math, [1, 3, 5, 3, 1]); // 5 defineProperty //为目标对象定义属性 Reflect.defineProperty(target, propertyKey, attributes) //value属性名是固定的 const student = {}; Reflect.defineProperty(student, \"name\", {value: \"Mike\"}); // true student.name; // \"Mike\" Generator 主要用于异步编程，交出了函数的执行权（可以自定义暂停） 在 function 后面，函数名之前有个 星号* 函数内部有 yield 表达式，可以定义不同的内部状态 本质上是一个异步任务的容器 function* func(){ yield '1';//定义不同的内部状态 yield '2'; return '3'; } let _func = func() //迭代器: 每个迭代器之间的作用域都是相互独立 //分阶段的执行Generator函数 _func.next() //{ value: ' 返回值 ' ，done: \" false \" } value: 返回值 ；done: 函数是否执行完毕 next() 带参数的会覆盖上一个yield语句的返回值 function* func(){ let n = 1 let v = yield n+11; console.log(v) //abc yield ++n; yield ++n; } let _func = func() console.log(_func.next()) //12 console.log(_func.next(\"abc\"))//2 console.log(_func.next())//3 for of 循环 let _func = func() for( let val of _func){ console.log(val) } return() 返回给定值，并结束遍历 Generator 函数 提供参数时，返回该参数；不提供参数时，返回 undefined function* foo(){ yield 1; yield 2; yield 3; } var f = foo(); f.return(\"foo\");//foo yield* 表达式 用于在 Generator 函数内部，调用另一个 Generator 函数 function* callee() { console.log('callee: ' + (yield)); } function* caller() { while (true) { yield* callee(); } } // 等同于 function* caller() { while (true) { for (var value of callee) { yield value; } } } const callerObj = caller(); callerObj.next(); // {value: undefined, done: false} callerObj.next(\"a\"); // callee: a // {value: undefined, done: false} callerObj.next(\"b\"); // callee: b // {value: undefined, done: false} "},"basics/Sass'Less.html":{"url":"basics/Sass'Less.html","title":"Sass/Less","keywords":"","body":"Sass/Less Sass gem install sass 变量声明 $nav-color: #F90; nav { $width: 100px; width: $width; color: $nav-color; } //编译后 nav { width: 100px; color: #F90; } 变量引用 $highlight-color: #F90; $highlight-border: 1px solid $highlight-color; .selected { border: $highlight-border; } //编译后 .selected { border: 1px solid #F90; } 嵌套CSS #content { article { h1 { color: #333 } p { margin-bottom: 1.4em } } &:hover { color: red } } 嵌套属性 nav { border: 1px solid #ccc { left: 0px; right: 0px; } } //编译后 nav { border: 1px solid #ccc; border-left: 0px; border-right: 0px; } 静默注释 body { color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */ } Less npm install -g less 变量（Variables） @width: 10px; @height: @width + 10px; #header { width: @width; height: @height; } 编译后 #header { width: 10px; height: 20px; } 混合（Mixins） 将一组属性从一个规则集包含（或混入）到另一个规则集的方法 //定义的类 .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } //使用 .post a { color: red; .bordered(); } 嵌套（Nesting） 使用嵌套（nesting）代替层叠或与层叠结合使用的能力 #header { color: black; .navigation { font-size: 12px; } &:after{ content:''; font-size:0 } } @规则嵌套和冒泡 @ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套 @ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡 .component { width: 300px; @media (min-width: 768px) { width: 600px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } } 编译后 .component { width: 300px } @media (min-width: 768px) { .component { width: 600px } } @media (min-width: 768px) and (min-resolution: 192dpi) { .component { background-image: url(/img/retina2x.png) } } calc() 特例 @var: 50vh/2; width: calc(50% + (@var - 20px)); // 结果是 calc(50% + (25vh - 20px)) 映射（Maps） #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } 编译后 .button { color: blue; border: 1px solid green; } 作用域（Scope） @var: red; #page { @var: white; #header { color: @var; // blue } @var: blue; } 导入（Importing） @import \"typo.css\"; "},"basics/Flex.html":{"url":"basics/Flex.html","title":"Flex","keywords":"","body":"Flex 容器属性 flex-direction 弹性子元素在父容器中的位置 row 横向从左到右排列 row-reverse 横向从右到左排列 column 纵向从上至下排列 column-reverse 纵向从下至上排列 flex-wrap 弹性盒子的子元素换行方式 nowrap 单行 -- 可能溢出容器 wrap 多行 -- 从上至下 wrap-reverse 多行 -- 从下至上 flex-flow flex-direction 、flex-wrap 两个属性简写 justify-content 内容沿着弹性容器的主轴线对齐 元素在行内的对齐 flex-start 行头堆叠 flex-end 行尾堆叠 center 居中对齐 space-between 平均分布 -- 两边靠边 space-evenly 完全平均分布 space-around 平均分布 -- 两边保留元素间距一半 align-items 弹性盒子在侧轴(纵轴)方向上的对齐 flex-start 起始端对齐 flex-end 末尾段对齐 center 居中对齐 baseline 基线对齐 stretch 子容器尺寸拉伸到父容器一致 align-content 各行在所在的flex容器里的对齐 类似 justify-content stretch 伸展占用剩余的空间 flex-start 起始位置堆叠 flex-end 结束位置堆叠 center 居中对齐 space-between 平均分布 -- 两边靠边 space-around 平均分布 -- 两边保留元素间距一半 项目属性 order 项目在容器中出现的顺序 order: number; .flex div:nth-child(1) { order: 2; } .flex div:nth-child(2) { order: 5; } align-self 某个项目设置不同于其它项目的对齐方式 可以覆盖 align-items 属性的值 auto 继承其父容器的值 stretch 拉伸以适合容器 center 容器的中央 flex-star 容器的顶部 flex-end 项目位于容器的底部 baseline 与容器的基线对齐 align-self: flex-start; flex flex-grow、flex-shrink 和 flex-basis 三个属性的简写 两个快捷值，分别为 auto（1 1 auto）和 none（0 0 auto） flex: flex-grow flex-shrink flex-basis; flex:1 1 auto; flex-grow number -- 默认0 项目相对于其他项目的增长量 flex-shrink number -- 默认1 项目相对于其他项目的收缩量 flex-basis string \\ auto \\ inherit 项目的长度 -- 默认auto "},"basics/Grid.html":{"url":"basics/Grid.html","title":"Grid","keywords":"","body":"Grid 容器( container ) 网格布局的区域 项目( item ) 容器内部采用网格定位的子元素 行( row ) 水平区域 列 ( column) 垂直区域 单元格( cell ) 行和列的交叉区域 n 行和 m 列会产生 n x m 个单元格 网格线( gridLine ) 水平网格线划分出行，垂直网格线划分出列 n 行有 n + 1 根水平网格线，m 列有 m + 1 根垂直网格线 容器属性 display 指定一个容器采用网格布局 grid 采用网格布局 -- 块级元素 inline-grid 采用网格布局 -- 行内元素 template-columns /template-rows grid-template-columns -- 定义每一列的列宽 grid-template-rows -- 定义每一行的行高 display: grid; grid-template-columns: 25% 25% 25% 25%; grid-template-rows: 25% 25% 25% 25%; repeat() 重复的值 repeat(4, 25%) -- (次数，内容) auto-fill 自动填充 repeat(auto-fill, 100px) fr 比例关系 1fr 2fr (后者是前者的两倍宽) minmax 长度范围 minmax(min, max) auto 自己决定长度 100px auto [ ] 指定每一根网格线的名字 [r1] 100px [r2] 100px template-areas grid-template-areas -- 定义区域 display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i'; 合并某区域 grid-template-areas: 'a a a' 'b b b' 'c c c'; 占位符 . 该单元格不属于任何区域 grid-template-areas: 'a . a' 'b . b' 'c . c'; 注意: 区域的命名会影响到网格线 起始网格线自动命名为区域名-start 终止网格线自动命名为区域名-end grid-template grid-template-columns、grid-template-rows 、grid-template-areas 合并简写 auto-columns / auto-rows 当网格只有3列，但是某一个项目指定在第5行。浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns -- 设置浏览器自动创建的多余网格的列宽 grid-auto-rows -- 设置浏览器自动创建的多余网格的行高 grid-auto-columns: 50px; grid-auto-rows: 50px; row-gap / column-gap row-gap -- 行与行的间隔（行间距） column-gap -- 属性设置列与列的间隔（列间距） gap: row-gap: 20px; column-gap: 20px; gap: 20px 20px; auto-flow grid-auto-flow -- 设置子元素顺序 grid-auto-flow: row; grid-auto-flow: row dense; grid-auto-flow: column; grid-auto-flow: column dense; row 先行后列 row dense 先行后列 -- 紧密填满 column 先列后行 column dense 先列后行 -- 紧密填满 justify-items / align-items justify-items -- 单元格内容的水平位置（左中右） align-items -- 单元格内容的垂直位置（上中下） justify-items: start | end | center | stretch; align-items: start | end | center | stretch; place-items: ; place-items: start end; start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 stretch 拉伸，占满单元格的整个宽度（默认值） justify-content / align-content justify-content -- 整个内容区域在容器里面的水平位置（左中右） align-content -- 整个内容区域的垂直位置（上中下） justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; place-content: place-content: space-around space-evenly; start 对齐容器的起始边框 end 对齐容器的结束边框 center 容器内部居中 stretch 拉伸占据整个网格容器 -- 未设置大小时 space-around 平均分布 -- 两边保留项目间距的一半 space-between 平均分布 -- 两边靠边 space-evenly 完全平均分布 grid grid-template-rows 、 grid-template-columns 、 grid-template-areas 、 grid-auto-rows 、 grid-auto-columns 、 grid-auto-flow 、简写 项目属性 column-start / column-end / row-start / row-end 指定项目的四个边框，分别定位在哪根网格线 grid-column-start 左边框所在的垂直网格线 grid-column-end 右边框所在的垂直网格线 grid-column 上方简写 -- start / end grid-row-start 上边框所在的水平网格线 grid-row-end 下边框所在的水平网格线 grid-row 上方简写 -- start / end span 跨越 -- span 2 //项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线 grid-column-start: 2; grid-column-end: 4; //指定为第几个网格线，还可以指定为网格线的名字 grid-column-start: header-start; grid-column-end: header-end; //项目的左边框距离右边框跨越2个网格 grid-column-start: span 2; 简写 grid-column: / ; grid-row: / ; grid-column: 1 / 3; grid-row: 1 / 2; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; grid-area grid-area -- 指定项目放在哪一个区域 可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写 //直接名字指定区域 grid-area: e; //合并简写方式指定区域 grid-area: / / / ; grid-area: 1 / 1 / 3 / 3 justify-self / align-self justify-self -- 单元格内容的水平位置（左中右） align-self -- 单元格内容的垂直位置（上中下） place-self -- 上方合并简写 justify-self: start | end | center | stretch; align-self: start | end | center | stretch; //合并简写 lace-self: ; place-self: center center; start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 stretch 拉伸，占满单元格的整个宽度（默认值） "},"basics/Promise.html":{"url":"basics/Promise.html","title":"Promise","keywords":"","body":"Promise iterable Array，Map，Set 都属于 ES6 的 iterable 类型 Promise.resolve() new Promise方法的语法糖 Promise.resolve(42) new Promise(function (resolve) { resolve(42) }) Promise.reject new Promise方法的语法糖 Promise.reject(new Error(\"Promise reject error\")) new Promise(function (reject) { reject(new Error(\"Promise reject error\")) }) Promise.then 函调函数异步执行 var promise = new Promise((resolve, reject) => {}) promise.then((res) => {}); Promise.catch promise.then(undefined, onRejected) 方法的一个别名 // 第一种写法 Promise.resolve() .then((data) => console.log(data)) .then(undefined, (err) => console.log(err)); // 第二种写法 Promise.resolve() .then((data) => console.log(data)) .catch((err) => console.log(err)); Promise.finally 回调函数不接受任何参数 异步完成后回调 p1.then((res) => console.log(res)) .catch((err) => console.log(err)) .finally(() => console.log(\"finally\")); Promise.all() 接收一个 promise 的 iterable 类型的输入 返回一个Promise实例 需要所有异步任务都同时进行并且完成时可以使用.all方法 任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 会立即抛出错误 var p1 = new Promise((resolve, reject) => {}); var p2 = new Promise((resolve, reject) => {}); var p3 = new Promise((resolve, reject) => {}); Promise.all([p1, p2, p3]).then(values => { console.log(values); }, reason => { console.log(reason) }); /*结果： resx: (3) [{…}, {…}, {…}] resy:{data: {…}, status: 200, statusText: \"OK\", headers: {…}, config: {…}, …} */ Promise.allSettled() 有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时 allSettled在其中一个promise返回错误时还可以继续等待结果 ,所有结果返回后安装传参传入的顺序返回结果 var p1 = new Promise((resolve, reject) => {}); var p2 = new Promise((resolve, reject) => {}); var p3 = new Promise((resolve, reject) => { reject('reject') }); Promise.allSettled([p1, p2, p3).then(values => { console.log(values); }, reason => { console.log(reason) }); //结果： //Promise {} //(5) [{…}, {…}, {…}, {…}, {…}] //0: {status: \"fulfilled\", value: \"one\"} //1: {status: \"fulfilled\", value: \"two\"} //2: {status: \"fulfilled\", value: \"three\"} //length: 5 //[[Prototype]]: Array(0) Promise.any() 某个Promise 变成rejected状态不会结束，必须等到所有参数 Promise 变成rejected状态才会结束 处理多个异步任务返回最快的成功的结果时可以使用 any var p1 = new Promise((resolve, reject) => {}); var p2 = new Promise((resolve, reject) => {}); var p3 = new Promise((resolve, reject) => { reject('reject') }); Promise.any([p1, p2, p3]).then(values => { console.log(values); }, reason => { console.log(reason) }); //结果： //Promise {} // one Promise.race() 遇到立即执行的reject时直接返回了reject的内容 处理多个异步任务但是不要求返回的内容是正确和错误时，返回最快的结果时使用 var p1 = new Promise((resolve, reject) => { setTimeout(resolve, 1000, 'one'); }); var p2 = new Promise((resolve, reject) => { setTimeout(resolve, 2000, 'two'); }); var p3 = new Promise((resolve, reject) => { reject('reject') }); Promise.race([p1, p2, p3]).then(values => { console.log(values); }, reason => { console.log(reason) }); //结果： //reject //Promise {: undefined} "},"basics/RegExp.html":{"url":"basics/RegExp.html","title":"RegExp","keywords":"","body":"RegExp 注意: iOS&Safari 不兼容 正则表达式的断言匹配[ (?=n) (? 类型 var re = new RegExp(\"表达式\",\"修饰符\"); var re = /表达式/修饰符; var re = eval(`/${a}/g`).test() //变量书写 普通字符 [...] 匹配 [...] 中的所有字符 .+ () 放在其中指定单纯的字符本意 const str = \"acacaca bababa cdcd\"; const patt1 = /[ab]/g; str.match(patt1) //a,a,a,a,b,a,b,a,b,a ... 匹配除了 [...] 中字符的所有字符 const str = \"acacaca bababa cdcd\"; const patt1 = /[^ab]/g; str.match(patt1) //c,c,c, , ,c,d,c,d [.-.] 表示一个区间，匹配区间里的内容 /[a-z]/g; //匹配小写a到小写z的字符 /[A-Z]/g; //匹配大写A到大写Z的字符 /[A-z]/g; //匹配大写A到小写z的字符 . 匹配除换行符（\\n、\\r）之外的任何单个字符 /[A-z]/g; //等同 /[^\\n\\r]/g \\w | \\W 单词字符 /\\w/g; //匹配任何单词字符,等价于:[a-zA-Z0-9] /\\W/g; //匹配任何非单词字符,等价于:[^a-zA-Z0-9] \\s | \\S 空白字符 /\\s/g; //匹配任何空白字符,等价于:[\\f\\n\\r\\t\\v] /\\S/g; //匹配任何非空白字符,等价于: [^\\f\\n\\r\\t\\v] \\d | \\D 数字字符 /\\d/g; //匹配一个数字字符,等价于:[0-9] /\\D/g; //匹配一个非数字字符,等价于:[^0-9] \\b | \\B 单词边界 /\\b/g; //匹配一个单词边界，指单词和空格间的位置 const str = \"never verb\"; const patt1 = /er\\b/g; str.match(patt1) //只能匹配never中的er /\\B/g; //匹配非单词边界 const str = \"never verb\"; const patt1 = /er\\B/g; str.match(patt1) //只能匹配verb中的er 非打印字符 \\r \\t \\0 \\n 查找回车符 查找制表符 查找NULL字符 查找换行符 限定符 {n} 匹配确定的 n 次 const str = \"Bob food\"; const patt1 = /o{2}/g; str.match(patt1) //只能匹配 \"food\" 中的两个 o {n,} 至少匹配n 次 ,上限无限 /o{1,}/g; //等价于 'o+' /o{0,}/g; //等价于 'o*' const str = \"Bob fooooood\"; const patt1 = /o{2,}/g; str.match(patt1) //能匹配 \"fooooood\" 中的所有 o {n,m} 最少匹配 n 次且最多匹配 m 次 注意在逗号和两个数之间不能有空格 /o{0,1}/g; //等价于 'o?' const str = \"Bob fooooood\"; const patt1 = /o{2,4}/g; str.match(patt1) //oooo oo 贪婪匹配 const str = \"fooooood\"; const patt1 = /^o{2,4}$/g; str.match(patt1) //false str内容必须是2-4位的才为true \\ 转义字符 ( [ { \\ ^ $ | ) ? * + . ] } //需要使用转义字符的 ( ) 原子组 对子表达式进行一个分组 子表达式可以获取供以后使用 //分组 var str=\"abz acz\"; var patt1=/(ab|ac)z/g; //将abac进行分组 str.match(patt1) //重复使用 //验证的值前后需要一致 var str=\"a1@a1\"; var patt1=/(a[1-3])@\\1/g; //a[1-3]进行分组，后续通过\\1 进行使用( 后续如果还存在原子组，则延续\\1\\2\\3 ) str.match(patt1) (?:) 在组记录中忽略其内容 var str = \"a1@a1.com\"; var patt1 = /(a[1-3])@(?:com|org|cn)/g; str.match(patt1) //数组中没有com (?=n) 断言匹配 匹配任何其后紧接指定字符串 n 的字符串 //对其后紧跟 \"all\" 的 \"is\" 进行全局搜索 var str=\"Is this all there is\"; var patt1=/is(?= all)/g; str.match(patt1) //this 中的is被匹配 (? 匹配任何前面紧接指定字符串 n 的字符串 //对其后紧跟 \"all\" 的 \"is\" 进行全局搜索 var str=\"Is this all there is\"; var patt1=/(? (?!n) 匹配任何其后没有紧接指定字符串 n 的字符串 //对其后没有紧跟 \"all\" 的 \"is\" 进行全局搜索 var str=\"Is this all there is\"; var patt1=/is(?= all)/g; str.match(patt1) //前后的IS is被匹配 (? 匹配任何前面没有紧接指定字符串 n 的字符串 //对其前面没有 \"all\" 的 \"is\" 进行全局搜索 var str=\"all Is this all there is\"; var patt1=/(? ？ 禁止贪婪用途，使子表达式倾向少的那一方 +? *? ?? {2,100}? 只能匹配1次 只能匹配0次 只能匹配0次 只能匹配2次 /hd+?/g; //只能匹配1次 /hd*?/g; //只能匹配0次 /hd??/g; //只能匹配0次 /hd{2,100}?/g; //只能匹配2次 n? n+ n* 匹配前一项0次或者1次 匹配前一项一次或多次 匹配前一项0次或多次 ^n n$ **n \\ m ** 匹配任何开头为n的字符串 匹配任何结尾为n的字符串 选择符 - nm之间的一个选择 修饰符 i g m ignore - 不区分大小写 global - 全局匹配 multi line - 多行匹配 s y 特殊字符圆点 . 中包含换行符 \\n 连续检索，当下一个未检索到是停止 对象方法 exec 检索字符串中指定的值，并返回找到的值 var str=\"Hello world!\"; var patt1=/Hello/g; var result1=patt.exec(str);//Hello var patt2=/to/g; var result2=patt.exec(str);//null test 检索字符串中指定的值 有匹配的值返回 true ，否则返回 false var str=\"Hello world!\"; var patt1=/Hello/g; var result1=patt.test(str);//true var patt2=/Runoob/g; var result2=patt.test(str);//false toString 返回正则表达式的字符串值 var patt = new RegExp(\"RUNOOB\", \"g\"); var res = patt.toString(); ///RUNOOB/g search 返回正则表达式相匹配的索引值 没有找到任何匹配的子串，则返回 -1 var str=\"Visit Runoob!\"; var n=str.search(\"Runoob\"); //6 match 找到一个或多个正则表达式的匹配 var str=\"The rain in SPAIN stays mainly in the plain\"; var n=str.match(/ain/g);//ain,ain,ain matchAll 返回一个迭代对象 var str=\"The rain in SPAIN stays mainly in the plain\"; var n=str.matchAll(/ain/g) replace 替换与正则表达式匹配的子串 $1 $& $` $' ? 第一个原子组 匹配到的内容 匹配到的前面的内容 匹配到的后面的内容 别名 var str = \"abab acac adad\"; var patt = new RegExp(\"a\", \"gm\") var n = str.replace(patt,\"s\");//sbsb scsc sdsd var n = str.replace(patt,v=>{ return \"s\" });//sbsb scsc sdsd //$1 第一个原子组 var str = \"a1@a1\"; var patt1 = /(a[1-3])@\\1/g; str.replace(patt1,`$1`) //a1 //$& 匹配到的内容 //$` 匹配到的前面的内容 a1@前面的等号 //$' 匹配到的后面的内容 @a1后面的等号 var str = \"=a1@a1=\"; var patt1 = /(a[1-3])@\\1/g; str.replace(patt1,`$&1`) //a1@a11 //别名 可以通过matchAll直接访问到别名 var str = \"=a1@a1=\"; var patt1 = /(?a[1-3])@\\1/g; str.replace(patt1,`$`) //a1@a1 split 把字符串分割为字符串数组 var str = \"abab-acac/adad\"; var patt = new RegExp(\"-\\/\", \"g\") var n = str.split(patt);//abab,acac,adad global 判断是否设置了 \"g\" 修饰符 ignoreCase 判断是否设置了 \"i\" 修饰符 multiline 判断是否设置了 \"m\" 修饰符 source 返回正则表达式的匹配模式 lastIndex 用于规定下次匹配的起始位置 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue2 ##vue3 "},"vue/vue2.html":{"url":"vue/vue2.html","title":"vue2","keywords":"","body":"基础 创建项目 npm install -g @vue/cli 安装vuecli vue create vue 创建vue项目 知识 查兼容性 caniuse.com vue3生命周期销毁名字改动 vue修饰符keyup后面可以直接跟键位值 keyup.65 可以给input标签加上vlaue来通过$event 获取 多选框可以直接通过value通过model添加进数组 方法可以直接写到标签内，getData() 直接return出去了， betterScroll 实现页面中拖动滚动拉动等属性功能 window 远程桌面连接 动态添加对象属性 vue2 无法直接拦截，vue3可以直接改 vue.set(对象,属性,true) vue set(vm.classObj,\"dd\",true) 组件： //中央事件主线 var bus = new Vue //通过new vue 创建实例 bus.$emit(\"kerwin\",data) //传入数据 bus.$On(\"kerwin\",(data)=>{}) //接受数据 对象组件传值 post: { id: 1, title: 'My Journey with Vue' } 组件使用v-model searchText = newValue\" /> value: { get() { return this.modelValue }, set(value) { this.$emit('update:modelValue', value) } } 透传 可以在js中访问组件的所有透传 this.$attrs ... //changeValue 将会透传到main根标签上 ... ... 插槽： 父组件通过插槽问子组件属性 默认插槽 具名插槽 Here's some contact info 指令： 自定义指令 this默认指向是window // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { inserted(el,binding) { // inserted 被绑定元素插入父节点时调用 } }) vue.directive('focus',(el,binding)=>{}) //简写 创建或更新都会执行 //局部指令 directives: { focus: { inserted (el) { } }， focus: (el){}，//简写 } v-focus=\"{index:1,name:q}\" //只有一个参数，但是可以传数组和对象 vue3中，指令的生命周期名字改成和组件生命周期一致了 $nextTick() 页面渲染完毕之后再加载 vue.config.js 文件配置 @ 别名 =》永远指向src的绝对路径 module.exports={ devServer :{ proxy :{ //配置反向代理 '/ajax':{ //确定应该将哪些请求代理到目标主机 target:\"https://baidu.com\",//要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { '^/ajax': '',}, ///路径重写 } }, }, configureWebpack:{ resolve:{ alias:{ //配置别名 'assets':'@/assets', 'components':'@/components' } } } } 路由： router.js Vue.use(VueRouter) //注册路由插件，两个全局组件 router-view router-link routers:[ { path: '/bill', component: Layout, //跳转路径 redirect: '/bill/equipmentList', //路由重定向 alwaysShow: true, //是否显时 name: '账单管理', meta:{isShhow:true} children: [ //嵌套路由 { path: 'billList', name: '账单列表', component: () => import('@/shopViews/bill/billList'), }, ] }, { //路由重定向 path:\"*\", redirect:\"/index\" //未匹配到时 重定向到index } ] const touter = new VueRouter({ mode:\"history\",//路由模式 routes }) 声明式导航 编程式导航 this.$router.push('/index') //路由跳转 router路由大对象 route当前匹配的路由 this.$router.replace('/') //和push功能一样，但是不会留下历史记录 //返回上一级 router.back() //动态路由 path:'/index/:myId' //动态路由 router.js文件 this.$router.push(`/index/${id}`) this.$toute.params.myId //拿到当前路由参数 //命名路由 name:'kerwin' //router.js 路由中命名 this.$router.push({ //跳转到名字为kerwi的路由 name:'kerwi', params:{ id, } }) 路由模式 hash模式（location.hash + hashchange 事件） window.onhashchange 监听路径是否改变 hash 模式的实现方式就是通过监听 URL 中的 hash 部分的变化，触发haschange事件，页面做出不同的响应。但是 hash 模式下，URL 中会带有 #，不太美观。 history模式 后端需要配置，当url无匹配资源时，返回同一个index.html页面 history 路由模式的实现，基于 HTML5 提供的 History 全局对象 history.pushState() //向当前浏览器会话的历史堆栈中添加一个状态，会改变当前页面url，但是不会伴随这刷新 history.replaceState()//将当前的会话页面的url替换成指定的数据，replaceState 会改变当前页面的url，但也不会刷新页面 全局路由守卫 meta:{isShhow:true} //to可以获取到meta的值 to.meta.isShhow router.beforEach(to,from,next)=>{ //to 即将进入的路由对象 from 正要离开的路由对象 next() //直接放行 next('/login') //也可重定向 next({ path:'/login', query:{path:'index'} //可以拼接参数 }) } 独享路由守卫 { path: '/bill', component: Layout, redirect: '/bill/equipmentList', alwaysShow: true, name: '账单管理', meta:{isShhow:true}, beforEach(to,from,next)=>{ //写在路由内部，为独享路由守卫 next() } }, 局部路由守卫 本质上是路由的生命周期 beforeRouteEnter(to,from,next)=>{}组件创建前调用，不能使用组件实例this beforeRouteUpdate(to,from,next)=>{}路由被改变，但是组件被复用时调用 beforeRouteLeave(to,from,next)=>{}导航离开时该组件调用 路由懒加载 按需加载 component: () => import('@/shopViews/bill/billList'), 组件UI库 elmentUi pc端 饿了吗开发 地址 Vant 移动端 有赞开发 地址 axios 请求 import axios from \"axios\"; const service = axios.create({ //创建axios实例 baseURL: '', timeout: 10000 }); service.interceptors.request.use( //发请求前拦截 config => {}, error => {} ); service.interceptors.response.use( //响应后拦截 response => {}, error => {} ); export default service; mixins 混入 地址 var mixin = new Vue({ created () { this.$store.commit('changeId',1) },//当没有cerated才会生效 mounted(){ this.$store.commit('changeId',2) } methods:{ //当没有相同的时，会添加进去，有不添加 a(){} } }) mixins: [mixin] //混入文件写了后，可以引入需要功能的文件中 动态绑定 动态属性 当值为 null 意为显式移除该绑定 在 HTML attribute 名称中都是不合法的都不可以，如空格、引号 避免在名称中使用大写字母，因为浏览器会强制将其转换为小写 不能使用复杂的动态参数 ... //等同于 :B=\"url\" //等同于 @B=\"change\" let A = 'B' 通过计算属性绑定class computed: { classObject() { return { active: this.isActive, text-danger: this.error } } } 通过对象绑定:style styleObject: { color: 'red', fontSize: '13px' } 依赖注入 为组件后代提供数据（provide） //提供静态数据 provide: { message: 'hello!' } //提供响应式数据 provide() { return { // 显式提供一个计算属性 message: computed(() => this.message) } } 获取上层组件提供的数据（inject） //声明需要的数据 inject: ['message'] //注入别名 inject: { message: { /* 本地属性名 */ from: 'message', // 注入来源名 当与原注入名同名时，这个属性是可选的 default: 'default' //注入默认值 } 内置组件 Transition v-enter-from 进入动画的起始状态 v-enter-active 进入动画的生效状态 v-enter-to 进入动画的结束状态 v-leave-from 离开动画的起始状态 v-leave-active 离开动画的生效状态 v-leave-to 离开动画的结束状态 //有名字的class名会以name为头 hello /* 进入和离开动画可以使用不同 持续时间和速度曲线。 */ .slide-fade-enter-active { transition: all 0.3s ease-out; } .slide-fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); } .slide-fade-enter-from, .slide-fade-leave-to { transform: translateX(20px); opacity: 0; } TransitionGroup 用于对 v-for 列表中的元素或组件的插入、移除和顺序改变添加动画效果。 每个元素都必须有一个独一无二的 key .list-move, /* 对移动中的元素应用的过渡 */ .list-enter-active, .list-leave-active { transition: all 0.5s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateX(30px); } /* 确保将离开的元素从布局流中删除 以便能够正确地计算移动的动画。 */ .list-leave-active { position: absolute; } Teleport 将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 Open Modal Hello from the modal! Close "},"vue/vue3.html":{"url":"vue/vue3.html","title":"vue3","keywords":"","body":" filters过滤器被删除 文件template下可以放多个根节点，而不像vue2只能放一个根节点 生命周期 onBeforeMount() 组件挂载之前被调用 onMounted() 组件挂载完成后执行 onBeforeUpdate() 组件更新完成前执行 onUpdated() 组件更新完成后执行 onBeforeUnmount() 组件在被卸载前调用 onUnmounted() 组件在被卸载后调用 onErrorCaptured() 捕获后代组件传递的错误时调用 onRenderTracked() 组件渲染过程中追踪到响应式依赖时调用 onRenderTriggered() 当响应式依赖的变更触发了组件渲染时调用 onActivated() KeepAlive -- 组件被插入到 DOM 中时调用 onDeactivated() KeepAlive -- 组件从 DOM 中被移除时调用 onServerPrefetch() 组件实例在服务器上被渲染之前调用 import { reactive,onBeforeMount,onMounted } from \"vue\" setup(){ onBeforeMount(()=>{}) onMounted(()=>{}) } vue3 功能介绍 副作用： 执行会直接或间接影响其他函数的执行 指令 //全局指令 createApp(App).directive('focus', { mounted(el,binding) { //生命周期名字换了 } }) 路由 import { useRouter,useRoute } from 'vue-router' const router = useRouter() //router == this.$router const route = useRoute() //route == this.$route 取值 路由模式 const router = createRouter({ history: createWebHistory(), //history模式 history: createWebHashHistory(), //hash模式 routes }) 声明式导航 自定义hooks 组合式函数约定用驼峰命名法命名，并以“use”作为开头 尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数 组合式函数中使用 ref() 将逻辑代码分离页面，写在外部的js文件中 //页面vue文件 import {getData} from './app.js' //引入逻辑js文件 setup(){ const obj = getData() return { obj } } //app.js文件 逻辑代码 import {onMouted} from \"vue\" function getData() // const obj = ref([]) cosnt obj = reactive({ list.[] }) onMouted(()=>{ obj.list = [1,2,3] }) return obj } exprot { getData } VNode 钩子 每个组件或html标签上，我们可以使用一些特殊的（文档没写的）钩子作为事件 onVnodeBeforeMount onVnodeMounted onVnodeBeforeUpdate onVnodeUpdated onVnodeBeforeUnmount onVnodeUnmounted CSS 功能 深度选择器 -- :deep() .a :deep(.b) {} css获取js变量 -- v-bind const theme = { color: 'red' } p { color: v-bind('theme.color'); } vue3 API介绍 app.config.globalProperties 注册能够被应用内所有组件实例访问到的全局属性的对象 app.config.globalProperties.mes = '111' this.$mes //111 reactive() 创建响应式对象 reactive参数不能是字符串或者数字，否则会警告 👎重新赋值一个新的对象会\"断开\"响应式 change import { reactive } from \"vue\" setup () { const obj = reactive({ //可以写多个reactive函数 myname: \"toing\" //类似data中的值 }) const data = reactive({}) //可以直接创建空对象、空数组 const handleClick = () => { //触发的方法 obj.myname = \"changeToing\" } return {obj,handleClick,data} //要返回 }, shallowReactive() reactive() 的浅层作用形式 只有属性的值会被原样存储和暴露 ref 的属性不会被自动解包 isReactive() 检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理 ref 访问原生dom节点 import { ref } from \"vue\" setup () { const myref = ref() //创建ref函数 const handleClick = () => { //触发的方法 console.log(myref.value) } return {myref} }, ref() 接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向属性.value 当 ref 赋值或者被赋值 reactive 时，ref会被解包（响应栈地址改变） 当在某个响应式数组或 Map 这样的原生集合类型中时， ref 元素不会解包 此处默认省略了value 实际上refText.value--> change import { ref } from \"vue\" setup () { const refText= ref(\"kerwin\") //可以直接拦截字符串 const handleClick = () => { //触发的方法 refText.value = \"changeToing\" } return {refText,handleClick} }, isRef() 检查某个值是否为 ref isRef(foo) unref() 参数是 ref，则返回内部值，否则返回参数本身 val = isRef(val) ? val.value : val 计算的一个语法糖 function useFoo(x: number | Ref) { const unwrapped = unref(x) // unwrapped 现在保证为 number 类型 } shallowRef() ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。 只对 .value 的访问是响应式的 triggerRef() 强制触发依赖于一个浅层 ref 的副作用 , 通常在对浅引用(shallowRef)的内部值进行深度变更后使用 const shallow = shallowRef({ greet: 'Hello, world' }) // 这次变更不应触发副作用，因为这个 ref 是浅层的 shallow.value.greet = 'Hello, universe' // 打印 \"Hello, universe\" triggerRef(shallow) toRef() 基于响应式对象上的一个属性，创建一个对应的 ref。 创建的 ref 与其源属性保持同步，改变源属性的值将更新 ref 的值，反之亦然。 const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, 'foo') // 更改该 ref 会更新源属性 fooRef.value++ console.log(state.foo) // 2 // 更改源属性也会更新该 ref state.foo++ console.log(fooRef.value) // 3 toRefs() 把reactive里的每个属性，转化成ref对象，再通过...展开，变成多个ref对象 在template中，用ref语法，js中用reactive语法 -- import { reactive,toRefs } from \"vue\" setup () { const obj = reactive({ myname: \"toing\", myage:\"100\" }) return { ...toRefs(obj),//在template中不用写obj.了 } }, 将一个响应式对象转换为一个普通对象 普通对象的每个属性都是指向源对象相应属性的 ref 每个单独的 ref 都是使用 toRef() 创建的 从组合式函数中返回响应式对象时 , 使用它，外部可以解构/展开返回的对象而不会失去响应性： function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // 在返回时都转为 ref return toRefs(state) } // 可以解构而不会失去响应性 const { foo, bar } = useFeatureX() isProxy() 查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理 computed() 只读 const plusOne = computed(() => count.value + 1) 可写 const plusOne = computed({ get: () => count.value + 1, set: (val) => { count.value = val - 1 } }) readonly() 返回一个原值的只读代理 const copy = readonly(original) shallowReadonly() readonly() 的浅层作用形式 只有根层级的属性变为了只读 ref 的属性不会被自动解包 const state = shallowReadonly({ foo: 1, nested: { bar: 2 } }) // 更改状态自身的属性会失败 state.foo++ // ...但可以更改下层嵌套对象 isReadonly(state.nested) // false isReadonly() 检查传入的值是否为只读对象 watch() 监听器 //监听一个 const count = ref(0) watch(count, (count, prevCount) => {},{deep:true}) //监听多个 watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {}) immediate 立即触发回调 deep 深层级变更时触发回调 flush:‘post’ 回调中能访问被 Vue 更新后的 DOM props&emit props:['myname'] setup(props,{emit}){ const myname = props.myname //接受父组件数据 const handleClick=()=>{ emit(\"isShow\",11) //子传父 } return{myname,handleClick} } v-model:visible = visible emit(\"update:visible\", false); watch watch(()=>obj.name,(newValue,oldValue)=>{ console.log(newValue,oldValue) }) 依赖注入功能 provide() 提供一个值，可以被后代组件注入 import { ref, provide } from 'vue' import { fooSymbol } from './injectionSymbols' // 提供静态值 provide('foo', 'bar') // 提供响应式的值 const count = ref(0) provide('count', count) // 提供时将 Symbol 作为 key provide(fooSymbol, count) inject() 注入一个由祖先组件或整个应用 提供的值 import { inject } from 'vue' import { fooSymbol } from './injectionSymbols' // 注入值的默认方式 const foo = inject('foo') // 注入响应式的值 const count = inject('count') // 通过 Symbol 类型的 key 注入 const foo2 = inject(fooSymbol) // 注入一个值，若为空则使用提供的默认值 const bar = inject('foo', 'default value') // 注入时为了表明提供的默认值是个函数，需要传入第三个参数 const fn = inject('function', () => {}, false) 插槽 useSlots() / useAttrs() useSlots 和 useAttrs 是真实的运行时函数 与 setupContext.slots 和 setupContext.attrs 等价 import { useSlots, useAttrs } from 'vue' const slots = useSlots() //获取子插槽数据 const attrs = useAttrs() //透传 TypeScript 标注类型 props 标注类型 传递给 defineProps 的泛型参数本身不能是一个导入的类型 interface Props { foo: string bar?: number } const props = defineProps() Props 解构默认值 withDefaults 帮助程序为默认值提供类型检查 确保返回的 props 类型删除了已声明默认值的属性的可选标志 export interface Props { msg?: string labels?: string[] } const props = withDefaults(defineProps(), { msg: 'hello', labels: () => ['one', 'two'] }) 通过 响应性语法糖开启，这个需要手动开启 interface Props { name: string count?: number } // 对 defineProps() 的响应性解构 // 默认值会被编译为等价的运行时选项 const { name, count = 100 } = defineProps() emits 标注类型 带调用签名的类型字面量 // 运行时 const emit = defineEmits(['update:change', 'update']) // 基于类型 const emit = defineEmits() ref 标注类型 const year: Ref = ref('2020') //上下两个方法等同 const year = ref('2020') year.value = 2020 // 成功！ reactive 标注类型 不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 import { reactive } from 'vue' interface Book { title: string year?: number } const book: Book = reactive({ title: 'Vue 3 指引' }) computed 标注类型 const double = computed(() => { // 若返回值不是 number 类型则会报错 }) 事件处理函数 标注类型 function handleChange(event: Event) { (event.target as HTMLInputElement).value } provide / inject 标注类型 provide 提供 InjectionKey 接口，继承自 Symbol 的泛型类型 , 用来在提供者和消费者之间同步注入值的类型 key 的类型放在单独的文件中，这样可以被多个组件导入 import { provide, inject } from 'vue' import type { InjectionKey } from 'vue' const key = Symbol() as InjectionKey provide(key, 'foo') // 若提供的是非字符串值会导致错误 inject // 第二个bar为默认值，没有的话类型则是 string | undefined const foo = inject('foo', 'bar') const foo = inject('foo') as string //强制转换类型 模板引用 标注类型 import { ref, onMounted } from 'vue' const el = ref(null) onMounted(() => { el.value?.focus() }) 组件模板引用 标注类型 如果想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的 Takeover 模式。 defineExpose ----> [组件暴露出自己的属性] import { ref } from 'vue' const isContentShown = ref(false) const open = () => (isContentShown.value = true) defineExpose({ //定义暴露 open }) 为了获取 MyModal 的类型，需要通过 typeof 得到类型，再使用 TypeScript 内置的 InstanceType 工具类型获取实例类型 import MyModal from './MyModal.vue' const modal = ref | null>(null) const openModal = () => { modal.value?.open() } "},"vue/vuex.html":{"url":"vue/vuex.html","title":"vuex","keywords":"","body":"vuex 文档地址 vue devtools 小工具 vuex 默认管理在内存，刷新页面后公共状态会丢失 vuex 持久化 todo 后端数据的缓存快照，较少重复数据请求 actions、mutations 中的方法可以相互调用 vue2 state import { mapState,mapActions,mapMutations } from 'vuex' state:{id:1} //公共状态 类似data this.$store.state.id //查看state的公共状态 this.id //查看state的公共状态 computed: { ...mapState(['id']) ...mapState({ //取别名 userId:(state) => state.id }) } getters getters:{ //类似计算属性 getdoosId:state.id=>(id)=>{ return state.id == id ? true :false } } computed: { ...mapGetter(['getdoosId']) } actions actions:{ //支持异步和同步 requert（store, data）{} //store 下面的为解构的 requert（{ commit, state }, data）{ http().then(id=>{ //异步请求 commit.changeId(id) //实质上还是通过store.commit,更改state值 }) } } this.$store.dispatch('requert',data )//触发actions方法 分发 this.$store.dispatch('requert',data ).then()//有返回值，就可以then this.requert(data) //同上面分发语法一致 methods: { ...mapActions([ 'requert', ]), } mutations mutations:{ //统一管理，可以被devtools记录 只支持同步函数 changeId(state,enterId){ state.id = enterId //更改state的公共状态 } } this.$store.commit('changeId',2) //触发mutations方法 交付 import { mapMutations } from 'vuex' this.changeId(2) // 同上面交付语法一致 methods: { ...mapMutations([ 'changeId', ]), } modules 将需要写的内容模块化出去 namespaced //命名空间 当有多个模块时，需要定义命名空间 import demo from './demo' export default new Vuex.Store({ modules:{ demo //模块的名称 } ) Vuex 持久化 vuex-persistedstate vuex-persist npm 1 vuex-persistedstate --save //安装 import createPersistedState from \"vuex-persistedstate\" //在需要的地方安装使用 const store =newVuex.Store({ plugins: [createPersistedState()] //缓存vuex所有数据 plugins: [createPersistedState({ //缓存配置 storage:'localStorage', //存储的位置 key:'vuexData', //键位名字，默认vuex reducer:(state){ //需要保存的值。默认情况下，保存整个状态。 id:state.id } })] }) vue3 import { useStore } from 'vuex' //引入逻辑js文件 setup(){ const store = useStore() //store == this.$store const count = computed(() => store.state.count), const double = computed(() => store.getters.double) const increment = () => store.commit('increment'), const asyncIncrement = () => store.dispatch('asyncIncrement') } TypeScript // store.ts import { InjectionKey } from 'vue' import { createStore, useStore as baseUseStore, Store } from 'vuex' export interface State { count: number } export const key: InjectionKey> = Symbol() export const store = createStore({ state: { count: 0 } }) // 定义自己的 `useStore` 组合式函数 export function useStore () { return baseUseStore(key) } // main.ts import { createApp } from 'vue' import { store, key } from './store' const app = createApp({ ... }) // 传入 injection key app.use(store, key) app.mount('#app') // vue 组件 import { useStore } from './store' export default { setup () { const store = useStore() store.state.count // 类型为 number } } "},"vue/pinia.html":{"url":"vue/pinia.html","title":"pinia","keywords":"","body":"pinia 定义store 可以对defineStore的返回值进行任意命名 最好以 use 开头且以 Store 结尾。比如：useUserStore defineStore 的第二个参数可接受两类值：Setup 函数 和 Option 对象 import { defineStore } from 'pinia' // 第一个参数是你的应用中 Store 的唯一 ID。 export const useStore = defineStore('main', {}) 对象 类型 export const useCounterStore = defineStore('counter', { state: () => ({ count: 0 }), getters: { double: (state) => state.count * 2, }, actions: { increment() { this.count++ }, }, }) 函数 类型 export const useCounterStore = defineStore('counter', () => { const count = ref(0) const plusOne = computed(() => count.value + 1) function increment() { count.value++ } return { count, increment } }) 响应式解构(storeToRefs) 使用 storeToRefs 将为每一个响应式属性创建引用 同时会跳过任何 action 或非响应式(非 ref/响应式)属性 const { name, doubleCount } = storeToRefs(store) State 定义为一个返回初始状态的函数， 可以同时支持服务端和客户端。 //对象类型 state: () => { return { // 所有这些属性都将自动推断出它们的类型 count: 0, name: 'Eduardo', } }, //函数类型 const count = ref(0) TypeScript interface State { name: string age: number } const useStore = defineStore('storeId', { state: (): State => { return { name: '123', age: 123, } }, }) 访问 通过 store 实例访问 state，直接对其进行读写 const store = useStore() store.count++ computed: { // 与从 store.count 中读取的数据相同 ...mapState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapState(useCounterStore, { myOwnName: 'count', // 你也可以写一个函数来获得对 store 的访问权 double: store => store.count * 2, // 它可以访问 `this`，但它没有标注类型 magicValue(store) { return store.someGetter + this.count + this.double }, }), }, 重置 -- $reset() 调用 store 的 $reset() 方法将 state 重置为初始值 const store = useStore() store.$reset() 变更/替换 -- $patch 补丁对象在同一时间更改多个属性 const store = useStore() store.$patch({ count: store.count + 1, age: 120, }) 函数方法来修改元素集合 store.$patch((state) => { state.items.push({ name: 'shoes', quantity: 1 }) state.hasChanged = true }) 访问修改 -- 函数类型 -- mapWritableState() computed: { // 可以访问组件中的 this.count，并允许设置它。 ...mapWritableState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapWritableState(useCounterStore, { myOwnName: 'count', }), }, this.count++ //修改state.count属性 订阅 -- $subscribe() 更改内容后，触发一次 const cartStore = useSomeStore() cartStore.$subscribe((mutation, state) => { mutation.type // 和 cartStore.$id 一样 mutation.storeId // 'cart' // 只有 mutation.type === 'patch object'的情况下才可用 mutation.payload // 传递给 cartStore.$patch() 的补丁对象。 // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem('cart', JSON.stringify(state)) }) 当组件被卸载时，将被自动删除 组件卸载后依旧保留它们，将 { detached: true } 作为第二个参数，将 state subscription 从当前组件中分离 const someStore = useSomeStore() // 在组件被卸载后，该订阅依旧会被保留。 someStore.$subscribe(callback, { detached: true }) 可以直接在pinia实例上侦听整个state watch( pinia.state, (state) => { // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem('piniaState', JSON.stringify(state)) }, { deep: true } ) Getter typescript 必须设置函数返回类型 可以 通过 this 访问到整个 store 实例 //对象类型 getters: { doubleCount(state) { return state.count * 2 }, doublePlusOne(): number { return this.doubleCount + 1 }, }, //函数类型 const plusOne = computed(() => count.value + 1) 访问 const store = useStore() store.doubleCount computed: { ...mapGetter(useCounterStore, ['count']) }, 访问其他store中的getter import { useOtherStore } from './other-store' getters: { otherGetter(state) { const otherStore = useOtherStore() }, }, Action 通过 this 访问整个 store 实例 action可以是异步的 actions: { async increment() { const preferences = await fetchPreferences() this.count++ }, }, function increment() { count.value++ } 访问 const main = useMainStore() main.randomizeCounter() const store = useStore() store.randomizeCounter() methods: { ...mapActions(useCounterStore, ['increment']) // 与上述相同，但将其注册为this.myOwnName() ...mapActions(useCounterStore, { myOwnName: 'doubleCount' }), }, 访问其他 store 的 action import { useAuthStore } from './auth-store' actions: { fetch() { const auth = useAuthStore() } }, 订阅 -- $onAction() 监听 action 和它们的结果 after 表示在 promise 解决后，在 action 解决后执行回调函数 nError 在 action 抛出错误或 reject 时执行回调函数 const unsubscribe = someStore.$onAction( ({ store, // store 实例，类似 `someStore` args, // 传递给 action 的参数数组 after, // 在 action 返回或解决后的钩子 onError, // action 抛出或拒绝的钩子 }) => { // 这将在 action 成功并完全运行后触发。 // 它等待着任何返回的 promise after((result) => {}) // 如果 action 抛出或返回一个拒绝的 promise，这将触发 onError((error) => {}) } ) // 手动删除监听器 unsubscribe() 当组件被卸载时，将被自动删除 组件卸载后依旧保留它们，将 { detached: true } 作为第二个参数，将 state subscription 从当前组件中分离 const someStore = useSomeStore() // 在组件被卸载后，该订阅依旧会被保留。 someStore.$onAction(callback, true) Plugins 给所有的store批量添加属性、方法等 任何由插件返回的属性都会被 devtools 自动追踪 state 变更或添加(包括调用 store.$patch())都是发生在 store 被激活之前，不会触发订阅函数 import { createPinia } from 'pinia' // 在安装此插件后创建的每个 store 中都会添加一个名为 `secret` 的属性。 // 注册插件（本质上是一个有返回值的函数） function SecretPiniaPlugin(context) { context.pinia // 用 `createPinia()` 创建的 pinia。 context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。 context.store // 该插件想扩展的 store context.options // 定义传给 `defineStore()` 的 store 的可选对象。 // ... } const pinia = createPinia() // 将该插件交给 Pinia pinia.use(SecretPiniaPlugin) // 在另一个文件中 const store = useStore() store.secret // 'the cake is a lie' 插件中调用 -- $subscribe 可以在插件中使用 store.$subscribe 和 store.$onAction pinia.use(({ store }) => { store.$subscribe(() => { // 响应 store 变化 }) store.$onAction(() => { // 响应 store actions }) }) TypeScript 标注插件类型 import { PiniaPluginContext } from 'pinia' export function myPiniaPlugin(context: PiniaPluginContext) { // ... } 导航守卫中使用 import { createRouter } from 'vue-router' const router = createRouter({}) router.beforeEach((to) => { const store = useStore() if (to.meta.requiresAuth && !store.isLoggedIn) return '/login' }) pinia-plugin-persistedstate 状态持久化 pinia-plugin-persistedstate import { defineStore,createPinia } from 'pinia' defineStore('store', { state: () => ({ saved: '' }), persist:{ key:'menuList',//存储的键值 storgae:'localStorage',//存储的类型[localStorage | sessionStorage] paths:['saved'], //指定存储的值 }, }) const pinia = createPinia(); pinia.use(piniaPluginPersistedstate); "},"vue/vue补充.html":{"url":"vue/vue补充.html","title":"vue 补充","keywords":"","body":"vue 中动态引入图片为什么要是 require 为什么无法编译？ 动态引入时,编译的是 src 后面的变量，就导致与图片资源编译过后的资源地址不一致， 导致无法正确的引入资源 为什么加上 require 就好了? 通过 require 方法拿到的文件地址，是资源文件编译过后的文件地址 静态的引入时，为什么返回的是编译过后的文件地址？ 在 webpack 编译的 vue 文件的时候，遇见 src 等属性会默认的使用 require 引入资源路径 "},"TypeScript/":{"url":"TypeScript/","title":"typeSctipt","keywords":"","body":"typeSctipt "},"TypeScript/基础篇.html":{"url":"TypeScript/基础篇.html","title":"基础篇","keywords":"","body":"命令行 tsc xxx //执行ts文件，编译成js文件 tsc --init //生成ts配置文件 tsc --watch //ts自动编译成js文件 tsc --noEmitOnError --watch //当ts文件有错误时，不自动编译 tsconfig.json \"target\":\"es5\" //降级编译 编译后的js文件符合es5标准 \"strict\": true //打开严格模式 这个包括下面两个功能 \"noImplicitAny\": true //类型隐患检查 \"strictNullChecks\": true //严格的Null检查 \"rootDir\":\"./src\" //根目录 \"outDir\":\"./dist\" //输出目录 一、类型 类型一般大写字母开头 基本类型 string //字符串 number //数字 boolean //布尔 null //不存在 undefined //未初始化的值 //数组 type[] //arr:number[] 数字类型数组 Array //Array 数字类型数组 //任何 any //obj: any = {} 任何值都可以赋值 其他类型 never //不应该存在的状态 当函数异常\\中止\\死循环就是never void // 没有返回值函数的返回值 object // 任何的不是基本类型的值 object !== Object\\ unknown //代表任何的值，但是不能进行任何访问 function //描述所有函数值的属性，它的返回值总是any 原语 bigint //非常大的整数 let a:bigint = 100n symbol //全局唯一引用 let a = Symbol(1) let b = Symbol(1) a == b //答案为false,因为symbol具有全局唯一性 二、类型注释 如果未注释类型，则会根据首次赋值来自动注释类型 匿名函数自动根据传入的值自动注释 //参数注释 let person: number = 1 //冒号+类型 //函数注释 function gteer(name: string) {} //: string 表示形参类型注释 function gteer(): string {} //string表示返回值类型注释(void表示没有返回值) () => string //箭头函数返回值类型 //对象注释 function gteer(pt:{x:number, y?:number}) //问好表示可不传y值 //联合类型 let id: number | string 类型别名 //使用type定义类型 type Point = { x:number,y:number } function getData(pt:Point) { } type ID = number | string function getData(id:ID) {} //扩展类型别名 type Bear = Point & { z:number } //通过&扩展 也可以扩展接口 接口 //使用interface定义类型 interface Point { x:number y:number } const point:Point = {x:1,y:2} //扩展接口 interface Bear extends Point1，Point2 { //此处扩展可以合并多个其他接口 z:number } const bear:Bear = {x:1,y:2,z:3} //添加新字段 interface Point { a:numbe } //重复定义，就可以新增加字段 泛型类型 interface Box{ contents: Type } let box: Box = { contents:\"hello\" } 类型断言 //string不能直接断言成number,需要有覆盖关系 const x = ('hello' as unknown) as number //unknown 未知的 const B = A //断言A为number类型 //固定类型 let x = {} as const x! //断言x不是null或者undefined 文字类型 //字符串文字类型 let x: 'true'|'false' = \"true\" //数字文字类型 let x:-1 | 1 | 0 = 0 //布尔文字类型 let x: true | false = true 枚举 enum direction { a = 1, b, c, d } console.log(direction.a，direction.b) //1 2 3 4 会在每个后面依次加1 三、类型缩小 typeof 类型守卫 object \\ string \\ number \\ bigint \\ boolean \\ symbol \\undefined \\ function if(typeof strs === \"object\") {} 真值缩小 条件、&&、||、if语句、！ 通过对上方的使用，过滤null和undefined 等值缩小 ===, !===, ==, != function example (x:string | number,y:string | boolean){ if(x === y){} //当两者都是string时执行里面内容 } let a: number | null | undefined if( a != null ){ } //当a等于null或undefined时，都不会执行里面内容 in 操作符缩小 type a1 = { a: ()=> void } type b1 = { b: ()=> void } type c1 = { a?: ()=> void; b?: ()=> void } function test( value: a1 | b1 | c1 ){ if( 'a' in a1 ){ //a1对象中是否有a属性 return (a as a1 ).a() //因为c1也有a属性，所以加个 as a1 缩小范围 } } instanceof 操作符缩小 x instanceof Foo //检查Foo是否是X的实例 if( x instanceof Date ){] //是否是Date上的实例 分配缩小 let x = Math.randow() 类型谓词 type Fish = { name:string swim: ()=> void } type Bird = { name: string fly: ()=> void } function isFish(pet: Fish | Bird):pet is Fish { return (pet as Fish).swim !== undefined } 联合类型 unions interface a { name:\"a\" radius:number } interface b{ name:\"b\" leftLength:number } type c = a | b //联合类型 function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength } } 穷进性检查 type c = a | b function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength default: //never 任何类型都不能分配给never let d: never = shape //never 不应该存在的状态 可以分配给任何类型 return d } } 四、函数类型 函数类型表达式 //fn : (a: string) => void type fnType = (a: string) => void function greeter(fn : fnType) { fn(\"hello\") } function prinTo(s:string){ console.log(s) } greeter(prinTo) //结果为 \"hello\" 调用签名 创建一个除了函数类型外还有其他类型的对象 也可以使用 interface 创建 type funType = { a: string (b: number) : booleam //参数列表和返回类型之间是：而不是=> } function getData(fn:funType){ cosnole.log(fn.a + fn(6)) } function fn1(n:number){ return true } fn1.a = 'hello' getData(fn1) //结果 hello true 构造签名 class ctor { s: string newfun(s: string) { this.s = s } } type funType = { new (a: string) : ctor //这里返回类或者构造函数 也可填写其他返回值类型 } function fn(ctor: funType){ return new ctor('hello') } const f = fn(ctor) console.log(f.s) //结果 hello 泛型函数 类型推断 数组元素是什么类型，Type就是什么类型 保持输入和输出类型一致 Type 名可以随意取 function getData(arr: Type[]): Type | undefined { return arr[0] } getData(['a','b']) //返回值类型string 一般不写 TS会自行推断 getData([1,2]) //返回值类型number getData([]) //返回值类型undefined function getArray(arr: Input[], func: (arg: Input) => Output): Output[] { return arr.map(func) //map直接放函数是map的语法 } const parsed = getArray(['1','2','3'],(n) => parseInt(n)) 限制条件 // 传入a或b的参数，必须要有length这个属性 function longest( a: Type, b: Type ){ return a.length + b.length } const logestAttay = longest([1,2],[3,4]) const logestString = longest('11','22') 使用受限值 function getData( obj:Type, num: number ):Type { if(obj.length>num){ return obj }else{ // 当返回值不是Type时，可以在前面加一个泛型就好了 return { length: num } } } const arr = getData([1,2,3],6) 指定类型参数 function getData(arr1: Type[], arr2: Type[]): Type[] { return {...arr1,...arr2} } // 这儿强制分别规定泛型类型 const att = getData([1,2,3],['string']) 约束准则 1、尽可能使用类型参数本身，而不是对其约束 function getData(arr: Type[]){ return arr[0] } //correct function getData(arr Type){ return arr[0] } //error 2、尽可能少的使用类型参数 function getData(arr:Type[], func:(arg:Type)=> boolean){} //correct function getData( //error arr: type[], func: func ) 3、一个类型参数只出现在一个地方时，若非必要则尽量不写 function gerData(s:string){} //correct function getData(s :str){} //error 4、当函数里传递回调函数时，永远不要写一个可选参数 函数重载 基本语法 多人合作时，重载签名相当于是定义好了的函数，实现签名就是我们将重载签名拿来使用 尽可能使用联合类型的参数，而不是重载参数 ts可以把this当作参数名（注意不能使用箭头函数） //重载签名 function makeDte(timestamp: number): Date function makeDte(m: number, d:number , y:number): Date //实现签名 function makeDte(mOrtTimestamp: number, d?: number, y?:number): Date { if(d !== undefined && y !== undefined){ return new Date(y, mOrtTimestamp,d) }else{ return new Date(mOrtTimestamp) } } 函数形参展开 function getData(...a: number[]){ return a[0] } getData(1,2,3,4) 参数解构 type abc = {a: number, b: number, c: number} function sum({a, b, c}: abc){ console.log(a + b + c) } sum({a: 10, b: 3, c: 32}) 五、对象类型 只读属性（readonly） interface someType{ readonly prop: string //readonly 写了后，属性就变成了只读 readonly list: { //内部的属性可以修改，list不能修改 name: 'a' } } 索引签名 interface stringArray { //string 表示index必须是string number 是表示数组，可以使用数子得到对应的参数 [idnex: number]: string //index相当于数组索引的意思 } cosnt myArray:stringArray = ['a','b'] cosnt item = myArray[0] interface TextString { // string 是表示props必须是string，可以使用属性得到对应的属性值 [props: string]: number } cosnt textString: TextString = { x:100, y:200 } cosnt item = textString['x'] 六、从类型中创建类型 泛型 基本语法 function getData(arg: Type): Type { } let data = getData(\"hello\") //定义了泛型类型 let data = getData(\"hello\") //自动推断类型为string 泛型接口 interface a{ (arg: Type): Type } function c(arg:Type):Type{ return arg } let b:a = c 泛型类 calss a{ b: numType add:(x：numType) => numType } let mya = new a() //此处的number就是给泛型类属性加类型 约束中使用类型参数 // Key extends keyof Type 意思是 key是包含在type中 function getData(obj: Type, key: Key) { return obj[key] } let x = { a:1, b:2, c:3 } getData(x,'a') //主要是a,b,c就没有问题 泛型中使用类类型 function create(c: { new (): Type }): Type { retuQ YHGB VNrn new c() } keyof 类型操作符 将类型对象属性解析成属性联合类型 type point = { x:number, y:number } type P = keyof point //等同于 'x' | 'y' const p1:P = 'x' const p2:P = 'y' type map = { [k: string]: boolean } //因为js[]语法底层会把number转换成string，所以m的类型是number | string type M = keyof map const myArray = [ { name:'a', age:11 }, { name:'b', age:12 }, ] // Person类型 {name: string,age:number} type Person = typeof myArray[number] //number代表是任何一个数组下标，占位符 typeof 类型操作符 解析属性属于什么类型 是对象则返回对象的返回值类型 let s = \"hello\" let n: typeof s //此时n的类型就是s的类型 string //ReturnType 获取函数返回值类型 ts内置函数 type Predicate = (x: unkown)=> boolean type K = ReturnType 索引访问类型 type List = { a: number; b:string; c:boolean } type A = List['a' | 'b'] 条件类型 举例 interface a { live():void } interface b extends a { woof():void } type c = b extends a ? number : string //a被b约束，语法类似三元表达式 约束 //T 是否存在 {message: unknown } type MessageOf = T extends {message: unknown } ? T['message'] : never interface a { message: string } type b = MessageOf //结果为string 条件类型内推理 infer 定义泛型变量 获取返回值类型 七、类 类属性 class point { //class 关键词定义类 a: number constructor(){ //当point实例化时，会执行此函数，进行数据初始化 this.a = 0 //this默认指向类的实例 } } const p = new point() //()表示实例化类 readonly 修饰符 防止在构造函数之外进行赋值 class point { readonly name:string = 'hello' constructor(enterNmae?: string){ //只能在constructor中修改只读属性 if(enterNmae !== undefined){ this.name = enterNmae } } } const g = new point('通过传值进行更改') console.log(g) 构造器 -- constructor 构造函数不能有类型参数 构造函数不能有返回类型注释 class point { //class 关键词定义类 a: number; b: number; //有默认值可以不写类型，会自动推断。 //不写默认值实例化不传值是会报错 constructor(x:number = 0 , y:number = 0){ this.a = x this.b = y } } const p = new point(1,2) //类继承必须使用super函数 class base { k = 4 } class point extends base { constructor(){ super() } } 类的方法 class point { a: number = 10 b: number = 11 scale(n: number): void { //和外部函数使用没区别 this.a *= n this.b *= n } } const p = new point() p.scale(10) console.log(p.a,p.b) Getters/Serters 存取器 如果只存在get，没有set，则该属性自动是只读的 如果没有指定setter参数的类型，则从getter的返回类型推断出来 访问器和设置器必须是相同的成员可见性 class C { _length = 0 get length(){ return this._length } set length(value) { this._length = value } } let c: C = new C() let a = c.length //会执行类里get关键字的函数 c.length = 100 //会执行类里set关键字的函数 索引签名 class myClass { [s: string]: boolean | ((s: string) => boolean) x = true check(s: string) { return this[s] as boolean } } 类继承 - implements 子句 一个类去继承或者实现一个接口 实现父级类的公共内容 父级类不会改变类的类型，子级类可以进行兼容 父类可选属性，继承的子类可以选择不实现 interface A { x: number y: number } class B implements A { //除了A中的可选属性，其他属性必须写上 x = 0 y = 0 } 类继承 - extends 子句 一个类继承另外一个类 继承的类具备父类所有的属性和方法，并且还可以定义自己的一些属性和方法 class A { x:number = 1 } class B extends A { y:number = 2 } 类重写 覆盖类的时候，类型需要兼容 class base { greet() { console.log(\"hello\") } } class Derived extends base { greet(name?: string) { //直接覆盖父类greet方法 if (name === undefined) { super.greet() //super 指向父类的方法 this指向属性 } else { console.log(name) } } } const d = new Derived() d.greet() d.greet(\"子类的方法\") 初始化顺序 父类: 基类 子类：派生类 1、基类的字段被初始化 2、基类构造函数运行 3、派生类的字段被初始化 4、派生类构造函数运行 class Base { name = 'base' constructor() { console.log(this.name) } } class Derived extends Base { name = 'derived' } const d = new Derived() 继承内置类型 class MsgError extends Error {} //Error 内置类型 成员的可见性 -- public 公开的，默认值。任何对象在任何地方都可以访问 class Base { public name = 'base' //public 默认值，可不写 } const d = new Base() d.name 成员的可见性 -- protected protected 受保护的。只能在当前类和子类中进行访问 派生类可以暴露基类受保护的成员 二次赋值即可 class Base { protected base() { return 'base' } } class Derived extends Base { title = super.base() test() { console.log(super.base()) } } const d = new Derived() d.test() 成员的可见性 -- private 私有的。只能在当前类中进行访问 class Base { private x = 1 base() { console.log(this.x) } } const d = new Base() d.base() TypeSctipr 允许跨实例的私有访问 class A { private x = 10 public sameAs(other: A) { //通过函数暴露私有化变量 return other.x } } const a = new A() console.log(a.sameAs(a)) 静态成员 -- static 静态名称避免使用：name,length,call等特殊名字 TypeScript 没有静态类的概念，因为有函数和普通对象 修饰符可以连着使用，这儿也可以加上成员可见性 基类可以被派生类继承 class myClass { static x = 0; static printX() { myClass.x //可以直接获取 } } const a = myClass.x 类里的static区块 把静态成员私有化，类私有域 class myClass { static #x = 0; //加了#号就只能在类内部使用 static printX() { return myClass.#x } static { //静态区块，默认会执行 console.log(\"hell\") } } 泛型类 静态成员不能使用泛型 class Box{ contents: Type constructor(value: Type) { this.contents = value } } const a = new Box(`1111`) const b: Box = new Box(`1111`) const c = new Box(`1111`) 类运行时的this class MyClass { name: 'MyClass' //原代码 getName() { //这样写，下面obj里c.getNam调用时this指向会边 return this.name } //解决方法1 //利用箭头函数，固定this指向 //会浪费更多的内存，不能在派生类中调用这个函数 getName = ()=>{ return this.name } //解决方法2 //this: MyClass 作用是告诉这个函数this指向地方，提前报错 getName(this: MyClass) { return this.name } } const c = new MyClass() const obj = { name: 'obj', getName: c.getName } console.log(obj.getName()) this 类型 class Box { content: string = '' sameAS(other: this) { //通过传入的值来固定this的指向 return other.content === this.content } } class DerivedBox extends Box { otherContent: string = '?' } const bsse = new Box() const derived = new DerivedBox() derived.sameAS(derived) 基于类型守卫的this ？ 类和方法返回值的位置使用 this is 类型 前面的是固定写法 class Box{ value?: T hasValue(): this is { value: T } { return this.value !== undefined } } const box = new Box() box.value = 'hello' if (box.hasValue()) { console.log(box.value) } 参数属性 class Box { //x加了public后，外部也可以访问了 constructor(public x: number) { this.x = x } } const p = new Box(100) p.x = 200 类表达式 const box = class { content: Type constructor(value: Type) { this.content = value } } const m = new box('hello') console.log(m.content) 抽象类和成员 -- abstract 不能被实例化，只能当作基类，派生类继承 abstract class Base { abstract getNmae(): string //抽象成员 不能被实现 printName() { console.log(this.getNmae) } } class Derived extends Base { getNmae() { return 'world' } } const b = new Derived() b.getNmae() b.printName() 类之间的关系 内部类型一样，可以相互兼容 class A { x = 0 y = 0 } class B { x = 0 y = 0 } const p: A = new B 类可以包含使用 class A { x = 0 y = 0 } class B { x = 0 y = 0 z = 0 } const p: A = new B //b当成了a的继承类 一个空的类可以传入任何参数 class A {} function fn(x:A){ } fn(window) //这儿传入什么，A就会有什么参数 八、模块 模块在自己的范围内执行 ES模块语法 export default function A() { //导出模块 return 'hello' } import hell from './hell' // 引入模块， 一般不写后缀，ts后缀不能写 heel() export let a = 1 export let b = 1 import {a,b} from './hell' console.log(a,b) 额外的导入语法 export let a = 1 export default class B {} //默认的导出 //B1 是类B的别名，as 启用别名 import B1, {a as a1} from './hell' // * 导入所有的东西 import * as math from './hell' // default() 导出默认的导出 const C = new math.default() TS特定的ES模块语法 export type dataType = { a: string b: number c: boolean } export interface dataInterface { a: string b: number c: boolean } import type { dataType,dataInterface } from './hell' export let a = 1 import { a, type dataType, type dataInterface } from './hell' commonJs语法 function getData(): void { } let a = 1 module.exports = { //导出 a, getData } exports.getData = getData //导出 cosnt data = require('./test')//导入 九、内置方法 Partial 将一个传递进来的类型所有属性设置成可选的 interface Person { name: string; age: number; } type PartialPerson = Partial // type PartialPerson = { // name?: string | undefined; // age?: number | undefined; // } Required 将传递的类型里所有的属性变成必选的 interface Person { name?: string; age: number; } type RequiredPerson = Required // type RequiredPerson = { // name: string; // age: number; // } Omit 第一个是类型，第二个是去掉类型中的某几个属性 interface User { id: number; name: string; email: string; age: number; } type OmitUser = Omit // type OmitUser = { // email: string; // age: number; // } Pick 第一个是类型，第二个是要留下哪几个属性 interface User { id: number; name: string; email: string; age: number; } type PickUser = Pick // type PickUser = { // id: number; // name: string; // } Record 用来约束一个类型的 第一个参数用来约束 key 的类型，第二个参数用来约束 value 的类型 type User = Record const user: User = { name: 'John', age: 20, email: '' } type User2 = Record const user2: User2 = { name: 'John', age: 20, email: '', } "},"TypeScript/tsconfig.html":{"url":"TypeScript/tsconfig.html","title":"tsconfig","keywords":"","body":"tsconfig { \"compilerOptions\": { \"target\": \"ESNext\", //遵循那个版本的语法es5 es6 \"useDefineForClassFields\": true, //是否使用定义类字段 \"module\": \"ESNext\", //编译后要遵循的模块规则 \"strictNullChecks\": true,//检查元素是否为空 \"moduleResolution\": \"Node\", //选择模块解析策略，有'node'和'classic'两种类型 \"strict\": true, //是否启动所有类型检查 \"noImplicitThis\": true,//不允许使用不明确指向的this \"noImplicitAny\": true,//不允许使用隐式any类型 \"jsx\": \"preserve\", //指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react' \"resolveJsonModule\": true, //允许导入带有“json扩展名的模块 \"isolatedModules\": true, //将每个文件作为单独的模块 \"esModuleInterop\": true, //允许export=导出，由import from 导入 \"lib\": [\"ESNext\", \"DOM\"], //包含在编译中的库文件 \"skipLibCheck\": true, //// 所有声明文件（*.d.ts）的类型检查，解决打包不报错 \"noEmit\": true, //不输出任何文件 \"skipDefaultLibCheck\": true, //是否跳过默认库声明文件的类型检查 \"baseUrl\": \"./\", //解析非绝对模块名的基准目录 \"paths\": { // 设置路径映射 路径别名 \"@\": [\"src\"], \"@/*\": [\"src/*\"], \"@comp/*\": [\"src/components/*\"], \"@utils/*\": [\"src/utils/*\"], \"@interfaces/*\": [\"src/types/*\"], \"@stores/*\": [\"src/stores/*\"], \"@imgs/*\": [\"src/assets/images/*\"], \"@hooks/*\": [\"src/hooks/*\"] }, \"types\": [\"vite/client\"] //加载的声明文件包 }, \"include\": [ //指定被编译文件所在的目录。 \"src/**/*.ts\", \"src/**/*.d.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"shims-vue.d.ts\" ], \"references\": [ //项目引用，它允许将 TS 程序组织成更小的部分 { \"path\": \"./tsconfig.node.json\" } ] } "},"TypeScript/ts补充.html":{"url":"TypeScript/ts补充.html","title":"ts 补充","keywords":"","body":"ts 补充 注意事项 不确定类型 , 应该使用unknown 当属性可选时，应该用类继承的方式去书写 vue2 补充 @Watch('message',{ immediate:true, // immediate表示在watch中首次绑定的时候，是否执行handler， // 值为true则表示在watch中声明的时候，就立即执行handler方法， // 值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。 }) "},"pack/":{"url":"pack/","title":"打包工具","keywords":"","body":"打包工具 "},"pack/vite.html":{"url":"pack/vite.html","title":"vite","keywords":"","body":"vite 注意： 命令行界面 功能 导入 支持裸模块导入 import { someMethod } from 'my-dep' 静态资源处理 服务时引入一个静态资源会返回解析后的公共路径 import imgUrl from './img.png' //./img.png //显式加载资源 未被包含在内部列表或 assetsInclude 中的资源，可以使用 ?url 后缀显式导入为一个 URL import assetAsURL from './asset.js?url' // 在构建时 Web Worker 内联为 base64 字符串 import InlineWorker from './worker.js?worker&inline' JSON // 导入整个对象 import json from './example.json' // 对一个根字段使用具名导入 import { field } from './example.json' Glob 导入 匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk Vite 独有的功能 const modules = import.meta.glob('./dir/*.js') // vite 编译后等用于 const modules = { './dir/foo.js': () => import('./dir/foo.js'), './dir/bar.js': () => import('./dir/bar.js'), } 倾向于直接引入所有的模块，可以传入第二个参数 { eager: true } const modules = import.meta.glob('./dir/*.js', { eager: true }) // vite 生成的代码 import * as __glob__0_0 from './dir/foo.js' import * as __glob__0_1 from './dir/bar.js' const modules = { './dir/foo.js': __glob__0_0, './dir/bar.js': __glob__0_1, } 动态导入 变量仅代表一层深的文件名 const module = await import(`./dir/${file}.js`) "},"pack/webpack.html":{"url":"pack/webpack.html","title":"webpack","keywords":"","body":"webpack 命令行 webpack-cil 命令行 npx webpack --help //查看参数 npx webpack --watch //会一直监听文件变化 webpack.config.js // [contenthash] 根据文件的内容生产一个哈希的字符串 // [ext] 表示原有的扩展名 const HtmlWebpackPlugin = require('html-webpack-plugin') // webpack构建后生成html文件 const MiniCssExtractPlugin = require('mini-css-extract-plugin') // 抽离css文件 const CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin') // 抽离css文件 module.exports = { entry, //入口文件 output: { //输出文件 filename, //文件名，也可以编辑路径 srtipt/[name].[contenthash].js path, //打包的输出路径 必须为绝对路径 clean: true, //删除上一次的打包内容 assetModuleFilename: 'image/[contenthash][ext]', //设置资源模块文件名和路径 pubicPath, //html中link标签上引入的域名 }, mode, //打包环境类型 production development devtoll: 'evel', //错误定位 plugins: [ //插件 new HtmlWebpackPlugin({ //必须实例化 template, //模板的路径 fileName, //文件名 inject, //文件里 script 标签生成地方 }), new MiniCssExtractPlugin() //参数和上面一样 ], devServe: { //基础的服务 static, //需要启动的路径 }, module: { //配置模块 rules: [ //配置规则 { test: /\\.png$/, //匹配规则 //asset/resource 可以加载全部文件 type: 'asset/resource', //发送单独的文件，并且导出url 本地的图片资源 generator: { filename, //设置资源的文件名 优先级高于assetModuleFilename } }, { test: /\\.svg$/, type: 'asset/lnline', // 导出资源的data的url，bese64 }, { test: /\\.text$/, type: 'asset/source', // 导出资源的源代码 }, { test: /\\.jpg$/, type: 'asset', //resource和lnline选择,默认情况下 大于8k就会生成一个资源文件,否则则是bese64 parser: { //解析器 dataUrlCondition: { //条件 maxSize, //更改asset生产资源的判断条件，默认是8k } } }, { test: /\\.(css | less)/, //当匹配到时，执行下方use // 注意：下方数组中有执行顺序，从后到前，先执行的less-loader use: [miniCssExtractPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.js/, exclude: /node_modules/, //排除条件 use: { loader: 'babel-lader', options: { parser: ['@babel/perser-env'], plugins: [ [ \"@babel/plugin-transform-runtime\" ] ] } } } ] }, optimization: { //优化 minimizer: [ //压缩 new CssMinimizerWebpackPlugin() ], splitChunks: { //将公共的方法分离成一个文件 cacheGroups: { //缓存组 vendor: { test: /[\\\\]node_modules[\\\\]/, name: 'vendors', //打包的名 chunks: 'all' } } } }, performance: { //性能配置 hints: false, //提示关闭 }, resolve: { //模块解析 alias: { //配置别名 'assets': '@/assets', 'components': '@/components' }, extensions: ['.json', 'js', 'vue'], //配置扩展名优先级，从前往后 }, externalsType: 'script', //下方链接放入的标签类型 externals: { //定义外部的第三方包 //$ 表示暴露的Jquery别名 jquery: ['JQuery的链接', '$'] }, } 代码分离 入口起点 使用entry配置手动的分离代码 entry: { //配置多入口 index: './index.js', another: './another.js', }, output: { //输出文件 //[name]根据入口名，自动生成出口文件名 filename:'[name].js', //文件名 path, //输出路径 必须为绝对路径 }, 防止重复 使用Entry dependencies 或者 SplitChunksPlugin 去重和分离代码 Entry dependencies entry: { index: { import: 'index.js', //入口文件路径 dependOn: 'shared', //将共享的文件定义出来,shared为文件名 }, output: { import: 'output.js', //入口文件路径 dependOn: 'shared', //将共享的文件定义出来 }, shared: 'lodash', //将lodash分离出来，单独为一个文件 }, SplitChunksPlugin optimization: { splitChunks: { //将公共的方法分离成一个文件 chunks: 'all' } } 动态导入 通过模块的内调函数来分离代码 function getInfo(){ import('lodash') //动态导入 .then(res){ return res } } 懒加载 //当执行add这个方法时，才加载index.js这个文件，并且index.js会被打包成一个包 // /*webpackChunkName:'indexInt'*/ 修改index.js打包后的文件名 function add(){ import( /*webpackChunkName:'indexInt'*/ './index.js') .then(res=>{}) } 预获取/预加载模块 //预获取(prfetch) //webpackPrfetch 首页内容加载完毕，在网络空闲的时候，提前下载好index.js文件 function add(){ import( /*webpackPrfetch:true*/ './index.js').then(res=>{}) } //预加载(preload) //webpackPrfetch 和懒加载类似,但是页面模块会并行加载 function add(){ import( /*webpackPrfetch:true*/ './index.js').then(res=>{}) } 缓存 当文件内容改变，文件名没有变化时，浏览器则会使用上一次的缓存 [contenthash] 根据文件的内容生产一个哈希的字符串 缓存第三方库 optimization: { splitChunks: { //将公共的方法分离成一个文件 cacheGroups: { //缓存组 vendor: { test: /[\\\\]node_modules[\\\\]/, name: 'vendors', //打包的名,保持文件名不变化，浏览器下次访问直接使用缓存 chunks: 'all' } } } } 拆分开发和生产环境配置 深合并 const { merge } = require('webpack-merge') module.exports = (env)=>{ switch(true){ case env.dev; return merge(commonConfig,devConfig) //代码合并 } } source-map devtoll: 'evel' evel 默认值 每个module都会封装在evel中【 末尾有注释 、能锁定代码错误行数 】 source-map 生成一个sourceMap文件【 末尾有注释 、能锁定代码错误行数 】 hidden-source-map 和上方一样 【 末尾没有注释 、不能锁定代码错误行数 】 inline-source-map DataUrl形式的map文件链接 【 末尾有注释 、能锁定代码错误行数 】 evel-source-map module都会封装在evel中,后方生成DataUrl的map文件链接 【 末尾有注释 、能锁定代码错误行数 】 cheap-source-map 只保留代码行数的map文件【不能锁定代码错误行数 】 cheap-module-source-map 只保留代码行数的map文件,对于外部的混入,也可以剔除出去【 、能锁定代码错误行数 】 推荐使用 devServe const path = qeruire('path') module.exports = { mode: 'development', entry: './main.js', devServe: { static: path.resolve(__dirname, './dist'), //指向当前的物流路径 compress: true, //是否进行代码压缩 port: 3000, //配置端口号 headers: {}, //请求头信息配置 proxy: {}, //设置代理 https: true, //将http改成https http2: true, //和上面一样，自带有https自签名证书 //当是单页面应用时，路由可能识别不了，可以配置historyApiFallback来避免报错 historyApiFallback: true, host: '0.0.0.0', //开发服务器主机, hot: true, //模块热替换，默认true liveReload: true, //热更新功能，默认true } } 模块解析 resolve: { //模块解析 alias: { //配置别名 'assets': '@/assets', 'components': '@/components' }, extensions: ['.json', 'js', 'vue'], //配置扩展名优先级，从前往后 } webWorks index.js const worker = new Worker(new URL('./work.js',import.meta.url)) worker.postMessage({}) //数据传给worker中 worker.onmessage = (message)=>{} //worker返回的结果 work.js self.onmessage = (message)=>{ //接受主线程发过来的信息 self.postMessage({ //把信息返回给主线程 info:111 }) } 外部扩展 externalsType: 'script', //下方链接放入的标签类型 externals: { //定义外部的第三方包 //$ 表示暴露的Jquery别名 jquery: ['JQuery的链接', '$'] } sideEffects 文件是否具体副作用 package.json sideEffects:true //保留所有未引用的文件 sideEffects:false //删除所有未引用的文件 css文件注入后不会被引用 sideEffects:['*.css','index.js'] //指定保留的文件名 shimming 预置依赖 兼容 第三方库的全局变量 实现follify(运行时环境的垫片) 按需加载 预置全局变量 const webpack = require('webpack') module.exports = { plugins: [ new webpack.ProvidePlugin({ //将下方的lodsh和jquery配置成全局变量 _: 'lodsh', $: 'JQuery' }) ], } 覆盖打包后文件的this指向 当模块运行在common.js上下文时，this指向的是module.exports中 module: { rules: { rest: require.resolve('./index.js'),// require.resolve 路径解析 use: 'imports-loader?wrapper=window' //覆盖this指向为window } } 模块联邦（Module Federation） 待引用应用 const { ModuleFederationPlugin } = require('webpack').container module.exports = { plugins: [ new ModuleFederationPlugin({ name: 'anv', //模块联邦的名字，后续其他模块用名字来访问知道模块 filename: 'index.js', //使用此模块联邦的应用名 remotes, //引用其他应用的模块联邦名字 exposes: { //暴露给外部使用的组件 './Header': './sec/head.js', //前面是key值，外部应用使用时拼接用的 }, shared: {}, //共享的模块 }) ] } 引用应用 module.exports = { plugins: [ new ModuleFederationPlugin({ //使用上面的模块联邦 //nav为上面的模块联邦名 name: 'anv', //index.js为上面的应用名 filename: 'index.js', remotes: { nav: 'nav@http://xxxxx:3000/index.js' } }) ] } //这儿的haider就是上面的 './Header': './sec/head.js' import('nav/Header').then(message=>{}) babel transformRuntime 全部辅助函数，兼容 await和async 语法糖 \"babel-loader\": \"^6.26.0\",//webpack中babel解析es6的桥梁，解析成低版本js代码 \"@babel/core\": \"^7.8.4\",//babel核心模块 \"@babel/plugin-transform-runtime\": \"^7.18.5\", //需要transformRuntime时，自动require打包 \"@babel/preset-env\": \"^7.18.2\",//babel预设 babel插件的集合 \"@babel/register\": \"^7.8.3\", 补充 绝对路径 const path = qeruire('path') //__dirname 获取到当前文件的绝对路径 //./dist 基于上面的路径，获取到dist的绝对路径 path.resolve(__dirname,'./dist') 查看模块依赖图 --- webpack-bundle-analyzer "},"request/":{"url":"request/","title":"request","keywords":"","body":"request "},"request/axios.html":{"url":"request/axios.html","title":"axios","keywords":"","body":"axios vue2+ts import axios, { AxiosInstance, AxiosPromise, AxiosRequestConfig, AxiosResponse, } from 'axios'; axios.defaults.withCredentials = true; declare type Methods = | 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH'; /** * transformRequest 函数数组 */ interface Config { data?: any; params?: any; url?: string; headers?: any; responseType?: string; transformRequest?: Array; } export default class Request { private instance: AxiosInstance | null = null; constructor() { if (this.instance === null) { this.instance = axios.create({ baseURL: process.env.VUE_APP_URL, timeout: 50000, // request timeout }); this.initInterceptors(); } } /** * 初始化请求响应的拦截器 */ private initInterceptors(): void { this.instance!.interceptors.request.use( (config: AxiosRequestConfig) => { return config; }, error => { Promise.reject(error); } ); this.instance!.interceptors.response.use( (response: AxiosResponse) => { return response; }, error => { return error; } ); } createAPI(url: string, method: Methods, data: any = {}): AxiosPromise { const config: Config = {}; if (method === 'get' || method === 'GET') { config.params = data; } else { config.data = data; } return this.instance!(Object.assign(config as any, { method, url })); } createFormAPI( url: string, method: Methods, data: any = {}, responseType?: string ) { if (!responseType) { responseType = 'json'; } const config: Config = { data: data, headers: { 'Content-Type': 'application/x-www-form-urlencoded', }, responseType, transformRequest: [], }; config.transformRequest = [ function (data: { [x: string]: string | number | boolean }) { let ret = ''; for (const key in data) { ret += `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}&`; } return ret; }, ]; return this.instance!(Object.assign(config as any, { method, url })); } } vue3+ts import axios, { AxiosInstance, AxiosError, AxiosRequestConfig, AxiosResponse, AxiosPromise, } from \"axios\"; import qs from \"qs\"; import router from \"@/routers\"; import { GlobalStore } from \"@/stores\"; import { ElMessage } from \"element-plus\"; import { checkStatus } from \"@utils/index\"; import { ResultEnum } from \"./enum\"; const config = { // 默认地址请求地址，可在 .env.*** 文件中修改 baseURL: import.meta.env.VITE_API_URL as string, // 设置超时时间（10s） timeout: ResultEnum.TIMEOUT as number, // 跨域时候允许携带凭证 withCredentials: true, }; class RequestHttp { service: AxiosInstance; public constructor(config: AxiosRequestConfig) { // 实例化axios this.service = axios.create(config); /** * @description 请求拦截器 * 客户端发送请求 -> [请求拦截器] -> 服务器 * token校验(JWT) : 接受服务器返回的token,存储到vuex/pinia/本地储存当中 */ this.service.interceptors.request.use( (config: AxiosRequestConfig): any => { const globalStore = GlobalStore(); const token = globalStore.token; const sessionId = globalStore.sessionId; return { ...config, headers: { ...config.headers, token, sessionId }, }; }, (error: AxiosError) => { return Promise.reject(error); } ); /** * @description 响应拦截器 * 服务器换返回信息 -> [拦截统一处理] -> 客户端JS获取到信息 */ this.service.interceptors.response.use( (response: AxiosResponse) => { const { data } = response; const globalStore = GlobalStore(); // * 登陆失效（code == 401） if (data.code == ResultEnum.OVERDUE) { ElMessage.error(data.msg); globalStore.setToken(\"\"); router.replace(\"/login\"); return Promise.reject(data); } // * 全局错误信息拦截（防止下载文件得时候返回数据流，没有code，直接报错） if (data.code && data.code !== ResultEnum.SUCCESS) { ElMessage.error(data.msg); return Promise.reject(data); } // * 成功请求（在页面上除非特殊情况，否则不用在页面处理失败逻辑） return data; }, async (error: AxiosError) => { const { response } = error; // 请求超时 && 网络错误单独判断，没有 response if (error.message.indexOf(\"timeout\") !== -1) ElMessage.error(\"请求超时！请您稍后重试\"); if (error.message.indexOf(\"Network Error\") !== -1) ElMessage.error(\"网络错误！请您稍后重试\"); // 根据响应的错误状态码，做不同的处理 if (response) checkStatus(response.status); // 服务器结果都没有返回(可能服务器错误可能客户端断网)，断网处理:可以跳转到断网页面 if (!window.navigator.onLine) router.replace(\"/500\"); return Promise.reject(error); } ); } // * 常用请求方法封装 get(url: string, params?: object): AxiosPromise { return this.service.get(url, { params }); } post(url: string, params?: object): AxiosPromise { return this.service.post(url, params); } formPost(url: string, params?: object): AxiosPromise { return this.service.post(url, qs.stringify(params)); } } export default new RequestHttp(config); 配置文件 export enum ResultEnum { SUCCESS = \"200\", ERROR = \"500\", OVERDUE = \"401\", TIMEOUT = 30000, TYPE = \"success\", } export const checkStatus = (status: number): void => { switch (status) { case 400: ElMessage.error(\"请求失败！请您稍后重试\"); break; case 401: ElMessage.error(\"登录失效！请您重新登录\"); break; case 403: ElMessage.error(\"当前账号无权限访问！\"); break; case 404: ElMessage.error(\"你所访问的资源不存在！\"); break; case 405: ElMessage.error(\"请求方式错误！请您稍后重试\"); break; case 408: ElMessage.error(\"请求超时！请您稍后重试\"); break; case 500: ElMessage.error(\"服务异常！\"); break; case 502: ElMessage.error(\"网关错误！\"); break; case 503: ElMessage.error(\"服务不可用！\"); break; case 504: ElMessage.error(\"网关超时！\"); break; default: ElMessage.error(\"请求失败！\"); } }; "},"node/":{"url":"node/","title":"node","keywords":"","body":"node基础 "},"node/node基础.html":{"url":"node/node基础.html","title":"node-基础","keywords":"","body":"一、nvm指令 nvm list //查看已安装的nodejs版本 nvm on // 启用node.js版本管理 nvm off // 禁用node.js版本管理(不卸载任何东西) nvm install // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0 nvm use //使用某一version的nodejs nvm uninstall // 卸载指定版本的nodejs nvm alias default //切换默认版本 代码工具 lodash npm搜索 官网lodash.com underscore 开源项目CDN 二、NPM知识 命令行 npm init -y //创建package文件 --sava //安装dependenciesd -S 简写 --dev //开发环境使用 devDependencies -D 简写 -g //全局安装 --save-dev //devDependencies添加依赖 install //安装 i 简写 npm uninstall gulp -D //卸载包 npm list //显示包管理的关系 npm list | grep 包名 //显示指定包管理的关系 三层关系 npm i --production //只装生产环境的包 npm view 包名 versions //查看包版本号 -V 简写 npm i 包名@版本号 -S //安装包指定版本号 版本号可不写 npm outdated //查看那些包已过期 npm update //更新包 npm cache clean --force //强制清除缓存 npm config get registry //查看当前源 npm config set registry 地址 //切换源 npm i git+https://git@ (git地址) //下载git项目（当hhs时，把https改成ssh） 使用npm i可以重新直接安装package里的内容 package-lock 显示包依赖关系 __dirname //当前代码所在文件的物理路径 包类型 1.内置的包 2.第三方库 3.自己定义的包 上传包 npm init -y 初始化 npm adduser 添加账户 npm publish 上传包 三、package 文件解析 package中的 ^1.12.1的^表示当前版本号需要按语义做适配 major 主版本号 minor 次版本号 patch 补丁号 ^1.12.2 //锁定主版本号（major ） ~1.12.2 //锁定主版本号和次版本号（minor） 1.12.2 //锁定所有版本号（patch） * //最新版本 配置信息： \"name\": \"opipjl\", //发布包的名 \"version\": \"1.0.0\", //版本号 \"description\": \"\", //描述 \"main\": \"index.js\", //包的入口 \"keywords\": [], //关键字 \"author\": \"\", //作者 \"license\": \"MIT\", //许可证协议 \"repository\":{\"type\":\"Git\",\"url\":\"git+ \" } //包的git地址 NPM脚本 package.json中的 scripts 字段 ​ 全局 --> 本地 & //可以连接两个命令行 不分先后 && //依次执行 分先后 test start //可以简写，不写run process.env.npmpackage变量名 //能拿到package里的值(只能在脚本中访问) echo $npm_package_config_dev //window疑似不支持 Cross-env (命令兼容平台) npm install --sava-dev cross-env //安装 简写：npm i -S -D cross-env cross-env NODE_ENV=test1 node ./test1.js //NODE_ENV 为命令中的变量名和变量值 后面为执行命令 process.env.NODE_ENV //在./test1.js中获取NODE_ENV的值 四、NRM 管理源 npm的镜像源管理工具 npm i -g nrm //安装nrm nrm ls //查看可选源 nrm use taobao //切换源 nrm test //测试源响应速度 NPX npx gulp -D //当galp未安装时，会生成一个临时路径安装gulp npx --on--install http-server //强制使用本地模块 npx --ignore--existing http-server //强制安装远程模块 commonJs 解意：nodeJs的第三方规范 四步骤使用模块 定义模块 --创建文件且写入内容 暴露模块 --将写入内容暴露给外部 引入模块 --其他文件引入模块 使用模块 --使用定义的模块 module.export = {name,age} //对象写法 exprot.name = name //赋值写法 //衍生写法 exports.default = { } module.exports = { default } 五、nodeJs内置模块 JS日志工具(log4js) const log4js = require('log4js') log4js.configure({ appenders: { cheese: { type: 'file', filename: 'cheese.log' } }, categories: { default: { appenders: ['cheese'], level: 'error' } }, }) const logger = log4js.getLogger('cheese') logger.level = 'debug' logger.debug() 1、url const url = require('url') const urlString = 'https://www.baidu.com:443/pathh/index.html?id=1#tag=2' const urlObj = { parse解析出的对象 } url.parse(urlString,true) //parse 数据解析 (true时，query为对象格式) url.format(urlObj) //format 反向编译路径 url.resolve(\"http://www.baiducom/a\",\"../\") //回到上一层 url.resolve(\"http://www.baiducom/a\",\"/b\") //替换a为b const urlParams = new URLSearchParams(url.parse(urlString).search) urlParams.get('id') //获取search指定字段 2、qureySring const querystring = require('querystring') const query = 'id=2&name=tongy&from=上海' querystring.parse(query,':', '/') //解析 第一个参数key和value中的分隔符，第二个是value和key分隔符 querystring.escape(query) //编码 percent-encoded查询字符串 querystring.unescape(queryEscape) //解码 const queryObj = { id: 2, name: 'toingyi', from: '北京' } id=2&name=toingyi&from=%E5%8C%97%E4%BA%AC querystring.stringify(queryObj, ':', '/') //编译对象，后面两个参数替换的=和&符号 const newQuery = querystring.stringify(queryObj, null, null, { encodeURIComponent(string) { //中文保持不变 return querystring.unescape(string) }, }) 3、http //request 本地请求的函数 response服务器返回函数 http.createServer((request, response) => { response.writeHead(404, {\"content-type\":} ) //第一个返回状态码，第二个对象，返回头部的配置 response.write('home111') //返回内容 不会断开 response.end() //返回内容 会断开 }) ​ 3.1、get 请求 https.get( 'https://www.xiaomiyoupin.com/mtop/mf/resource/data/list', //请求的地址 (result) => { let data = '' result.on('data', (chunk) => { //chunk传回的数据 data += chunk }) result.on('end', () => { //利用response返回数据 }) } ) 3.2、post 请求 const postData = querystring.stringify({}) const options = { protocol: 'http:', //协议 hostname: 'localhost', //主机名 method: 'post', //方法类型 port: '3000', //端口号 path: '/data', //路径 headers: { //请求的首部字段 'content-type': 'application/x-www-form-urlencoded', 'content-length': Buffer.byteLength(postData), }, } const server = http.createServer((request, response) => { // const req = http.request(options, (result) => {}) req.write(postData) req.end() response.end() }) server.listen(80808,()=>{}) //监听端口号 请求头部信息 content-type : 对照表 node浏览器调试 // --inspect-brk 第一行打断点 node --inspect --inspect-brk server.js node进程管理工具 supervisor nodemon //热更启动 forever pm2 //部署 insomnia //调试工具 post请求 3.3、跨域（JSONP\\CORS\\middleware\\爬虫） JSONP 原理：利用在浏览器端请求js不跨域的特性 //前端代码 function getData(data){ console.log(data) } //后端代码 const server = http.createServer((request, response) => { let urlStr = request.url let urlObj = url.parse(urlStr, true) switch (urlObj.pathname) { case '/api/data': response.write(`${urlObj.query.cb}(\"hello\")`) //spanp中的p是填充的意思 break default: response.write('page no found') } response.end() }) CORS 原理：设置Access-Control-Allow-Origin白名单 response.writeHead(200, { 'content-type': 'application/json;charser=utf-8', 'Access-Control-Allow-Origin': '*', //后面的是白名单 }) proxy middleware(http-proxy-middleware) 文档地址 if (/\\/wph/.test(urlStr)) { const proxy = createProxyMiddleware('/wph', { //'/wph'确定应该将哪些请求代理到目标主机 target: 'https://mapi-rp.vip.com/', //要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { //路径重写 '^/wph': '', }, }) proxy(request, response) 爬虫 cheerio //爬到数据后，可以建立虚拟DOM树来解析 function filterData(data){ const $ = cheerio.load(data) $('.xxxx p').each((index,el)=>{}) //each == foreach } 4、event(自定义事件) const EventEmilter = require('events') class MyEventEmilter extends EventEmilter {} //继承EventEmilter const event = new MyEventEmilter() event.on('play', (value) => { //绑定事件（监听作用） console.log(value) }) event.emit('play', '执行') //触发事件 5、文件操作 注：错误优先的回调函数 5.1 文件夹操作 //创建文件 fs.mkdir('logs', (err) => { if (err) throw err }) // throw 抛出异常 //修改文件名/文件夹名 fs.rename('logs', 'log', (err) => {}) //待修改名 修改名 回调 //删除文件夹 fs.rmdir('./log', (err) => {}) //读取文件夹 fs.readdir('./logs', (err, result) => {}) 5.2 文件操作 //创建文件 fs.writeFile('./logs/log1.log', 'hello\\nwordd', (err) => {}) // 追加文件 fs.appendFile('./logs/log1.log', '!!!', (err) => {}) // 删除文件 fs.unlink('./logs/log1.log', (err) => {}) // 读取文件 fs.readFile('./logs/log1.log', 'utf-8', (err, content) => {}) //读取文件路径 返回内容格式 回调 // 同步读取文件 const content = fs.readFileSync('./logs/log1.log', 'utf-8', (err, content) => {}) //promise同步读取(node版本10以上) const fsPromises = require('fs').promises ;async () => { let result = await fsPromises.readFile('./logs/log1.log') } //判断某个文件是否存在 fs.existsSync(\"./index.html\") 5.3 遍历目录所有文件 function readdir(dir) { fs.readdir(dir, (err, content) => { //读取文件夹 content.forEach((value, index) => { let joinDir = `${dir}/${value}` fs.stat(joinDir, (err, stats) => { // stat获取文件或目录的信息 if (stats.isDirectory()) { //isDirectory 是否为目录 readdir(joinDir) } else { fs.readFile(joinDir, 'utf-8', (err, content) => { console.log(content) }) } }) }) }) } 5.4 监听文件 //文件路径 是否监听文件 是否监视所有子目录 字符编码 //eventType:rename或change（文件名出现或者消失时，触发rename） filename:触发事件的文件名称 fs.watch('./logs/log0',true,true,'utf8' (eventType,filename) => {}) //文件路径 是否为二进制 是否监听文件 监听间隔 fs.watchFile('./logs/log0',true,true,5000 (err) => {}) fs.watch //有一小部分平台文件名出现或者消失时,不触发rename，但是效率更高 fs.watchFile //没有上面的平台问题 5.5 文件流 （zlib压缩文件） const fs = require('fs') const zlib = require('zlib') const gizp = zlib.createGzip() const readStream = fs.createReadStream('./logs.txt') //读取流 const writeStream = fs.createWriteStream('./logs.gzip') //写入流 readStream.pipe(gizp).pipe(writeStream) //pipe 管道注入内容 5.6 逐行读取 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('What do you think of Node.js? ', (answer) => { // TODO：记录答案到数据库中 console.log(`Thank you for your valuable feedback: ${answer}`); rl.close(); }); 6、加密（crypto） const crypto = require('crypto') const passsword = 'abc' const hash = crypto .createHash('sha256') //sha256 加密的算法也可以是md5 .update(passsword) //加密谁 .digest('hex') //加密的形式 hex：十六进制 dec：十进制 oct：八进制 bin：二进制 36集 "},"onlineTool/在线工具.html":{"url":"onlineTool/在线工具.html","title":"在线工具","keywords":"","body":"在线工具 时间戳在线 草料二维码 "},"tool/":{"url":"tool/","title":"工具语法","keywords":"","body":"测试工具 "},"tool/git.html":{"url":"tool/git.html","title":"git","keywords":"","body":"git git init //初始化仓库 git add . //添加到暂存区 git status //查看git此时提交状态 git commit -m '提交备注' //提交到本地仓库 git log //查看提交记录 git reset --hard HEAD~1 //回退上一个版本，~2就是回退两个版本 git reflog //操作记录 git reset --hard 6位版本号 //切换提交版本 操作记录处获取版本号 git remote add 别名(origin) 远程仓库地址 //绑定git远程仓库 git push -u origin 推送的分支名称 //将内容推送到远程仓库，-u记住地址，下次直接git push origin 推送的分支名称 git clone 仓库地址 //项目克隆 git pull 远程仓库地址 分支名称 //拉取远程仓库 git branch -a //查看所有分支 git checkout -b aa //创建新的分支aa git checkout aa //切换到aa分支的 git push origin aa //推送aa分支到远程仓库aa分支 git push origin master:aa //推送master分支到远程仓库aa分支 git push origin :aa //删除远程仓库aa分支 git branch -d aa //删除本地aa分支 .gitigonre 忽略文件 node_modules //忽略node_modules 文件夹 /dist //忽略dist 文件夹 "},"tool/mockjs.html":{"url":"tool/mockjs.html","title":"mock","keywords":"","body":"使用mockjs 项目安装mock npm install mockjs npm install @types/mockjs 项目中新建mock文件 //引入mock模块 import Mock from 'mockjs' 将mock文件在main.js中导入 import Vue from 'vue' import App FROM './App.vue' import \"./mock/mock.ts\"; Vue.config.productionTip = false new Vue({ render:h => h(App), }).$mount('#app') mock语法 方法 参数 注释 @boolean min?, max?, current? 布尔值 @natural min?, max? 自然数 @integer min?, max? 整数 @float min?, max?, dmin?, dmax? 浮动数 @cword pool?, min?, max? 文本 @ctitle min?, max? 标题 @csentence null 句子 @cparagraph null 段落 @increment null 自增id @cname null 姓名 @id null 身份证 @city(true) null 地址 @image size?, background?, foreground?, format?, text? 图片 @date yyyy-MM-dd hh:mm:ss 时间 @name true 名字 @cname null 中文名 @url null 路径 @email null 邮箱 @ip null ip @county(true) null 地址 @guid null guid 生成字符串 生成指定次数字符串 import Mock from 'mockjs' Mock.mock({ \"string|4\":\"哈哈\" }) 生成指定范围长度字符串 Mock.mock({ \"string|1-8\":\"哈哈\" }) 生成文本 生成一个随机字符串 Mock.mock({ \"string\":\"@cword\" }) 生成指定长度和范围 Mock.mock({ string:\"@cword(1)\", str :\"@cword(10,15)\" }) 生成标题和句子 生成标题和句子 Mock.mock({ title:\"@ctitle(8)\", sentence:\"@csentence\" }) 生成指定长度的标题和句子 Mock.mock({ title:\"@ctitle(8)\", sentence:\"@csentence(50)\" }) 生成指定范围的 Mock.mock({ title:\"@ctitle(5,8)\", sentence:\"@csentence(50,100)\" }) 生成段落 随机生成段落 Mock.mock({ content:\"@cparagraph()\" }) 生成数字 生成指定数字 Mock.mock({ \"number|80\":1 }) 生成范围数字 Mock.mock({ \"number|1-99\":1 }) 生成自增id 随机生成标识 Mock.mock({ id:\"@increment\" }) 生成姓名-地址-身份证 随机生成姓名-身份证-地址 Mock.mock({ name:\"@cname()\", idCard:\"@id()\", address:\"@city(true)\" }) 随机生成图片 生成图片：@image('200x100', '#50B347', '#FFF', 'Mock.js') Mock.mock({ name:\"@image('200x100', '#50B347', '#FFF', 'Mock.js')\" }) 参数1：图片大小 参数2：图片背景色 参数3：图片前景色 参数4：图片格式 参数5：图片文字 生成时间 @Date 生成指定格式时间：@date(yyyy-MM-dd hh:mm:ss) 指定数组返回的参数 指定长度：‘date|5’ 指定范围:'data|5-10' 数组组合 Mock.mock({ 'list|50-99':[ { name:'@cname', address:'@city(true)', id:'@increment()' } ] }) mock拦截请求 Mock.mock('api/post/news','post/get',(data:any)=>{ let { id,status } = data return{ status:200, message:\"获取数据成功\" } }) mock 多个拦截 封装 在 app.vue 引用 import \"./mock/mock.ts\" 文件 (main.ts报错) ts 中引用 mockjs 需要在 shims-vue.d.ts 中添加声明(declare module 'mockjs';) mock.js import Mock from 'mockjs'; import * as mockList from './index'; interface mockInfoInf { path: string; code?: string; data: any; msg?: string; total?: number; ok?: boolean; } const defaultMockInfo: mockInfoInf = { path: 'mock', code: '200', data: '', msg: '成功', }; function init() { let mockmockInfos: Array = []; for (let key in mockList) { const mockInfo = (mockList)[key]; if (mockInfo.show) { mockmockInfos.push(mockInfo); } } mockmockInfos.forEach((mockInfo: mockInfoInf) => { initMock(mockInfo); }); } function initMock(mockInfo: mockInfoInf) { mockInfo = { ...defaultMockInfo, ...mockInfo }; const path = new RegExp(mockInfo.path.replace('/', '\\\\/')); const data = mockInfo.data.data ? mockInfo.data.data : mockInfo.data; const response = { code: mockInfo.code, data, msg: mockInfo.msg, }; Mock.mock(path, (data: any) => { handleRequest(data); return response; }); } function handleRequest(data: any) { let path: string = ''; let param: any = {}; if (data.type === 'GET') { if (data.url.includes('?')) { const urlArray = data.url.split('?'); path = urlArray[0]; if (urlArray.length === 2 && urlArray[1].includes('&')) { const paramArray = urlArray[1].split('&'); paramArray.forEach((item: any) => { const itemArray = item.split('='); const key = itemArray[0]; const value = itemArray[1]; param[key] = value; }); } } else { path = data.url; } } if (data.type === 'POST') { path = data.url; param = JSON.parse(data.body); } console.log({ path }); console.table(param); } init(); index.js import Mock from 'mockjs'; /* @increment 自增id @cname 随机姓名 @id 随机身份证 @city(true) 随机地址 @boolean 随机布尔值 @natural 随机自然数 @cword 随机字符串 @ctitle 随机标题 @csentence 随机句子 @cparagraph 随机段落 @image('200x100', '#50B347', '#FFF', 'Mock.js') 随机图片 @date(yyyy-MM-dd hh:mm:ss) 随机时间 */ //banner export class banner { static show: boolean = true; static path: string = '/TicketBuyList'; static data: any = Mock.mock({ pageSize: 10, total: 100, totalPage: 10, 'list|50-99': [ { id: '@increment()', name: '@cname', tickeName: '黑龙江@city门票', buyNum: '@natural(1,10)', }, ], }); } export class banner21 { static show: boolean = true; static path: string = '/admin/languageCfg/store'; static msg: string = '成功'; static data: any = Mock.mock({ 'data|50-99': [ { name: '@cname', address: '@city(true)', id: '@increment()', }, ], }); } "},"tool/Markdown.html":{"url":"tool/Markdown.html","title":"Markdown","keywords":"","body":"Markdown # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 *斜体文本* **粗体文本** ***粗斜体文本*** *** ~~删除线~~ 下划线 * 第一行 * 第二行 1. 第一行 2. 第二行 > 区块引用 >> 区块嵌套引用 ` 行代码 ` ​``` 代码块 [链接名称](链接地址) ![图片描述](本地链接或者URL地址) ### Typora 快捷键 ```css Ctrl + 1 ：一级标题 Ctrl + 2 ：二级标题 Ctrl + 0 ：段落 Ctrl + = ：提升标题等级 Ctrl + - ：降低标题等级 Ctrl + Home ：跳转到文首 Ctrl + End ：跳转到文末 Ctrl + Tab ：应用内窗口切换 Ctrl + / ：源代码模式 Ctrl + \\ ：清除样式 Ctrl + [ ：减少缩进 Ctrl + ] ：增加缩进 Ctrl + 逗号 ：偏好设置 Ctrl + B ：加粗 Ctrl + D ：选中当前词 Ctrl + E ：选中当前格式文本 Ctrl + I ：斜体 Ctrl + U ：下划线 Alt + shift + 5 ：删除线 Ctrl + J ：跳转到所选内容 Ctrl + K ：超链接 Ctrl + L ：选中当前行 Ctrl + shift + I ：插入图片 Ctrl + shift + K ：插入代码块 Ctrl + shift + M ：插入公式 Ctrl + shift + [ ：有序列表 Ctrl + shift + ] ：无序列表 Ctrl + O ：打开 Ctrl + P ：快速打开 Ctrl + T ：插入表格 Alt + Ctrl + P ：选择段落或块 Ctrl + shift + 1 ：大纲 Ctrl + shift + 2 ：文档列表 Ctrl + shift + 3 ：文件树 Ctrl + shift + 9 ：实际大小 Ctrl + shift + D ：删除当前词 Ctrl + shift + E ：使用上一次设置导出 Alt + Ctrl + shift + P ：删除块 Alt + Ctrl + shift + L ：删除当前行或句 Alt + Ctrl + shift + E ：删除当前格式文本 shift + F10 ：快捷操作弹窗 shift + F12 ：开发者工具 "},"tool/Moment.html":{"url":"tool/Moment.html","title":"Moment","keywords":"","body":"Moment Moment 原型通过 moment.fn 公开 Moment.prototype.format == moment.fn.format == moment＃format 解析 moment() 获取当前的日期和时间 moment() //上下相同 moment(new Date()) moment(Number) 时间戳转换 moment(1318781876406) moment(Date) 使用预先存在的原生 Javascript Date 对象来创建 Moment var day = new Date(2011, 9, 16); var dayWrapper = moment(day); 默认值 moment(5, \"DD\"); // 本月的第 5 天 moment(5, \"HH\"); // 今天 5:00:00.000 moment(\"4 05:06:07\", \"DD hh:mm:ss\"); // 本月的第 4 天 05:06:07.000 moment(3, \"MM\"); // 今年第三个月（三月） moment(\"Apr 4 05:06:07\", \"MMM DD hh:mm:ss\"); // 今年四月的第 4 天 05:06:07.000 取值/赋值 millisecond() 获取或设置毫秒，接受 0 到 999 之间的数字 超出范围，则会冒泡到秒钟 moment().millisecond(Number); moment().milliseconds(Number); second() 获取或设置秒钟 , 接受 0 到 59 之间的数字 超出范围，则会冒泡到分钟 moment().second(Number); moment().seconds(Number); minute() 获取或设置分钟 , 接受 0 到 59 之间的数字 超出范围，则会冒泡到小时 moment().minute(Number moment().minutes(Number); hour() 获取或设置小时, 接受 0 到 23 之间的数字 超出范围，则会冒泡到日期 moment().hour(Number); moment().hours(Number); date() 获取或设置月份的日期, 接受 1 到 31 之间的数字 超出范围，则它将会冒泡达到月份 moment().date(Number); month() 获取或设置月份，接受 0 到 11 之间的数字 超出范围，则会冒泡到年份 月份是零索引的，因此一月是月份 0 支持月份名称设置 moment().month(string | number); year() 获取或设置年份，接受 -270,000 至 270,000 之间的数字 moment().year(Number); moment().years(Number); 链接操作 链接多个操作以构造一个日期，应从年份、月份、日期等依次开始 moment().year(year).month(month).date(day) dayOfYear() 获取或设置年份的日期，接受 1 到 366 之间的数字 超出范围，则会冒泡到年份 moment().dayOfYear(Number); day() 获取或设置星期几，此方法可用于设置星期几，其中星期日为 0、星期六为 6 超出范围，则会冒泡到其他星期 也支持星期名称 moment().day(Number|String); moment().days(Number|String); week() 获取或设置年份的星期 moment().week(Number); moment().weeks(Number); quarter() 获取或设置季度 ，接受 1 到 4之间的数字 超出范围，则会冒泡到下一年 moment().quarter(Number); moment().quarters(Number); get(string) moment().get('year'); moment().get('month'); moment().get('date'); moment().get('hour'); moment().get('minute'); moment().get('second'); moment().get('millisecond'); set(string,number) moment().set('year', 2013); moment().set('month', 3); moment().set('date', 1); moment().set('hour', 13); moment().set('minute', 20); moment().set('second', 30); moment().set('millisecond', 123); moment().set({'year': 2013, 'month': 3}); max () 返回给定的 moment 实例的最大值 moment.max(Moment[,Moment...]); moment.max(Moment[]); moment.max(a, b); // b min() 返回给定的 moment 实例的最小值 moment.min(Moment[,Moment...]); moment.min(Moment[]); moment.min(a, b); // a moment.min([a, b]); // a 操作 add() 通过增加时间来改变原始的 moment 可以使用单词简写 moment().add(Number, String); moment().add(Duration); moment().add(Object); moment().add(7, 'days'); moment().add(7, 'd'); subtract() 通过减去时间来改变原始的 moment moment().subtract(Number, String); moment().subtract(Duration); moment().subtract(Object); moment().subtract(7, 'days'); startOf(String) 将原始的 moment 设置为时间单位的开头 moment().startOf('year'); // 设置为今年1月1日上午 12:00 moment().startOf('month'); // 设置为本月1日上午 12:00 moment().startOf('quarter'); // 设置为当前季度的开始，即每月的第一天上午 12:00 moment().startOf('week'); // 设置为本周的第一天上午 12:00 moment().startOf('isoWeek'); // 根据 ISO 8601 设置为本周的第一天上午 12:00 moment().startOf('day'); // 设置为今天上午 12:00 moment().startOf('date'); // 设置为今天上午 12:00 moment().startOf('hour'); // 设置为当前时间，但是 0 分钟、0 秒钟、0 毫秒 moment().startOf('minute'); // 设置为当前时间，但是 0 秒钟、0 毫秒 moment().startOf('second'); // 与 moment().milliseconds(0); 相同 endOf(String) 将原始的 moment 设置为时间单位的末尾 moment().endOf(\"year\"); // 将 moment 设置为今年的 12 月 31 日 23:59:59.999 显示 format() 显示格式 moment().format(); moment().format(String); 年份:YYYY 月份:M 月份的日期:D 小时24:HH 小时12:hh 分钟:mm 秒钟:ss 季度:Q 年份的星期:w 星期几：d 子午线：A(AM PM) 年份的日期：DDD Unix 时间戳:X(秒) x(毫秒) valueOf() 获得当前时间戳 moment().valueOf(); +moment(); daysInMonth() 获取当月天数 moment().daysInMonth(); toArray() 返回一个数组，该数组反映了 new Date() 中的参数 moment().toArray(); // [2013, 1, 4, 14, 40, 16, 154]; toJSON() 获取UTC（世界时）格式的json字符串 moment().toJSON(); //'2023-05-05T07:08:31.045Z' toObject() 返回一个包含年份、月份、月份的日期、小时、分钟、秒钟、毫秒的对象 moment().toObject(); //{years: 2023, months: 4, date: 5, hours: 15, minutes: 11, …} 查询 isBefore() 检查一个 moment 是否在另一个 moment 之前 moment('2010-10-20').isBefore('2010-10-21'); // true isSame() 检查一个 moment 是否与另一个 moment 相同 moment('2010-10-20').isSame('2010-10-20'); // true isAfter() 检查一个 moment 是否在另一个 moment 之后 moment('2010-10-20').isAfter('2010-10-19'); // true isBetween() 检查一个 moment 是否在其他两个 moment 之间 moment('2010-10-20').isBetween('2010-10-19', '2010-10-25'); // true moment('2010-10-20').isBetween('2010-10-19', undefined); // true, 因为 moment(undefined) 等效于 moment() "},"vueDemo/":{"url":"vueDemo/","title":"VueDome","keywords":"","body":"前端技巧视频 "},"vueDemo/瀑布流.html":{"url":"vueDemo/瀑布流.html","title":"瀑布流","keywords":"","body":"瀑布流 vue3 + Gaid {{ index }} const data = [ { height: 160, color: \"#ef3429\" }, ] .masonry { width: 230px; display: grid; grid-template-columns: repeat(auto-fill, 50px); column-gap: 10px; row-gap: 1px; } vue2 + flex import data from \"./data.json\"; export default { data() { let data1 = [], //第一列 data2 = [], //第二列 data3 = [], //第三列 i = 0; while (i .masonry { display: flex; flex-direction: row; .colmun { display: flex; flex-direction: column; flex: 1; padding: 0 2px; .item { margin-bottom: 5px; width: 100%; } } } "},"vueDemo/SSR.html":{"url":"vueDemo/SSR.html","title":"SSR","keywords":"","body":"SSR "},"vueDemo/websocket.html":{"url":"vueDemo/websocket.html","title":"websocket","keywords":"","body":"websocket "},"vueDemo/storage封装.html":{"url":"vueDemo/storage封装.html","title":"storage 封装","keywords":"","body":"storage 文章地址 const config = { type: \"loaclStorage\",// 本地存储类型 localStorage/sessionStorage prefix: 'CBD_1.0.0',// 名称前缀 建议：项目名 + 项目版本 expire: 60 * 60 * 24 * 30,//过期时间 单位：秒 isEncrypt: true, // 是否加密 } interface indexObj { [key: string]: any } // 名称前自动添加前缀 function autoAddPrefix(key: string) { const prefix = config.prefix ? config.prefix + '_' : ''; return prefix + key; } // 移除已添加的前缀 function autoRemovePrefix(key: string) { const len: number = config.prefix ? config.prefix.length + 1 : 0; return key.substr(len); } // 设置storage // { key:键值,value:数据,expire:过期时间,noRenewal:是否不续期 } export function setStorage(key: string, value: any, expire?: number, noRenewal?: boolean) { if (!value) value = null expire = (expire ? expire : config.expire) * 1000 let data: (object | string) = { value: value,//存储值 time: Date.now(),//存储时间戳 expire: expire, //过期时间 noRenewal, } data = JSON.stringify(data); key = autoAddPrefix(key); // if (config.isEncrypt) data = encrypt(data) //加密 (window)[config.type].setItem(key, data) } // 获取storage // { key:键值 } export function getStorage(key: string) { key = autoAddPrefix(key) let data = (window)[config.type].getItem(key) if (!data || JSON.stringify(data) === \"null\") return null // if (config.isEncrypt) data = decrypt(data) //解密 const nowTime = Date.now() if (data.expire && data.expire window)[config.type].removeItem(autoAddPrefix(key)); } // 清空 clearStorage export const clearStorage = () => { (window)[config.type].clear(); } // 判断是否可用 JSON.parse export function isJson(value: any) { if (Object.prototype.toString.call(value) === '[object String]') { try { const obj = JSON.parse(value); const objType = Object.prototype.toString.call(obj); return objType === '[object Object]' || objType === '[object Array]'; } catch (e) { return false; } } return false; } // 派发storage的数据变化 export function dispatchEventStroage() { const signSetItem = localStorage.setItem localStorage.setItem = function (key, val) { signSetItem.apply(this, arguments) //更改setItem的this指向，arguments传入的参数数组（name,value） let setEvent: any = new Event('setItemEvent') //构造函数 setEvent.key = key setEvent.value = val window.dispatchEvent(setEvent) //发送事件到监听器上 } } // 监听storage的数据变化 // window.addEventListener(\"setItemEvent\", function (e: any) { // const newdata = JSON.parse(e.value); // }); "},"vueDemo/web分页搜索存储.html":{"url":"vueDemo/web分页搜索存储.html","title":"web 分页搜索存储","keywords":"","body":"web 分页搜索存储 vue2+ts+Mixins import { Component, Vue } from 'vue-property-decorator'; //页面分页信息保存 interface pagingInt { name: string; pagingInfo: object; } @Component export default class PagingStroage extends Vue { pageObj: any; //对页面分页和过滤进行存储 filters: any; newPageObj: any; filterConfig: any; created() { this.getStoragePagingInfo(); } beforeDestroy() { this.setStoragePagingInfo(); } pageRoute: any = null; //设置当前页码分页信息 getStoragePagingInfo() { this.pageRoute = this.$route; //获取当前分页信息 const pagingInfo = this.getStoragePaging(this.pageRoute); if (!pagingInfo) return; //将存储的分页信息赋值给pageObj if (pagingInfo.pageObj) { this.pageObj = { ...this.pageObj, ...pagingInfo.pageObj }; } //处理存储的过滤信息，并且赋值 if (pagingInfo.filters) { this.filters = { ...this.filters, ...pagingInfo.filters }; for (let key in pagingInfo.filters) { const value = pagingInfo.filters[key]; if (this.filterConfig[key]) { this.filterConfig[key].value = value; } if (key === 'endTime' || key === 'startTime') { this.filterConfig.date.option[key].value = value; } } } } //存储当前分页信息 setStoragePagingInfo() { if (!this.newPageObj) return; let pagingInfo: any = { pageObj: this.newPageObj.current || this.newPageObj.pageSize ? this.newPageObj : null, filters: this.filters || null, }; this.setStoragePaging(this.pageRoute, pagingInfo); } //获取分页信息 getStoragePaging(route: any) { let dataJson: any = window.sessionStorage.getItem('pagingInfo'); let data: pagingInt[] = dataJson ? JSON.parse(dataJson) : []; if (data.length > 0 && route) { let pagingInfo: any = null; let newData: pagingInt[] = []; data.forEach((item: pagingInt) => { if (item.name === route.name) { pagingInfo = item; } else { newData.push(item); } }); if (newData.length > 0) { window.sessionStorage.setItem( 'pagingInfo', JSON.stringify(newData) ); } else { window.sessionStorage.removeItem('pagingInfo'); } if (pagingInfo) { return pagingInfo.pagingInfo; } } return null; } //设置分页信息 setStoragePaging(route: any, pagingInfo: object) { if (!pagingInfo) return; const newData: pagingInt = { name: route.name, pagingInfo, }; let data: any = window.sessionStorage.getItem('pagingInfo'); data = data ? JSON.parse(data) : []; data = [...data, newData]; window.sessionStorage.setItem('pagingInfo', JSON.stringify(data)); } } //清空分页信息 export function removeStoragePaging() { setTimeout(() => { window.sessionStorage.removeItem('pagingInfo'); }, 0); } "},"vueDemo/虚拟列表.html":{"url":"vueDemo/虚拟列表.html","title":"虚拟列表","keywords":"","body":"虚拟列表 InfiniteList.vue import { ref, computed, nextTick, reactive, watchEffect, onUnmounted } from 'vue' const props = defineProps }>() // 列表HTMLElementDom const ulRef = ref(null) // 屏幕高度 const screenH = document.documentElement.clientHeight const data = reactive({ // 列表第一项的高度（起始高度） initH: 0, // 一行的高度 unitH: 0, // 屏幕范围内能显示个数 displayCount: 1, // 列表起始值 startIdx: 0 }) const listData = computed(() => { let endIdx = data.startIdx + data.displayCount if (endIdx >= props.listData.length) endIdx = props.listData.length return props.listData.slice(data.startIdx, endIdx).map((v, k) => { v.idx = data.startIdx + k + 1 return v }) }) function scrollHandler() { // 当前滚动高度 const curScrollTop = document.documentElement.scrollTop if (curScrollTop > data.initH) { const addCount = Math.floor((curScrollTop - data.initH) / data.unitH) ulRef.value.style.setProperty('padding-top', `${addCount * data.unitH}px`) data.startIdx = addCount } else { ulRef.value.style.setProperty('padding-top', '0px') data.startIdx = 0 } } watchEffect(() => { if (props.listData.length > 0) { nextTick(() => { // 列表距离顶部距离 data.initH = ulRef.value.getBoundingClientRect().top + document.documentElement.scrollTop // 计算每行高度 data.unitH = ulRef.value.children[0].offsetHeight // 计算屏幕内能显示的行数 data.displayCount = Math.ceil(screenH / data.unitH) // 设置列表总高度 = 一行高度 * 行数 const listH = data.unitH * props.listData.length ulRef.value.style.setProperty('height', `${listH}px`) window.removeEventListener('scroll', scrollHandler) window.addEventListener('scroll', scrollHandler) }) } }) onUnmounted(() => { window.removeEventListener('scroll', scrollHandler) }) .ulRef { box-sizing: border-box } list.vue 111 sfas 0\" :listData=\"songs\"> {{ listItem.idx }}{{ listItem.name }} import { reactive, ref, onMounted } from 'vue'; import InfiniteList from '@comp/InfiniteList/index.vue' import { TestList } from \"@api/Test\" let songs = ref([]) // 列表数据 const getTestList = async () => { let res = await TestList() songs.value = res.list console.log(songs.value.length > 0) } getTestList() "},"设计原则/":{"url":"设计原则/","title":"设计原则","keywords":"","body":"设计原则 "},"设计原则/类之间的关系.html":{"url":"设计原则/类之间的关系.html","title":"类之间的关系","keywords":"","body":"类之间的关系 泛化关系 -- 继承 对已有类型进行扩展 派生类继承非抽象类的基类，并且对基类进行一个更细致化的扩展 suv是小汽车的一个泛化关系，suv是小汽车的一个派生类 class Car { showType() { console.log(\"基类的方法\") } } class SvuCar extends Car{ showType(): void { console.log('对基类的二次扩展') } } 实现关系 -- 继承 实现了基类定义了但是不能实现的功能 基类属于一个抽象类，需要派生类进行一个继承，去实现对应的功能 车则是一个抽象的定义，而小汽车则是对车进行了二次的定义并且实现了，所以小汽车是对车进行了一个实现定义的关系 abstract class Transfrom { abstract move(): void } class Bike extends Transfrom { move() { return '实现transfrom' } } const a = new Bike a.move() //'实现transfrom' 聚合关系 -- 非强关联 由几个类进行组合一个类，进行一个方法的实现 类A和类B，类A包含类B， 类B是类A的成员变量 双方不是平级的，是整体和部分的关系 学生聚合起来，组成学习小组，xx学习小组撤销了，学生并不会因此消失 class Student { //学生 name: string constructor(name: string) { this.name = name } } class Group { //小组 member: Array constructor() { this.member = new Array() } add(item: Student) { this.member = [...this.member, item] } } const group = new Group() group.add(new Student('小x')) //添加小组成员 组合关系 -- 强关联 由多个类组成一个类，进行一个方法的实现 A类由B类C类组成,A类消失，B类C类也随之消失 双方不是平级的，是整体和部分的关系 若干个班级组成xx学校，xx学校消失了，xx学校xx班级也随之消失 class School { //学校 grades: Array = new Array() initGrades(...grade: Grade[]) { this.grades = [...this.grades, ...grade] } deinit() { this.grades = new Array() } } class Grade { //班级 name: string constructor(name: string) { this.name = name } } const school = new School() school.initGrades(new Grade('一年级x班'), new Grade('二年级x班')) 关联关系 -- 强关联 A类中使用B类，A类就对B类进行一个关联 A类销毁时，A类对类的关联也随之消失 关联关系双方是平级的，是个体和个体的关系 class IdCar { //身份证 id: number constructor(id: number) { this.id = id } } class Civics { //公民信息 name: string idCard: IdCar constructor(name: string, id: number) { this.name = name this.idCard = new IdCar(id) } ShowMeYourCard(): IdCar { return this.idCard } } 依赖关系 -- 临时性 -- 动态性 当A类某个参数依赖于B类，当A类需要某个参数时，B类则对A类进行依赖注入 class IdCar { //身份证 id: number constructor(id: number) { this.id = id } } class Civics { //公民身份信息 name: string idCard: IdCar constructor(name: string, idCar: IdCar) { this.name = name this.idCard = idCar } } let a = new Civics('张三',new IdCar(123))//公民内部的IdCar就是初始化的注入 "},"设计原则/设计原则.html":{"url":"设计原则/设计原则.html","title":"设计原则","keywords":"","body":"设计原则 单一职责原则表达实现类要职责单一 里氏替换原则表达不要破坏继承体系 依赖倒置原则表达面向接口编程 接口隔离原则表达在设计接口的时候要精简单一 迪米特法则表达要降低耦合 开闭原则是总纲，表达要对扩展开放，对修改关闭。 单一职责原则(SRP) 定义 一个类应该只有一个发生变化的原因，即一个类只负责一项职责 核心 解耦和增强内聚性 优点 降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多。 提高类的可读性，提高系统的可维护性。 变更引起的风险降低，变更是必然的，如果 SRP 遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 开闭原则(OCP) 定义 软件中的实体（类，模块，函数等等）应该对扩展开放，对修改封闭 一个实体是允许在不改变它的源代码的前提下变更它的行为 优点 保持系统的可维护性和代码的重用性 想遵守开闭原则 , 在做系统设计（概要设计、详细设计）的时候就要*考虑到未来的扩展和改变 里氏替换原则(LSP) 定义 派生类（子类）对象可以在程序中代替其基类（父类）对象 优点 实现开闭原则的重要方式之一 克服了继承中重写父类造成的可复用性变差的缺点 类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性 替换原则 任何基类可以出现的地方，子类一定可以出现 子类必须完全实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类可以实现自己特有的方法 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格（类向上转换是安全的，向下转换则不一定是安全） 子类的实例可以替代任何父类的实例，不成立则不符合替换原则 注意点 子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法 LSP 是继承复用的基石 里氏代换原则是对开闭原则的补充 依赖倒置原则(DIP) 定义 高层模块，低层模块，细节都应该依赖抽象 高层模块不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 细节 -- 较为具体的东西，比如具体的类 抽象 -- 具有契约性、共同性、规范性的表达 优点 减少类间的耦合性 降低并行开发引起的风险 提高代码的可读性和可维护性 注意点 分清细节与抽象 变量的声明类型尽量是抽象类或接口 尽量不要覆写基类的方法 继承要遵循里氏替换原则 迪米特法则(LOD) 定义 只和对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法 两个软件实体无须直接通信，那么就不应当发生直接的相互调用 ，可以通过第三方转发该调用 依赖者的角度来说，只依赖应该依赖的对象 被依赖者的角度说，只暴露应该暴露的方法 优点 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性 实现原则 类的划分：应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用 类的结构设计： 每一个类都应当尽量降低其成员变量和成员函数的访问权限 类的设计 ： 只要有可能，一个类型应当设计成不变类 对其他类的引用： 一个对象对其他对象的引用应当降到最低 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法） 注意点 过度使用迪米特法则会系统产生大量的中介类，增加系统复杂性，模块之间的通信效率降低。所以，在釆用时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 接口隔离原则(ISP) 定义 客户端不应该依赖它不需要的接口 一个类对另一个类的依赖应该建立在最小的接口上 优点 建立单一接口， 不是该功能的功能不需要 尽量细化接口，接口中的方法尽量少 提高系统的灵活性和可维护性 区别 单一职责原则 注重的是职责 主要是约束类，其次才是接口和方法 针对的是程序中的实现和细节 接口隔离原则 注重对接口依赖的隔离 主要约束接口 , 主要针对抽象 针对程序整体框架的构建 注意点 接口尽量小，但是要有限度 只暴露给调用的类它需要的方法 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好 组合/聚合复用原则(CARP) 定义 尽量使用组合/聚合，尽量不要使用继承 复用方式 组合 -- 任何环境 将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能 优点： 新对象存取成分对象的唯一方法是通过成分对象的接口 复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的 复用所需的依赖较少 每一个新的类可以将焦点集中在一个任务上 组合/聚合是动态行为 缺点： 有较多的对象需要管理 继承 -- 一些环境 继承复用通过扩展一个已有对象的实现来得到新的功能 优点： 新的实现比较容易，因为基类的大部分功能都可以通过继承自动的进入子类 修改或扩展继承而来的实现较为容易 缺点： 继承复用破坏了包装，因为继承超类的的实现细节暴露给子类。由于超类的内部细节常常对子类是透明的，因此这种复用是透明的复用，又称“白箱”复用 如果基类的实现发生改变，那么派生类的实现也不得不发生改变 从超类继承而来的实现是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性 使用原则 满足 “Is-A” 的关系是才可以使用继承 组合却是一种 “Has-A”（整体与部分）的关系 注意点 首选组合，然后才是继承 继承时应该严格的遵守里氏替换原则，必须满足 “Is-A” 的关系是才能使用继承 "},"设计原则/设计模式.html":{"url":"设计原则/设计模式.html","title":"设计模式","keywords":"","body":"一、构造器模式 class Employee { name age constructor(name: string, age: number) { this.name = name this.age = age } say() { console.log(this.name + this.age) } } const employee1 = new Employee(\"ker\", 100) const employee2 = new Employee(\"ker\", 100) employee1.say 二、工厂模式 定义 又名静态工厂模式 根据参数的**不同返回不同类的实例 class User { role pages constructor(role: string, pages: Array) { this.role = role this.pages = pages } static UserFactory(role: string) { switch (role) { case 'user': return new User('user', [1]) case 'admin': return new User('admin', [1, 2]) } } } let a = new User.UserFactory(\"admin\") 优点 将对象创建和对象业务逻辑部分分离，降低系统的耦合性，使修改更加容易 工厂方法是静态的，可以直接通过类名调用 缺点 工厂方法是静态的，不能被派生类继承 如果工厂需要加入新的产品，会对工厂类进行修改，违背了开闭原则 抽象工厂模式 不直接生成实例，而是用对于产品类蔟的创建 //创建基类 class User { name role router constructor(name: string, role: string, router: number[]) { this.name = name this.role = role this.router = router } welcome() { console.log(`欢迎回来${this.name}`) } } //创建对于派生类 class UserAdmin extends User { constructor(name: string) { super(name, 'userRole', [1,]) } dataShow() { console.log(\"重写了方法\") } } //创建对于派生类 class Admin extends User { constructor(name: string) { super(name, 'adminRole', [1, 2, 3]) } dataShow() { console.log(\"重写了方法\") } } //通过传入的值 选择返回对于的派生类 function getRoleFactory(role: string) { switch (role) { case \"userRole\": return UserAdmin case \"adminRole\": return Admin } } let RoleClass: any = getRoleFactory('adminRole') let userInfo = new RoleClass('管理员') 优点 创建基类，根据不同的要求创建不同的派生类，避免修改基类内容 三、建造者模式 侧重点----创建对象的的过程,甚至是每一个细节 //比赛信息--表示层 class MatchInfo { init() { console.log(\"初始化\") } getDate() { let res = { code: 200, data: [], msg: '请求成功' } console.log(res) } editData(res: any) { let data = res.data console.log(data) } } //用户信息--表示层 class UserInfo { init() { console.log(\"初始化\") } getDate() { let res = { code: 200, data: [], msg: '请求成功' } console.log(res) } editData(res: any) { let data = res.data console.log(data) } } //构建层 class Creator { async startBuild(builder: any) { builder.init() const res = await builder.getDate() builder.editData(res) } } //使用类 const op = new Creator() op.startBuild(new MatchInfo()) op.startBuild(new UserInfo()) 优点 将负责对象的构建层和表示层相互分离 构建过程可采用不同的表示层 "},"standard/规范.html":{"url":"standard/规范.html","title":"规范","keywords":"","body":"规范 CSS 规范 BEM 命名规范 stick-man // - 连接 不使用驼峰 __head // __ 上级的子组件 --blue // -- 上级的状态 状态 前一个 prev 后一个 next 当前的 current 显示的 show 隐藏的 hide 打开的 open 关闭的 close 选中的 selected 有效的 active 默认的 default 反转的 toggle 禁用的 disabled 危险的 danger 主要的 primary 成功的 success 提醒的 info 警告的 warning 出错的 error 大型的 lg 小型的 sm 超小的 xs 布局 文档 doc 头部 header(hd) 主体 body 尾部 footer(ft) 主栏 main 侧栏 side 容器 box/container 栏目 column 通用部件 列表 list 列表项 item 表格 table 表单 form 链接 link 标题 caption/heading/title 菜单 menu 集合 group 条 bar 内容 content 结果 result 组件 按钮 button(btn) 字体 icon 下拉菜单 dropdown 工具栏 toolbar 分页 page 缩略图 thumbnail 警告框 alert 进度条 progress 导航条 navbar 导航 nav 子导航 subnav 面包屑 breadcrumb(crumb) 标签 label 徽章 badge 巨幕 jumbotron 面板 panel 洼地 well 标签页 tab 提示框 tooltip 弹出框 popover 轮播图 carousel 手风琴 collapse 定位浮标 affix 语义化小部件 品牌 brand 标志 logo 额外部件 addon 版权 copyright 注册 regist(reg) 登录 login 搜索 search 热点 hot 帮助 help 信息 info 提示 tips 开关 toggle 新闻 news 广告 advertise(ad) 排行 top 下载 download JavaScript 规范 "},"WX/":{"url":"WX/","title":"微信","keywords":"","body":"微信 "},"WX/微信公众号.html":{"url":"WX/微信公众号.html","title":"微信公众号","keywords":"","body":"微信公众号 注意 JS-SDK说明文档 微信内置浏览器WeixinJSBridge 微信浏览器内部尚未初始化 sendMessage 进行绑定 if(document.addEventListener){ document.addEventListener('WeixinJSBridgeReady',sendMessage,false); }else if(document.attachEvent){ document.attachEvent('WeixinJSBridgeReady' , sendMessage); document.attachEvent('onWeixinJSBridgeReady' , sendMessage); } 常用参数 WeixinJSBridge.call('closeWindow'); //关闭当前浏览器 WeixinJSBridge.call(‘hideToolbar’); //隐藏右下面工具栏 WeixinJSBridge.call(‘showToolbar’); //显示右下面工具栏 WeixinJSBridge.call(‘hideOptionMenu’); //隐藏右上角三个点按钮。 WeixinJSBridge.call(‘showOptionMenu’); //显示右上角三个点按钮。 分享好友 （menu:share:appmessage） WeixinJSBridge.on('menu:share:appmessage', function(argv){ WeixinJSBridge.invoke('sendAppMessage',{ \"appid\":\"\", //appid 设置空就好了。 \"img_url\": imgUrl, //分享时所带的图片路径 \"img_width\": \"120\", //图片宽度 \"img_height\": \"120\", //图片高度 \"link\":url, //分享附带链接地址 \"desc\":\"我是一个介绍\", //分享内容介绍 \"title\":\"标题，再简单不过了。\" }, function(res){ /*** 回调函数，最好设置为空 ***/ }); }); 分享朋友圈 （menu:share:timeline） WeixinJSBridge.on('menu:share:timeline', function(argv){ WeixinJSBridge.invoke('shareTimeline',{ \"appid\":\"\", //appid 设置空就好了。 \"img_url\": imgUrl, //分享时所带的图片路径 \"img_width\": \"120\", //图片宽度 \"img_height\": \"120\", //图片高度 \"link\":url, //分享附带链接地址 \"desc\":\"我是一个介绍\", //分享内容介绍 \"title\":\"标题，再简单不过了。\" }, function(res){ /*** 回调函数，最好设置为空 ***/}); }); }); 分享到微博（menu:share:weibo） WeixinJSBridge.on('menu:share:weibo', function(argv){ WeixinJSBridge.invoke('shareWeibo',{ \"content\":dataForWeixin.title+' '+dataForWeixin.url, \"url\":dataForWeixin.url }, function(res){ /*** 回调函数，最好设置为空 ***/ }); }); 获取网络状态 WeixinJSBridge.invoke('getNetworkType',{},function(e){ // 在这里拿到e.err_msg，这里面就包含了所有的网络类型 e.err_msg }); //wifi wifi网络 //edge 非wifi,包含3G/2G //fail 网络断开连接 //wwan 2g或者3g "},"encrypt/":{"url":"encrypt/","title":"数据加密","keywords":"","body":"数据加密 "},"encrypt/crypto-js.html":{"url":"encrypt/crypto-js.html","title":"crypto-js","keywords":"","body":"crypto-js "},"server/":{"url":"server/","title":"server","keywords":"","body":"server "},"server/ngin.html":{"url":"server/ngin.html","title":"ngin","keywords":"","body":"nginx nginx服务器 nginx-服务器文件夹目录中不能有中文目录 dist 打包文件夹 放入nginx服务器 文件夹目录中 每次改完文件，都需要重新加载 需要在 阿里云 加入安全组 添加80端口 命令行 .\\nginx.exe -c conf\\kerwin.conf //加载kerwin.conf 并启动服务器 .\\nginx.exe -s stop //关闭nginx服务器 .\\nginx.exe -s reload //重新加载 conf/kerwin.conf 文件夹 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream kerwin-server { server localhost:3001 weight=1; server localhost:3002 weight=1; } server { listen 80; //访问域名 server_name localhost; //访问协议 location / { root dist; //加载的文件夹名 index index.html index.htm; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location /ajax/ { //反向代理配置 proxy_pass https://m.maoyan.com; } } } "},"Linux/Linux.html":{"url":"Linux/Linux.html","title":"Linux","keywords":"","body":"Linux "}}