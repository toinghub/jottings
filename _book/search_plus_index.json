{"./":{"url":"./","title":"前言","keywords":"","body":"node随笔 "},"node/":{"url":"node/","title":"node","keywords":"","body":"node基础 "},"node/node基础.html":{"url":"node/node基础.html","title":"node-基础","keywords":"","body":"一、nvm指令 nvm list //查看已安装的nodejs版本 nvm on // 启用node.js版本管理 nvm off // 禁用node.js版本管理(不卸载任何东西) nvm install // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0 nvm use //使用某一version的nodejs nvm uninstall // 卸载指定版本的nodejs nvm alias default //切换默认版本 代码工具 lodash npm搜索 官网lodash.com underscore 开源项目CDN 二、NPM知识 命令行 npm init -y //创建package文件 --sava //安装 -S 简写 --dev //开发环境使用 -D 简写 -g //全局安装 install //安装 i 简写 npm uninstall gulp -D //卸载包 npm list //显示包管理的关系 npm list | grep 包名 //显示指定包管理的关系 三层关系 npm i --production //只装生产环境的包 npm view 包名 versions //查看包版本号 -V 简写 npm i 包名@版本号 -S //安装包指定版本号 版本号可不写 npm outdated //查看那些包已过期 npm update //更新包 npm cache clean --force //强制清除缓存 npm config get registry //查看当前源 npm config set registry 地址 //切换源 npm i git+https://git@ (git地址) //下载git项目（当hhs时，把https改成ssh） 使用npm i可以重新直接安装package里的内容 package-lock 显示包依赖关系 __dirname //当前代码所在文件的物理路径 包类型 1.内置的包 2.第三方库 3.自己定义的包 上传包 npm init -y 初始化 npm adduser 添加账户 npm publish 上传包 三、package 文件解析 package中的 ^1.12.1的^表示当前版本号需要按语义做适配 major 主版本号 minor 次版本号 patch 补丁号 ^1.12.2 //锁定主版本号（major ） ~1.12.2 //锁定主版本号和次版本号（minor） 1.12.2 //锁定所有版本号（patch） * //最新版本 配置信息： \"name\": \"opipjl\", //发布包的名 \"version\": \"1.0.0\", //版本号 \"description\": \"\", //描述 \"main\": \"index.js\", //包的入口 \"keywords\": [], //关键字 \"author\": \"\", //作者 \"license\": \"MIT\", //许可证协议 \"repository\":{\"type\":\"Git\",\"url\":\"git+ \" } //包的git地址 NPM脚本 package.json中的 scripts 字段 ​ 全局 --> 本地 & //可以连接两个命令行 不分先后 && //依次执行 分先后 test start //可以简写，不写run process.env.npmpackage变量名 //能拿到package里的值(只能在脚本中访问) echo $npm_package_config_dev //window疑似不支持 Cross-env (命令兼容平台) npm install --sava-dev cross-env //安装 简写：npm i -S -D cross-env cross-env NODE_ENV=test1 node ./test1.js //NODE_ENV 为命令中的变量名和变量值 后面为执行命令 process.env.NODE_ENV //在./test1.js中获取NODE_ENV的值 四、NRM 管理源 npm的镜像源管理工具 npm i -g nrm //安装nrm nrm ls //查看可选源 nrm use taobao //切换源 nrm test //测试源响应速度 NPX npx gulp -D //当galp未安装时，会生成一个临时路径安装gulp npx --on--install http-server //强制使用本地模块 npx --ignore--existing http-server //强制安装远程模块 commonJs 解意：nodeJs的第三方规范 四步骤使用模块 定义模块 --创建文件且写入内容 暴露模块 --将写入内容暴露给外部 引入模块 --其他文件引入模块 使用模块 --使用定义的模块 module.export = {name,age} //对象写法 exprot.name = name //赋值写法 //衍生写法 exports.default = { } module.exports = { default } 五、nodeJs内置模块 JS日志工具(log4js) const log4js = require('log4js') log4js.configure({ appenders: { cheese: { type: 'file', filename: 'cheese.log' } }, categories: { default: { appenders: ['cheese'], level: 'error' } }, }) const logger = log4js.getLogger('cheese') logger.level = 'debug' logger.debug() 1、url const url = require('url') const urlString = 'https://www.baidu.com:443/pathh/index.html?id=1#tag=2' const urlObj = { parse解析出的对象 } url.parse(urlString,true) //parse 数据解析 (true时，query为对象格式) url.format(urlObj) //format 反向编译路径 url.resolve(\"http://www.baiducom/a\",\"../\") //回到上一层 url.resolve(\"http://www.baiducom/a\",\"/b\") //替换a为b const urlParams = new URLSearchParams(url.parse(urlString).search) urlParams.get('id') //获取search指定字段 2、qureySring const querystring = require('querystring') const query = 'id=2&name=tongy&from=上海' querystring.parse(query,':', '/') //解析 第一个参数key和value中的分隔符，第二个是value和key分隔符 querystring.escape(query) //编码 percent-encoded查询字符串 querystring.unescape(queryEscape) //解码 const queryObj = { id: 2, name: 'toingyi', from: '北京' } id=2&name=toingyi&from=%E5%8C%97%E4%BA%AC querystring.stringify(queryObj, ':', '/') //编译对象，后面两个参数替换的=和&符号 const newQuery = querystring.stringify(queryObj, null, null, { encodeURIComponent(string) { //中文保持不变 return querystring.unescape(string) }, }) 3、http //request 本地请求的函数 response服务器返回函数 http.createServer((request, response) => { response.writeHead(404, {\"content-type\":} ) //第一个返回状态码，第二个对象，返回头部的配置 response.write('home111') //返回内容 不会断开 response.end() //返回内容 会断开 }) ​ 3.1、get 请求 https.get( 'https://www.xiaomiyoupin.com/mtop/mf/resource/data/list', //请求的地址 (result) => { let data = '' result.on('data', (chunk) => { //chunk传回的数据 data += chunk }) result.on('end', () => { //利用response返回数据 }) } ) 3.2、post 请求 const postData = querystring.stringify({}) const options = { protocol: 'http:', //协议 hostname: 'localhost', //主机名 method: 'post', //方法类型 port: '3000', //端口号 path: '/data', //路径 headers: { //请求的首部字段 'content-type': 'application/x-www-form-urlencoded', 'content-length': Buffer.byteLength(postData), }, } const server = http.createServer((request, response) => { // const req = http.request(options, (result) => {}) req.write(postData) req.end() response.end() }) server.listen(80808,()=>{}) //监听端口号 请求头部信息 content-type : 对照表 node浏览器调试 // --inspect-brk 第一行打断点 node --inspect --inspect-brk server.js node进程管理工具 supervisor nodemon //热更启动 forever pm2 //部署 insomnia //调试工具 post请求 3.3、跨域（JSONP\\CORS\\middleware\\爬虫） JSONP 原理：利用在浏览器端请求js不跨域的特性 //前端代码 function getData(data){ console.log(data) } //后端代码 const server = http.createServer((request, response) => { let urlStr = request.url let urlObj = url.parse(urlStr, true) switch (urlObj.pathname) { case '/api/data': response.write(`${urlObj.query.cb}(\"hello\")`) //spanp中的p是填充的意思 break default: response.write('page no found') } response.end() }) CORS 原理：设置Access-Control-Allow-Origin白名单 response.writeHead(200, { 'content-type': 'application/json;charser=utf-8', 'Access-Control-Allow-Origin': '*', //后面的是白名单 }) proxy middleware(http-proxy-middleware) 文档地址 if (/\\/wph/.test(urlStr)) { const proxy = createProxyMiddleware('/wph', { //'/wph'确定应该将哪些请求代理到目标主机 target: 'https://mapi-rp.vip.com/', //要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { //路径重写 '^/wph': '', }, }) proxy(request, response) 爬虫 cheerio //爬到数据后，可以建立虚拟DOM树来解析 function filterData(data){ const $ = cheerio.load(data) $('.xxxx p').each((index,el)=>{}) //each == foreach } 4、event(自定义事件) const EventEmilter = require('events') class MyEventEmilter extends EventEmilter {} //继承EventEmilter const event = new MyEventEmilter() event.on('play', (value) => { //绑定事件（监听作用） console.log(value) }) event.emit('play', '执行') //触发事件 5、文件操作 注：错误优先的回调函数 5.1 文件夹操作 //创建文件 fs.mkdir('logs', (err) => { if (err) throw err }) // throw 抛出异常 //修改文件名/文件夹名 fs.rename('logs', 'log', (err) => {}) //待修改名 修改名 回调 //删除文件夹 fs.rmdir('./log', (err) => {}) //读取文件夹 fs.readdir('./logs', (err, result) => {}) 5.2 文件操作 //创建文件 fs.writeFile('./logs/log1.log', 'hello\\nwordd', (err) => {}) // 追加文件 fs.appendFile('./logs/log1.log', '!!!', (err) => {}) // 删除文件 fs.unlink('./logs/log1.log', (err) => {}) // 读取文件 fs.readFile('./logs/log1.log', 'utf-8', (err, content) => {}) //读取文件路径 返回内容格式 回调 // 同步读取文件 const content = fs.readFileSync('./logs/log1.log', 'utf-8', (err, content) => {}) //promise同步读取(node版本10以上) const fsPromises = require('fs').promises ;async () => { let result = await fsPromises.readFile('./logs/log1.log') } //判断某个文件是否存在 fs.existsSync(\"./index.html\") 5.3 遍历目录所有文件 function readdir(dir) { fs.readdir(dir, (err, content) => { //读取文件夹 content.forEach((value, index) => { let joinDir = `${dir}/${value}` fs.stat(joinDir, (err, stats) => { // stat获取文件或目录的信息 if (stats.isDirectory()) { //isDirectory 是否为目录 readdir(joinDir) } else { fs.readFile(joinDir, 'utf-8', (err, content) => { console.log(content) }) } }) }) }) } 5.4 监听文件 //文件路径 是否监听文件 是否监视所有子目录 字符编码 //eventType:rename或change（文件名出现或者消失时，触发rename） filename:触发事件的文件名称 fs.watch('./logs/log0',true,true,'utf8' (eventType,filename) => {}) //文件路径 是否为二进制 是否监听文件 监听间隔 fs.watchFile('./logs/log0',true,true,5000 (err) => {}) fs.watch //有一小部分平台文件名出现或者消失时,不触发rename，但是效率更高 fs.watchFile //没有上面的平台问题 5.5 文件流 （zlib压缩文件） const fs = require('fs') const zlib = require('zlib') const gizp = zlib.createGzip() const readStream = fs.createReadStream('./logs.txt') //读取流 const writeStream = fs.createWriteStream('./logs.gzip') //写入流 readStream.pipe(gizp).pipe(writeStream) //pipe 管道注入内容 5.6 逐行读取 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('What do you think of Node.js? ', (answer) => { // TODO：记录答案到数据库中 console.log(`Thank you for your valuable feedback: ${answer}`); rl.close(); }); 6、加密（crypto） const crypto = require('crypto') const passsword = 'abc' const hash = crypto .createHash('sha256') //sha256 加密的算法也可以是md5 .update(passsword) //加密谁 .digest('hex') //加密的形式 hex：十六进制 dec：十进制 oct：八进制 bin：二进制 36集 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue2 vue3 "},"vue/vue2.html":{"url":"vue/vue2.html","title":"vue2","keywords":"","body":"vue2 基础 创建项目 npm install -g @vue/cli 安装vuecli vue create vue 创建vue项目 知识 查兼容性 caniuse.com vue3生命周期销毁名字改动 vue修饰符keyup后面可以直接跟键位值 keyup.65 可以给input标签加上vlaue来通过$event 获取 多选框可以直接通过value通过model添加进数组 方法可以直接写到标签内，getData() 直接return出去了， betterScroll 实现页面中拖动滚动拉动等属性功能 window 远程桌面连接 动态添加对象属性 vue2 无法直接拦截，vue3可以直接改 vue.set(对象,属性,true) vue set(vm.classObj,\"dd\",true) 组件： //中央事件主线 var bus = new Vue //通过new vue 创建实例 bus.$emit(\"kerwin\",data) //传入数据 bus.$On(\"kerwin\",(data)=>{}) //接受数据 插槽： 指令： 自定义指令 this默认指向是window // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { inserted(el,binding) { // inserted 被绑定元素插入父节点时调用 } }) vue.directive('focus',(el,binding)=>{}) //简写 创建或更新都会执行 //局部指令 directives: { focus: { inserted (el) { } }， focus: (el){}，//简写 } v-focus=\"{index:1,name:q}\" //只有一个参数，但是可以传数组和对象 vue3中，指令的生命周期名字改成和组件生命周期一致了 $nextTick() 页面渲染完毕之后再加载 进阶 vue.config.js 文件配置 @ 别名 =》永远指向src的绝对路径 module.exports={ devServer :{ proxy :{ //配置反向代理 '/ajax':{ //确定应该将哪些请求代理到目标主机 target:\"https://baidu.com\",//要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { '^/ajax': '',}, ///路径重写 } }, }, configureWebpack:{ resolve:{ alias:{ //配置别名 'assets':'@/assets', 'components':'@/components' } } } } 路由： router.js Vue.use(VueRouter) //注册路由插件，两个全局组件 router-view router-link routers:[ { path: '/bill', component: Layout, //跳转路径 redirect: '/bill/equipmentList', //路由重定向 alwaysShow: true, //是否显时 name: '账单管理', meta:{isShhow:true} children: [ //嵌套路由 { path: 'billList', name: '账单列表', component: () => import('@/shopViews/bill/billList'), }, ] }, { //路由重定向 path:\"*\", redirect:\"/index\" //未匹配到时 重定向到index } ] const touter = new VueRouter({ mode:\"history\",//路由模式 routes }) 声明式导航 编程式导航 this.$router.push('/index') //路由跳转 router路由大对象 route当前匹配的路由 //动态路由 path:'/index/:myId' //动态路由 router.js文件 this.$router.push(`/index/${id}`) this.$toute.params.myId //拿到当前路由参数 //命名路由 name:'kerwin' //router.js 路由中命名 this.$router.push({ //跳转到名字为kerwi的路由 name:'kerwi', params:{ id, } }) //返回上一级 router.back() 路由模式 hash 默认 window.onhashchange 监听路径是否改变 history 无#号 后端需要配置，当url无匹配资源时，返回同一个index.html页面 全局路由守卫 meta:{isShhow:true} //to可以获取到meta的值 to.meta.isShhow router.beforEach(to,from,next)=>{ //to 即将进入的路由对象 from 正要离开的路由对象 next() //直接放行 next('/login') //也可重定向 next({ path:'/login', query:{path:'index'} //可以拼接参数 }) } 独享路由守卫 { path: '/bill', component: Layout, redirect: '/bill/equipmentList', alwaysShow: true, name: '账单管理', meta:{isShhow:true}, beforEach(to,from,next)=>{ //写在路由内部，为独享路由守卫 next() } }, 局部路由守卫 本质上是路由的生命周期 beforeRouteEnter(to,from,next)=>{}组件创建前调用，不能使用组件实例this beforeRouteUpdate(to,from,next)=>{}路由被改变，但是组件被复用时调用 beforeRouteLeave(to,from,next)=>{}导航离开时该组件调用 路由懒加载 按需加载 component: () => import('@/shopViews/bill/billList'), 组件UI库 elmentUi pc端 饿了吗开发 地址 Vant 移动端 有赞开发 地址 axios 请求 import axios from \"axios\"; const service = axios.create({ //创建axios实例 baseURL: '', timeout: 10000 }); service.interceptors.request.use( //发请求前拦截 config => {}, error => {} ); service.interceptors.response.use( //响应后拦截 response => {}, error => {} ); export default service; Vuex 状态管理模式 文档地址 vue devtools 小工具 vuex 默认管理在内存，刷新页面后公共状态会丢失 vuex 持久化 todo 后端数据的缓存快照，较少重复数据请求 actions、mutations 中的方法可以相互调用 state import { mapState,mapActions,mapMutations } from 'vuex' state:{id:1} //公共状态 类似data this.$store.state.id //查看state的公共状态 this.id //查看state的公共状态 computed: { ...mapState(['id']) ...mapState({ //取别名 userId:(state) => state.id }) } getters getters:{ //类似计算属性 getdoosId:state.id=>(id)=>{ return state.id == id ? true :false } } computed: { ...mapGetter(['getdoosId']) } actions actions:{ //支持异步和同步 requert（store, data）{} //store 下面的为解构的 requert（{ commit, state }, data）{ http().then(id=>{ //异步请求 commit.changeId(id) //实质上还是通过store.commit,更改state值 }) } } this.$store.dispatch('requert',data )//触发actions方法 分发 this.$store.dispatch('requert',data ).then()//有返回值，就可以then this.requert(data) //同上面分发语法一致 methods: { ...mapActions([ 'requert', ]), } mutations mutations:{ //统一管理，可以被devtools记录 只支持同步函数 changeId(state,enterId){ state.id = enterId //更改state的公共状态 } } this.$store.commit('changeId',2) //触发mutations方法 交付 import { mapMutations } from 'vuex' this.changeId(2) // 同上面交付语法一致 methods: { ...mapMutations([ 'changeId', ]), } modules 将需要写的内容模块化出去 import demo from './demo' export default new Vuex.Store({ modules:{ demo //模块的名称 } ) Vuex 持久化 vuex-persistedstate vuex-persist npm 1 vuex-persistedstate --save //安装 import createPersistedState from \"vuex-persistedstate\" //在需要的地方安装使用 const store =newVuex.Store({ plugins: [createPersistedState()] //缓存vuex所有数据 plugins: [createPersistedState({ //缓存配置 storage:'localStorage', //存储的位置 key:'vuexData', //键位名字，默认vuex reducer:(state){ //需要保存的值。默认情况下，保存整个状态。 id:state.id } })] }) mixins 混入 地址 var mixin = new Vue({ created () { this.$store.commit('changeId',1) },//当没有cerated才会生效 mounted(){ this.$store.commit('changeId',2) } methods:{ //当没有相同的时，会添加进去，有不添加 a(){} } }) mixins: [mixin] //混入文件写了后，可以引入需要功能的文件中 "},"vue/vue3.html":{"url":"vue/vue3.html","title":"vue3","keywords":"","body":"vue3 注意 filters过滤器被删除 页面生命周期函数名换了 vue2是类写法，vue3函数写法(没有this了) 文件template下可以放多个根节点，而不像vue2只能放一个根节点 Composition Api介绍 指令 //全局指令 createApp(App).directive('focus', { mounted(el,binding) { //生命周期名字换了 } }) 路由 import { useRouter,useRoute } form 'vue-router' const router = useRouter() //router == this.$router const route = useRoute() //route == this.$route 取值 路由模式 const router = createRouter({ history: createWebHistory(), //history模式 history: createWebHashHistory(), //hash模式 routes }) 声明式导航 生命周期 VUE2 vue3 beforeCreate setup Created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeUpdate updated onUpdate beforeDestroy onBeforeUnmount destroyed onUnmounted import { reactive,onBeforeMount,onMounted } from \"vue\" setup(){ onBeforeMount(()=>{}) onMounted(()=>{}) } reactive 创建响应式对象 reactive参数不能是字符串或者数字，否则会警告 {{obj.myname}} change import { reactive } from \"vue\" setup () { const obj = reactive({ //可以写多个reactive函数 myname: \"toing\" //类似data中的值 }) const data = reactive({}) //可以直接创建空对象、空数组 const handleClick = () => { //触发的方法 obj.myname = \"changeToing\" } return {obj,handleClick,data} //要返回 }, ref 访问原生dom节点 import { ref } from \"vue\" setup () { const myref = ref() //创建ref函数 const handleClick = () => { //触发的方法 console.log(myref.value) } return {myref} }, ref拦截字符串 有reactive一样的功能，可以拦截数据 {{refText}} 此处默认省略了value 实际上refText.value--> change import { ref } from \"vue\" setup () { const refText= ref(\"kerwin\") //可以直接拦截字符串 const handleClick = () => { //触发的方法 refText.value = \"changeToing\" } return {refText,handleClick} }, toRefs 把reactive里的每个属性，转化成ref对象，再通过...展开，变成多个ref对象 在template中，用ref语法，js中用reactive语法 {{myname}}--{{myage}} import { reactive,toRefs } from \"vue\" setup () { const obj = reactive({ myname: \"toing\", myage:\"100\" }) return { ...toRefs(obj),//在template中不用写obj.了 } }, props&emit props:['myname'] setup(props,{emit}){ const myname = props.myname //接受父组件数据 const handleClick=()=>{ emit(\"isShow\",11) //子传父 } return{myname,handleClick} } 计算属性 setup(){ const computedList = computed(()=>{ return 1 }) return{computedList} } watch watch(()=>obj.name,(newValue,oldValue)=>{ console.log(newValue,oldValue) }) 自定义hooks 将逻辑代码分离页面，写在外部的js文件中 //页面vue文件 import {getData} from './app.js' //引入逻辑js文件 setup(){ const obj = getData() return { obj } } //app.js文件 逻辑代码 import {onMouted} from \"vue\" function getData() // const obj = ref([]) cosnt obj = reactive({ list.[] }) onMouted(()=>{ obj.list = [1,2,3] }) return obj } exprot { getData } vuex import { useStore } from 'vuex' //引入逻辑js文件 setup(){ const store = useStore() //store == this.$store } 依赖注入功能 provide、inject 共享后，所有子组件都可以访问到 //主要文件 const isShow = ref(true) provide(\"kerwin\",isShow) //提供一个名为kerwin的服务 //下级所有子组件，不限层级 const isShow = inject(\"kerwin\")//将一个名为kerwin服务的地址栈注入到isShow中 "},"git/":{"url":"git/","title":"git","keywords":"","body":"git "},"git/git随笔.html":{"url":"git/git随笔.html","title":"git","keywords":"","body":"git git init //初始化仓库 git add . //添加到暂存区 git status //查看git此时提交状态 git commit -m '提交备注' //提交到本地仓库 git log //查看提交记录 git reset --hard HEAD~1 //回退上一个版本，~2就是回退两个版本 git reflog //操作记录 git reset --hard 6位版本号 //切换提交版本 操作记录处获取版本号 git remote add 别名(origin) 远程仓库地址 //绑定git远程仓库 git push -u origin 推送的分支名称 //将内容推送到远程仓库，-u记住地址，下次直接git push origin 推送的分支名称 git clone 仓库地址 //项目克隆 git pull 远程仓库地址 分支名称 //拉取远程仓库 git branch -a //查看所有分支 git checkout -b aa //创建新的分支aa git checkout aa //切换到aa分支的 git push origin aa //推送aa分支到远程仓库aa分支 git push origin master:aa //推送master分支到远程仓库aa分支 git push origin :aa //删除远程仓库aa分支 git branch -d aa //删除本地aa分支 .gitigonre 忽略文件 node_modules //忽略node_modules 文件夹 /dist //忽略dist 文件夹 "},"WXgroup/":{"url":"WXgroup/","title":"微信公众号","keywords":"","body":"微信公众号 "},"WXgroup/微信公众号.html":{"url":"WXgroup/微信公众号.html","title":"微信公众号","keywords":"","body":"微信公众号 "},"webpack/":{"url":"webpack/","title":"webpack","keywords":"","body":"webpack "},"server/":{"url":"server/","title":"server","keywords":"","body":"server "},"server/ngin.html":{"url":"server/ngin.html","title":"ngin","keywords":"","body":"nginx nginx服务器 nginx-服务器文件夹目录中不能有中文目录 dist 打包文件夹 放入nginx服务器 文件夹目录中 每次改完文件，都需要重新加载 需要在 阿里云 加入安全组 添加80端口 命令行 .\\nginx.exe -c conf\\kerwin.conf //加载kerwin.conf 并启动服务器 .\\nginx.exe -s stop //关闭nginx服务器 .\\nginx.exe -s reload //重新加载 conf/kerwin.conf 文件夹 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream kerwin-server { server localhost:3001 weight=1; server localhost:3002 weight=1; } server { listen 80; //访问域名 server_name localhost; //访问协议 location / { root dist; //加载的文件夹名 index index.html index.htm; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location /ajax/ { //反向代理配置 proxy_pass https://m.maoyan.com; } } } "},"Ts/":{"url":"Ts/","title":"typeSctipt","keywords":"","body":"typeSctipt "},"Ts/基础篇.html":{"url":"Ts/基础篇.html","title":"基础篇","keywords":"","body":"基础篇 命令行 tsc xxx //执行ts文件，编译成js文件 tsc --init //生成ts配置文件 tsc --watch //ts自动编译成js文件 tsc --noEmitOnError --watch //当ts文件有错误时，不自动编译 tsconfig.json \"target\":\"es5\" //降级编译 编译后的js文件符合es5标准 \"strict\": true //打开严格模式 这个包括下面两个功能 \"noImplicitAny\": true //类型隐患检查 \"strictNullChecks\": true //严格的Null检查 \"rootDir\":\"./src\" //根目录 \"outDir\":\"./dist\" //输出目录 一、类型 类型一般大写字母开头 基本类型 string //字符串 number //数字 boolean //布尔 null //不存在 undefined //未初始化的值 //数组 type[] //arr:number[] 数字类型数组 Array //Array 数字类型数组 //任何 any //obj: any = {} 任何值都可以赋值 其他类型 never //不应该存在的状态 当函数异常\\中止\\死循环就是never void // 没有返回值函数的返回值 object // 任何的不是基本类型的值 object !== Object\\ unknown //代表任何的值，但是不能进行任何访问 function //描述所有函数值的属性，它的返回值总是any 原语 bigint //非常大的整数 let a:bigint = 100n symbol //全局唯一引用 let a = Symbol(1) let b = Symbol(1) a == b //答案为false,因为symbol具有全局唯一性 二、类型注释 如果未注释类型，则会根据首次赋值来自动注释类型 匿名函数自动根据传入的值自动注释 //参数注释 let person: number = 1 //冒号+类型 //函数注释 function gteer(name: string) {} //: string 表示形参类型注释 function gteer(): string {} //string表示返回值类型注释(void表示没有返回值) () => string //箭头函数返回值类型 //对象注释 function gteer(pt:{x:number, y?:number}) //问好表示可不传y值 //联合类型 let id: number | string 类型别名 //使用type定义类型 type Point = { x:number,y:number } function getData(pt:Point) { } type ID = number | string function getData(id:ID) {} //扩展类型别名 type Bear = Point & { z:number } //通过&扩展 也可以扩展接口 接口 //使用interface定义类型 interface Point { x:number y:number } const point:Point = {x:1,y:2} //扩展接口 interface Bear extends Point1，Point2 { //此处扩展可以合并多个其他接口 z:number } const bear:Bear = {x:1,y:2,z:3} //添加新字段 interface Point { a:numbe } //重复定义，就可以新增加字段 泛型类型 interface Box{ contents: Type } let box: Box = { contents:\"hello\" } 类型断言 cosnt myCanvas = document.getElementById(\"canvas\") as HTMLCancasElement cosnt myCanvas = document.getElementById(\"canvas\") //string不能直接断言成number,需要有覆盖关系 const x = ('hello' as unknown) as number //unknown 未知的 //固定类型 let x = {} as const x! //断言x不是null或者undefined 文字类型 //字符串文字类型 let x: 'true'|'false' = \"true\" //数字文字类型 let x:-1 | 1 | 0 = 0 //布尔文字类型 let x: true | false = true 枚举 enum direction { a = 1, b, c, d } console.log(direction.a，direction.b) //1 2 3 4 会在每个后面依次加1 三、类型缩小 typeof 类型守卫 object \\ string \\ number \\ bigint \\ boolean \\ symbol \\undefined \\ function if(typeof strs === \"object\") {} 真值缩小 条件、&&、||、if语句、！ 通过对上方的使用，过滤null和undefined 等值缩小 ===, !===, ==, != function example (x:string | number,y:string | boolean){ if(x === y){} //当两者都是string时执行里面内容 } let a: number | null | undefined if( a != null ){ } //当a等于null或undefined时，都不会执行里面内容 in 操作符缩小 type a1 = { a: ()=> void } type b1 = { b: ()=> void } type c1 = { a?: ()=> void; b?: ()=> void } function test( value: a1 | b1 | c1 ){ if( 'a' in a1 ){ //a1对象中是否有a属性 return (a as a1 ).a() //因为c1也有a属性，所以加个 as a1 缩小范围 } } instanceof 操作符缩小 x instanceof Foo //检查Foo是否是X的实例 if( x instanceof Date ){] //是否是Date上的实例 分配缩小 let x = Math.randow() 类型谓词 type Fish = { name:string swim: ()=> void } type Bird = { name: string fly: ()=> void } function isFish(pet: Fish | Bird):pet is Fish { return (pet as Fish).swim !== undefined } 联合类型 unions interface a { name:\"a\" radius:number } interface b{ name:\"b\" leftLength:number } type c = a | b //联合类型 function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength } } 穷进性检查 type c = a | b function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength default: //never 任何类型都不能分配给never let d: never = shape //never 不应该存在的状态 可以分配给任何类型 return d } } 四、函数类型 函数类型表达式 //fn : (a: string) => void type fnType = (a: string) => void function greeter(fn : fnType) { fn(\"hello\") } function prinTo(s:string){ console.log(s) } greeter(prinTo) //结果为 \"hello\" 调用签名 创建一个除了函数类型外还有其他类型的对象 也可以使用 interface 创建 type funType = { a: string (b: number) : booleam //参数列表和返回类型之间是：而不是=> } function getData(fn:funType){ cosnole.log(fn.a + fn(6)) } function fn1(n:number){ return true } fn1.a = 'hello' getData(fn1) //结果 hello true 构造签名 class ctor { s: string newfun(s: string) { this.s = s } } type funType = { new (a: string) : ctor //这里返回类或者构造函数 也可填写其他返回值类型 } function fn(ctor: funType){ return new ctor('hello') } const f = fn(ctor) console.log(f.s) //结果 hello 泛型函数 类型推断 数组元素是什么类型，Type就是什么类型 保持输入和输出类型一致 Type 名可以随意取 function getData(arr: Type[]): Type | undefined { return arr[0] } getData(['a','b']) //返回值类型string 一般不写 TS会自行推断 getData([1,2]) //返回值类型number getData([]) //返回值类型undefined function getArray(arr: Input[], func: (arg: Input) => Output): Output[] { return arr.map(func) //map直接放函数是map的语法 } const parsed = getArray(['1','2','3'],(n) => parseInt(n)) 限制条件 // 传入a或b的参数，必须要有length这个属性 function longest( a: Type, b: Type ){ return a.length + b.length } const logestAttay = longest([1,2],[3,4]) const logestString = longest('11','22') 使用受限值 function getData( obj:Type, num: number ):Type { if(obj.length>num){ return obj }else{ // 当返回值不是Type时，可以在前面加一个泛型就好了 return { length: num } } } const arr = getData([1,2,3],6) 指定类型参数 function getData(arr1: Type[], arr2: Type[]): Type[] { return {...arr1,...arr2} } // 这儿强制分别规定泛型类型 const att = getData([1,2,3],['string']) 约束准则 1、尽可能使用类型参数本身，而不是对其约束 function getData(arr: Type[]){ return arr[0] } //correct function getData(arr Type){ return arr[0] } //error 2、尽可能少的使用类型参数 function getData(arr:Type[], func:(arg:Type)=> boolean){} //correct function getData( //error arr: type[], func: func ) 3、一个类型参数只出现在一个地方时，若非必要则尽量不写 function gerData(s:string){} //correct function getData(s :str){} //error 4、当函数里传递回调函数时，永远不要写一个可选参数 函数重载 基本语法 多人合作时，重载签名相当于是定义好了的函数，实现签名就是我们将重载签名拿来使用 尽可能使用联合类型的参数，而不是重载参数 ts可以把this当作参数名（注意不能使用箭头函数） //重载签名 function makeDte(timestamp: number): Date function makeDte(m: number, d:number , y:number): Date //实现签名 function makeDte(mOrtTimestamp: number, d?: number, y?:number): Date { if(d !== undefined && y !== undefined){ return new Date(y, mOrtTimestamp,d) }else{ return new Date(mOrtTimestamp) } } 函数形参展开 function getData(...a: number[]){ return a[0] } getData(1,2,3,4) 参数解构 type abc = {a: number, b: number, c: number} function sum({a, b, c}: abc){ console.log(a + b + c) } sum({a: 10, b: 3, c: 32}) 五、对象类型 只读属性（readonly） interface someType{ readonly prop: string //readonly 写了后，属性就变成了只读 readonly list: { //内部的属性可以修改，list不能修改 name: 'a' } } 索引签名 interface stringArray { //string 表示index必须是string number 是表示数组，可以使用数子得到对应的参数 [idnex: number]: string //index相当于数组索引的意思 } cosnt myArray:stringArray = ['a','b'] cosnt item = myArray[0] interface TextString { // string 是表示props必须是string，可以使用属性得到对应的属性值 [props: string]: number } cosnt textString: TextString = { x:100, y:200 } cosnt item = textString['x'] 六、从类型中创建类型 泛型 基本语法 function getData(arg: Type): Type { } let data = getData(\"hello\") //定义了泛型类型 let data = getData(\"hello\") //自动推断类型为string 泛型接口 interface a{ (arg: Type): Type } function c(arg:Type):Type{ return arg } let b:a = c 泛型类 calss a{ b: numType add:(x：numType) => numType } let mya = new a() //此处的number就是给泛型类属性加类型 约束中使用类型参数 // Key extends keyof Type 意思是 key是包含在type中 function getData(obj: Type, key: Key) { return obj[key] } let x = { a:1, b:2, c:3 } getData(x,'a') //主要是a,b,c就没有问题 泛型中使用类类型 function create(c: { new (): Type }): Type { retuQ YHGB VNrn new c() } keyof 类型操作符 将类型对象属性解析成属性联合类型 type point = { x:number, y:number } type P = keyof point //等同于 'x' | 'y' const p1:P = 'x' const p2:P = 'y' type map = { [k: string]: boolean } //因为js[]语法底层会把number转换成string，所以m的类型是number | string type M = keyof map const myArray = [ { name:'a', age:11 }, { name:'b', age:12 }, ] // Person类型 {name: string,age:number} type Person = typeof myArray[number] //number代表是任何一个数组下标，占位符 typeof 类型操作符 解析属性属于什么类型 是对象则返回对象的返回值类型 let s = \"hello\" let n: typeof s //此时n的类型就是s的类型 string //ReturnType 获取函数返回值类型 ts内置函数 type Predicate = (x: unkown)=> boolean type K = ReturnType 索引访问类型 type List = { a: number; b:string; c:boolean } type A = List['a' | 'b'] 条件类型 举例 interface a { live():void } interface b extends a { woof():void } type c = b extends a ? number : string //a被b约束，语法类似三元表达式 约束 //T 是否存在 {message: unknown } type MessageOf = T extends {message: unknown } ? T['message'] : never interface a { message: string } type b = MessageOf //结果为string 条件类型内推理 infer 定义泛型变量 获取返回值类型 七、类 类属性 class point { //class 关键词定义类 a: number constructor(){ //当point实例化时，会执行此函数，进行数据初始化 this.a = 0 //this默认指向类的实例 } } const p = new point() //()表示实例化类 readonly 修饰符 防止在构造函数之外进行赋值 class point { readonly name:string = 'hello' constructor(enterNmae?: string){ //只能在constructor中修改只读属性 if(enterNmae !== undefined){ this.name = enterNmae } } } const g = new point('通过传值进行更改') console.log(g) 构造器 -- constructor 构造函数不能有类型参数 构造函数不能有返回类型注释 class point { //class 关键词定义类 a: number; b: number; //有默认值可以不写类型，会自动推断。 //不写默认值实例化不传值是会报错 constructor(x:number = 0 , y:number = 0){ this.a = x this.b = y } } const p = new point(1,2) //类继承必须使用super函数 class base { k = 4 } class point extends base { constructor(){ super() } } 类的方法 class point { a: number = 10 b: number = 11 scale(n: number): void { //和外部函数使用没区别 this.a *= n this.b *= n } } const p = new point() p.scale(10) console.log(p.a,p.b) Getters/Serters 存取器 如果只存在get，没有set，则该属性自动是只读的 如果没有指定setter参数的类型，则从getter的返回类型推断出来 访问器和设置器必须是相同的成员可见性 class C { _length = 0 get length(){ return this._length } set length(value) { this._length = value } } let c: C = new C() let a = c.length //会执行类里get关键字的函数 c.length = 100 //会执行类里set关键字的函数 索引签名 class myClass { [s: string]: boolean | ((s: string) => boolean) x = true check(s: string) { return this[s] as boolean } } 类继承 - implements 子句 一个类去继承或者实现一个接口 实现父级类的公共内容 父级类不会改变类的类型，子级类可以进行兼容 父类可选属性，继承的子类可以选择不实现 interface A { x: number y: number } class B implements A { //除了A中的可选属性，其他属性必须写上 x = 0 y = 0 } 类继承 - extends 子句 一个类继承另外一个类 继承的类具备父类所有的属性和方法，并且还可以定义自己的一些属性和方法 class A { x:number = 1 } class B extends A { y:number = 2 } 类重写 覆盖类的时候，类型需要兼容 class base { greet() { console.log(\"hello\") } } class Derived extends base { greet(name?: string) { //直接覆盖父类greet方法 if (name === undefined) { super.greet() //super 指向父类的方法 this指向属性 } else { console.log(name) } } } const d = new Derived() d.greet() d.greet(\"子类的方法\") 初始化顺序 父类: 基类 子类：派生类 1、基类的字段被初始化 2、基类构造函数运行 3、派生类的字段被初始化 4、派生类构造函数运行 class Base { name = 'base' constructor() { console.log(this.name) } } class Derived extends Base { name = 'derived' } const d = new Derived() 继承内置类型 class MsgError extends Error {} //Error 内置类型 成员的可见性 -- public 公开的，默认值。任何对象在任何地方都可以访问 class Base { public name = 'base' //public 默认值，可不写 } const d = new Base() d.name 成员的可见性 -- protected protected 受保护的。只能在当前类和子类中进行访问 派生类可以暴露基类受保护的成员 二次赋值即可 class Base { protected base() { return 'base' } } class Derived extends Base { title = super.base() test() { console.log(super.base()) } } const d = new Derived() d.test() 成员的可见性 -- private 私有的。只能在当前类中进行访问 class Base { private x = 1 base() { console.log(this.x) } } const d = new Base() d.base() TypeSctipr 允许跨实例的私有访问 class A { private x = 10 public sameAs(other: A) { //通过函数暴露私有化变量 return other.x } } const a = new A() console.log(a.sameAs(a)) 静态成员 -- static 静态名称避免使用：name,length,call等特殊名字 TypeScript 没有静态类的概念，因为有函数和普通对象 修饰符可以连着使用，这儿也可以加上成员可见性 基类可以被派生类继承 class myClass { static x = 0; static printX() { myClass.x //可以直接获取 } } const a = myClass.x 类里的static区块 把静态成员私有化，类私有域 class myClass { static #x = 0; //加了#号就只能在类内部使用 static printX() { return myClass.#x } static { //静态区块，默认会执行 console.log(\"hell\") } } 泛型类 静态成员不能使用泛型 class Box{ contents: Type constructor(value: Type) { this.contents = value } } const a = new Box(`1111`) const b: Box = new Box(`1111`) const c = new Box(`1111`) 类运行时的this class MyClass { name: 'MyClass' //原代码 getName() { //这样写，下面obj里c.getNam调用时this指向会边 return this.name } //解决方法1 //利用箭头函数，固定this指向 //会浪费更多的内存，不能在派生类中调用这个函数 getName = ()=>{ return this.name } //解决方法2 //this: MyClass 作用是告诉这个函数this指向地方，提前报错 getName(this: MyClass) { return this.name } } const c = new MyClass() const obj = { name: 'obj', getName: c.getName } console.log(obj.getName()) this 类型 class Box { content: string = '' sameAS(other: this) { //通过传入的值来固定this的指向 return other.content === this.content } } class DerivedBox extends Box { otherContent: string = '?' } const bsse = new Box() const derived = new DerivedBox() derived.sameAS(derived) 基于类型守卫的this ？ 类和方法返回值的位置使用 this is 类型 前面的是固定写法 class Box{ value?: T hasValue(): this is { value: T } { return this.value !== undefined } } const box = new Box() box.value = 'hello' if (box.hasValue()) { console.log(box.value) } 参数属性 class Box { //x加了public后，外部也可以访问了 constructor(public x: number) { this.x = x } } const p = new Box(100) p.x = 200 类表达式 const box = class { content: Type constructor(value: Type) { this.content = value } } const m = new box('hello') console.log(m.content) 抽象类和成员 -- abstract 不能被实例化，只能当作基类，派生类继承 abstract class Base { abstract getNmae(): string //抽象成员 不能被实现 printName() { console.log(this.getNmae) } } class Derived extends Base { getNmae() { return 'world' } } const b = new Derived() b.getNmae() b.printName() 类之间的关系 内部类型一样，可以相互兼容 class A { x = 0 y = 0 } class B { x = 0 y = 0 } const p: A = new B 类可以包含使用 class A { x = 0 y = 0 } class B { x = 0 y = 0 z = 0 } const p: A = new B //b当成了a的继承类 一个空的类可以传入任何参数 class A {} function fn(x:A){ } fn(window) //这儿传入什么，A就会有什么参数 八、模块 模块在自己的范围内执行 ES模块语法 export default function A() { //导出模块 return 'hello' } import hell from './hell' // 引入模块， 一般不写后缀，ts后缀不能写 heel() export let a = 1 export let b = 1 import {a,b} from './hell' console.log(a,b) 额外的导入语法 export let a = 1 export default class B {} //默认的导出 //B1 是类B的别名，as 启用别名 import B1, {a as a1} from './hell' // * 导入所有的东西 import * as math from './hell' // default() 导出默认的导出 const C = new math.default() TS特定的ES模块语法 export type dataType = { a: string b: number c: boolean } export interface dataInterface { a: string b: number c: boolean } import type { dataType,dataInterface } from './hell' export let a = 1 import { a, type dataType, type dataInterface } from './hell' commonJs语法 function getData(): void { } let a = 1 module.exports = { //导出 a, getData } exports.getData = getData //导出 cosnt data = require('./test')//导入 "}}