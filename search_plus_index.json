{"./":{"url":"./","title":"前言","keywords":"","body":"Summary 前言 工作随笔 工作随笔 功能技巧 Vscode 调试技巧 三剑客 基础 javaScript ES6 Promise RegExp Sass/Less Flex Grid 性能优化 规范 进阶 数据结构及算法 排序算法 堆与栈 typeScript 基础篇 tsconfig ts 补充 vue vue2 vue3 uniApp vuex pinia vue 补充 Dome 瀑布流 SSR websocket storage 封装 web 分页搜索存储 虚拟列表 二维码显示 canvas 图片导出 表格导出 css-日夜按钮 request URLScheme React React18 微信 微信公众号 小程序 Flutter Dart Flutter 打包工具 vite webpack 工具导航 在线小工具 插件工具官网 工具语法 git mock Markdown Moment 设计原则 类之间的关系 设计原则 设计模式 网络 TCP/IP 协议族 DNS TCP IP HTTP HTTP web 缓存 前端安全 数据加密 服务器端 node node-基础 包管理器 代理 ngin "},"工作随笔/工作随笔.html":{"url":"工作随笔/工作随笔.html","title":"工作随笔","keywords":"","body":" 开发注意 iOS&Safari 不兼容 正则表达式的断言匹配 注意代码执行异步和同步 改完一定要测试 梳理业务逻辑再动代码 遵守开闭原则 vue2+Ts @Watch('message',{ immediate:true, // immediate表示在watch中首次绑定的时候，是否执行handler， // 值为true则表示在watch中声明的时候，就立即执行handler方法， // 值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。 }) 不确定类型 , 应该使用unknown 当属性可选时，应该用类继承的方式去书写 CSS随笔 position: sticky; //粘性布局 background: linear-gradient(180deg, #f2f2f2, #ffffff); //背景渐变 width:calc(100% - 100px) //单位换算计算 visibility:hidden; 隐藏元素（位置保留） :src=\"require('./1.jpg')\" uniapp 使用本地路径加require background: url(\"~@/assets/xxx.jpg\") //uniapp ~符号作为前缀的路径视作依赖模块而去解析 border-bottom: 50px solid transparent; //transparent 透明 user-select //用户选择文本 node:禁止 all:选中所有 filter: grayscale(.95); //让网站变灰 word-break: break-all; //英文强制换行 width: max(50%, 300px); //宽度设置为最大的值，取 50% 或 300px 的最大值 width: min(50%, 300px); //宽度设置为最小的值，取 50% 或 300px 的最小值 clamp(1rem, 2vmin, 3rem) //(最小值，首选值，最大值) :class=\"{ red: isRed } fixed //两个fixed嵌套，可都设置zIndex消除影响 #### 伪类 | 伪元素 ```css :empty //当节点为空时，执行此样式 :focus-within //元素获得焦点，或该元素的后代元素获得焦点，就会匹配 ::placeholder //修改placeholder的样式 ::selection //自定义选中样式 有限制样式 鼠标事件穿透当前层 pointer-events:none //鼠标事件穿透当前层 | 禁止鼠标事件 pointer-events:auto //鼠标不会穿透当前层 字体渐变色 background-image: linear-gradient(right, #7a492f, #cb7e3c); // 为元素提供渐变色背景 background-clip: text; // 用文本剪辑背景 -webkit-text-fill-color: transparent; //使用透明颜色填充文本 撑满子元素高度 overflow: hidden ; //父元素 margin-bottom:-200px;padding--bottom:200px //子元素 让每个元素之间隔开px display: flex | grid； gap: 20px; 注意 在flex子元素中设置不同方向的，子元素就可偏移 当在定位中同时设置lert和right时，就隐式的设置的宽度 如果按钮为图片，应设置为背景图，个别浏览器点击img图片会将图片放大 JavaScript随笔 location.reload(); //刷新页面 window.location //获取网址信息 Object.values(a) // 枚举a对象所有的属性值 arr.flat(Infinity) // 扁平化数组,Infinity默认深度最深，也可指定深度 [a,b] = [b,a] //使用解构，快速交互ab值 window.location.href=url //(动态输出跳转) 跳转链接 click.once //方法只执行一次 array.at(-1 ) //数组负索引（-1为最后一位）微信内部不支持此语法 let b = a !== 0 ? ( a ? a: \"-\") : 0 //括号可省略 &nbsp; //空格 /n; //换行 navigator.userAgent.toLowerCase() //返回当前用户所使用的是什么浏览器 try {} catch (error) {} finally {} //错误反馈 Navigator //浏览器的相关信息的对象 const data = { [key]:value } //属性名变量传入 eval() //字符串改成表达式 data.payFrom = array.join() //get请求传数组 Promise.all //多接口刷新推荐使用all window.open //跳转外部 无刷更新url export const replaceUrl = (hash: string) => { history.replaceState( { back: history.state.back, current: hash }, \"\", `${location.search}#${hash}` ); } replaceUrl('/order/1/list') 知识 $attrs // 封装第三方库文件 使用attrs数据会及时响应 扩展运算符 let aobj = {a:1,b:2} let bobj = {a:3,b:4,c:5} aobj = {...aobj,...bobj} //{a:3,b:4,c:5} 循环判断 while (判断条件){ 执行代码 } //先判断，后执行; do{ 执行代码 }while( 判断条件 ) //先执行，后判断 查找数组最大最小值 let data = [1,20,20,33,55,33,66,77] let maxNum = Math.max(...data); let minNum = Math.min(...data); 功能技巧 工具 vue-clipboard2 //剪切板 @chenfengyuan/vue-qrcode //生成二维码 vue3 vue2可用 mobile-detect //获取手机设备信息 moment //日期处理类库 vConsole //手机端测试打开控制台 vue-class-component && vue-property-decorator //class风格开发组件 image-conversion //图片压缩 qs库 //编码 AbortController //控制器对象，允许你根据需要中止一个或多个 Web 请求 postcss-px-to-viewport //px转换vw 命令 npm cache clear --force //清楚缓存 pwd //打开当前目录的绝对路径 阻止用户截图 1.阻止右键保存和拖拽 2.失焦后加遮罩层 3.高速动态马赛克 注意 微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 直播组件：直播拉流(live-player) + 直播推流(live-pusher) uni.setNavigationBarTitle 更改头部标题 webpack对于小于8k的图片，会将图片转成base64 直接插入图片 items.push(...newItems) 会有爆栈风险 router-view加个唯一的key，来保证路由切换时都会重新渲染触发钩子 "},"工作随笔/功能技巧.html":{"url":"工作随笔/功能技巧.html","title":"功能技巧","keywords":"","body":"功能技巧 CSS_demo 动画 .img_rotate { animation: changeright 50s linear infinite; } @keyframes changeright { 0% { -webkit-transform: rotate(0deg); } 50% { -webkit-transform: rotate(180deg); } 100% { -webkit-transform: rotate(360deg); } } css 类绑定 css变量 :root{ //web是:root 小程序是page --size:100 } div{ //var 读取 calc 计算 width:calc(var(--size)*2px) } @padding-md:15px padding:@padding-md 苹果底部边距 padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); 文本溢出 //单行 overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 white-space: nowrap; // 规定段落中的文本不进行换行 //多行 overflow: hidden; // 溢出隐藏 text-overflow: ellipsis; // 溢出用省略号显示 display: -webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列 -webkit-line-clamp: 2; // 显示的行数 JS_demo 单行代码 //数组去重 const uniqueArr = (arr) => [...new Set(arr)]; //从url获取参数并转为对象 const getParameters = URL => JSON.parse(`{\"${decodeURI(URL.split(\"?\")[1]).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"')}\"}`) //检查对象是否为空 const isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object; //反转字符串 const reverse = str => str.split('').reverse().join(''); //生成随机十六进制颜色 const randomHexColor = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \"0\")}` //检查当前选项卡是否在后台 const isTabActive = () => !document.hidden; //两日期之间相差的天数 const dayDiff = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000); //将 RGB 转换为十六进制 const rgbToHex = (r, g, b) => \"#\" + ((1 复制内容到剪贴板 /** * 复制内容到剪贴板 * @param value */ export const copyToClipboard = (value: string) => { const oInput = document.createElement('input'); oInput.value = value; document.body.appendChild(oInput); oInput.select(); // 选择对象 // 执行浏览器复制命令 if (document.execCommand('Copy')) { oInput.className = 'oInput'; oInput.style.display = 'none'; return showToast(\"复制成功\"); } return showToast(\"复制失败\"); } 监听手机返回 created() { if (window.history && window.history.pushState) { history.pushState(null, \"\", document.URL); window.addEventListener(\"popstate\", this.goBack, false); } this.init(); } destroyed() { window.removeEventListener(\"popstate\", this.goBack, false); } goBack() { (this).$router.go(this.backspace); } app返回退出软件问题 document.addEventListener('plusready', function () { var webview = plus.webview.currentWebview(); plus.key.addEventListener('backbutton', function () { webview.canBack(function (e) { if (e.canBack) { webview.back(); } else { //webview.close(); //hide,quit //plus.runtime.quit(); //首页返回键处理 //处理逻辑：1秒内，连续两次按返回键，则退出应用； var first = null; plus.key.addEventListener('backbutton', function () { //首次按键，提示‘再按一次退出应用’ if (!first) { first = new Date().getTime(); console.log('再按一次退出应用'); setTimeout(function () { first = null; }, 1000); } else { if (new Date().getTime() - first 防抖动 debounce (wait, fun,data) { if (this.timer) { clearInterval(this.timer) } this.timer = setTimeout(() => { fun(data) }, wait) }, //vue3+ts let timer = ref(0); const debounce = (wait: number, fun: any, data?: any) => { if (timer) { clearInterval(timer); } timer = setTimeout(() => { fun(data); }, wait); }; 节流 //vue2 throttling (wait, fun) { let _this = this let now = +new Date() if (!this.last || (now - this.last) > wait) { _this.last = now fun() } }, //vue3+ts let last = ref(0); const throttling = (wait: number, fun: any) => { let now: any = +new Date(); if (!last.value || now - last.value > wait) { last.value = now; fun(); } }; uniapp 刷新页面 // 获取当前页面栈实例 const pages = getCurrentPages() // 获取当前页面 const curPage = pages[pages.length - 1] // 声明一个当前页面 curPage.onLoad(curPage.options) // 传入参数 浏览器关闭提醒 window.onbeforeunload = function (e) { e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) { e.returnValue = '关闭提示'; } // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示'; }; 存储监听 const setItem = localStorage.setItem localStorage.setItem = function (name, value) { setItem.apply(this, arguments) //更改setItem的this指向，arguments传入的参数数组（name,value） var event = new Event('setItem') //构造函数 event.key = name event.value = value window.dispatchEvent(event); //发送事件到监听器上 } // 页面使用 window.addEventListener('setItem', function (e) {//注册监听setItem事件 document.querySelector('.view').innerText = `${e.key}： ${e.value}` }) 时间格式 Vue.filter('formatDate1', function (value, fmt) { let getDate = new Date(value); let o = { 'M+': getDate.getMonth() + 1, //月份 'd+': getDate.getDate(),//日 'h+': getDate.getHours(),//小时 'm+': getDate.getMinutes(),//分钟 's+': getDate.getSeconds(),//秒数 'q+': Math.floor((getDate.getMonth() + 3) / 3),//季度 'S': getDate.getMilliseconds()//毫秒 }; if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (getDate.getFullYear() + '').substr(4 - RegExp.$1.length)) } for (let k in o) { if (new RegExp('(' + k + ')').test(fmt)) { fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length))) } } return fmt; }) 数组处理 //并集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var union = new Set([...a, ...b]); // {1, 2, 3, 4} //交集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3} //差集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var difference =new Set([...[...a].filter(x => !b.has(x)),...[...b].filter(x => !a.has(x))]); // {1,4} 正则替换 const setGitCode = ( row: any, column: ColumnProps, cellValue: any, index: number ) => { var str: any = /(? 规则 initialValue: 0, rules:[ { required: true, message: '请输入密码' }, { pattern:/\\d{6}/, message: '请输入6位数字密码'}, { validator: (val: string) => return boolean, message: '两次密码输入不一致' }], 屏蔽F12、Ctrl+U、Ctrl+Shift+I、右击 const banF12 = () => { window.onkeydown = window.onkeyup = window.onkeypress = function (e) { if ( // F12 e.keyCode === 123 || // Ctrl+Shift+I (e.ctrlKey && e.shiftKey && e.keyCode == 73) || // Shift+F10 (e.shiftKey && e.keyCode == 121) || // Ctrl+U (e.ctrlKey && e.keyCode == 85) ) { e.preventDefault(); // 阻止默认事件行为 (window as any).event.returnValue = false; } }; // 为右键添加自定义事件，可以禁用 window.oncontextmenu = function (event) { event.preventDefault(); // 阻止默认事件行为 return false; }; }; "},"工作随笔/Vscode.html":{"url":"工作随笔/Vscode.html","title":"Vscode","keywords":"","body":"Vscode 主题 主题名 Monokia 通用插件 Path Intellisense 路径提示插件 open in browser 浏览器中打开html文件 Code Spell Checker 单词拼写检查 Path Autocomplete 路径提示的插件 Prettier - Code formatter 自动格式化 Sass/Less/Stylus/Pug/Jade/Typescript/Javascript Compile Hero Pro 识别出代码的关键词并进行关键词美化 Auto Close Tag 补齐标签 Auto Rename Tag 同步修改标签 Blue Light Theme 括号颜色高亮 AutoScssStruct4Vue 根据template的标签目录自动一键生成CSS/SCSS/LESS结构 CSS Peek 快速找到css定义 koroFileHeader 头部注释插件 Path Autocomplete 路径检查提醒 特色插件 Vuter vue2 代码提示 vue-helper vue 代码提示 TypeScript Vue Plugin (Volar) vue3 ts 代码提示 Vue Language Features (Volar) vue3 代码提示 "},"工作随笔/test.html":{"url":"工作随笔/test.html","title":"调试技巧","keywords":"","body":"调试技巧 console dir() JSON对象形式输出 debug()、info()、warn()、error() 颜色图片不同 table() 表格的形式输出 count() 会显示执行的次数 二次发起请求 对接口请求右键 选择Relpy xhr发送请求 接口请求参数修改 对接口请求右键 选择copy 再选择copy as fetch 在console区域粘贴上面的请求信息，然后修改请求体参数 然后切换到networkl查看最新请求的结果 控制台输出选择的dom 在页面选择指定的位置dom 在控制台使用$0就表示当前选中的dom "},"三剑客/基础/javaScript.html":{"url":"三剑客/基础/javaScript.html","title":"javaScript","keywords":"","body":"js 补充 文章地址 尾调用优化 当函数调用时,会在内存中形成调用记录, 又称\"调用帧\"（call frame） 当在文章末尾调用函数时，可以使用 return,来删除外层函数的调用记录，只保留内层函数的调用记录 function f() { let m = 1; let n = 2; return g(m + n); } 尾递归 因为仅有 1 个调用记录 ，所以不会存在内存溢出问题 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5); // 120 while 循环 只要指定条件为 true，循环就可以一直执行代码块 while (条件){ 需要执行的代码 } Object.is 和 ===的区别 object.is 可以区别-0和+0 object.is NaN等于另一个NaN值 Object.assign 和 扩展运算符... 的区别 Object.assign 会直接改变原数据的值 扩展运算符只能通过赋值都方式改变数据的值 路由返回 //原页面表单中的内容会丢失 window.history.go(-1)：//后退+刷新； window.history.go(1)：//前进； //原页面表单中的内容会保留 window.history.back()：//后退 window.history.back(0)：//刷新 window.history.back(1)：//前进 //关闭当前页面 window.close() window.history.pushState(data, title, targetURL) window.history.replaceState(data, title, targetURL); @状态对象：传给目标路由的信息,可为空 @页面标题：目前所有浏览器都不支持,填空字符串即可 @可选url：目标url，不会检查url是否存在，且不能跨域。如不传该项,即给当前url添加data "},"三剑客/基础/ES6.html":{"url":"三剑客/基础/ES6.html","title":"ES6","keywords":"","body":"ES6 新增方法(es7-es14) for...of 字符串可以循环遍历 for (let item of 'randy') { console.log(item) // r a n d y } 操作符 cat?.name //可选链操作符 可以读取cat深处的值，不用担心是否有效 a ?? b //空值合并操作符 左侧为 null 或者 undefined 时，返回右侧数据 a ??= b //空值赋值运算符 左侧为 null 或者 undefined 时,右侧数据赋值给左侧 !. //非空断言操作符 ts内容 2**10 //幂运算 1024 1_000_000 // 使用数字分隔符 原意不变 a ||= b //或等于 a || (a = b) a ||= b //与等于 a && (a = b) class 私有属性和私有方法 属性/方法添加一个hashtag(#)前缀，这个属性/方法就变成私有的了 class Person { #firstName = 'randy'; #lastName = 'su'; #say() { console.log('say hello') } get name() { this.#say(); return `${this.#firstName} ${this.#lastName}`; } } toSorted sort方法的排序复制版本，区别就是sort是修改原数组，而toSorted是返回新数组 const arr = [1, 3, 5, 2, 8]; const newArr = arr.toSorted(); 解构 数组解构 //级别 let [a, b, c] = [1, 2, 3]; //嵌套 let [a, [[b], c]] = [1, [[2], 3]]; //可忽略 let [a, , b] = [1, 2, 3]; //不完全解构 let [a = 1, b] = []; //剩余运算符 let [a, ...b] = [1, 2, 3];//b=[2, 3] //字符串等 let [a, b, c, d, e] = 'hello'; //解构默认值 let [a = 2] = [undefined]; // a = 2 对象解构 基本 let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; //别名 let { baz : foo } = { baz : 'ddd' };// foo = 'ddd' 嵌套 let {p: [x, { y }] } = {p: ['hello', {y: 'world'}] }; // x = 'hello' // y = 'world' 忽略 let {p: [x, { }] } = {p: ['hello', {y: 'world'}] }; // x = 'hello' 不完全解构 let {p: [{ y }, x ] } = {p: [{y: 'world'}] }; // x = undefined // y = 'world' 剩余运算符 let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; // a = 10 // b = 20 // rest = {c: 30, d: 40} 解构默认值 let {a = 10, b = 5} = {a: 3}; // a = 3; b = 5; //别名 + 默认值 let {a: aa = 10, b: bb = 5} = {a: 3}; // aa = 3; bb = 5; 新类型 Symbol 没有两个 Symbols 永远相等 对象键可以是 Symbols Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问 类似永不重合的字符串 定义 //普通定义 let hd1 = Symbol(\"描述\") let hd2 = Symbol(\"描述\") hd1 === hd2 //false hd1.description //提取hd1描述 //for定义 -- 全局保存 let hd1 = Symbol.for(\"描述\") let hd2 = Symbol.for(\"描述\") hd1 === hd2 //true Symbol.keyFor(hd1) //获取hd1的描述 Map 与 Set Map 对象 任何值(对象或者原始值) 都可以作为一个键或一个值 方法 cosnt map = new Map() //创建 map.set(key,value) //设置该键的值 map.get(key) //获取该键的值 map.size //获取map的成员数量 map.clear() //清除所有成员 遍历 var myMap = new Map(); myMap.set(0, \"zero\"); myMap.set(1, \"one\"); //for for (var [key, value] of myMap) { console.log(key + \" = \" + value); } //forEach myMap.forEach(function(value, key) { console.log(key + \" = \" + value); }) 对象操作 //数组转换 var kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]]; var myMap = new Map(kvArray);//数组转换map var outArray = Array.from(myMap); //map转换数组 //克隆 var myMap1 = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]); var myMap2 = new Map(myMap1); let boolean = myMap1 === myMap2 //false //合并 var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]); var second = new Map([[1, 'uno'], [2, 'dos']]); var merged = new Map([...first, ...second]); Set 对象 Set 对象存储的值总是唯一的 +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复 undefined 与 undefined 是恒等的，所以不重复 NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。 对象之间引用不同，即使值相同，也能存储 方法 const set = new Set() set.add(val) //向 Set 中添加一个值 set.has(value) //判断 Set 中是否包含指定的值（布尔） set.delete(value) //删除 Set 中指定的值(成功删除该值返回 true) set.clear() //清空 Set 中的所有值 set.size //返回 Set 中的值的数量 set.forEach(callbackFn, thisArg) //当前值、当前值的键和 Set 对象本身 Array.from(set) //Set 对象转为 Array 作用 //去重 var mySet = new Set([1, 2, 3, 4, 4]); [...mySet]; // [1, 2, 3, 4]; //并集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var union = new Set([...a, ...b]); // {1, 2, 3, 4} //交集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3} //差集 var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var difference =new Set([...[...a].filter(x => !b.has(x)),...[...b].filter(x => !a.has(x))]); // {1,4} Reflect 与 Proxy Proxy 对目标对象的读取、函数调用等操作进行拦截 ，进行操作处理 由 target 和 handler 两个部分组成（将 target 对象操作拦截到 handler 中进行处理） let target = { name: 'Tom', age: 24 } //代理陷阱：对象的操作 let handler = { get( target, key ) { return target[key] }, set( target, key, value ) { target[key] = value } } let proxy = new Proxy(target, handler) proxy.name // 实际执行 handler.get proxy.age = 25 // 实际执行 handler.set Reflect Object 的一些明显属于语言内部的方法 get //查找并返回 target 对象的 name 属性 Reflect.get(target, name, receiver) //当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会指向 receiver //实际计算的值的receiver中的 Reflect.get(target, name, receiver) set //将 target 的 name 属性设置为 value Reflect.set(target, name, value, receiver) // 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 指向receiver //实际修改的是 receiver 的属性, //当receiver没有对应修改值时，则添加一个 Reflect.set(exam, 'info', 1, receiver); has //用于查找 name 属性在 obj 对象中是否存在。 Reflect.has(obj, name) let exam = { name: \"Tom\", age: 24 } Reflect.has(exam, 'name'); // true deleteProperty //用于删除 obj 对象的 property 属性，返回值为 boolean Reflect.deleteProperty(obj, property) let exam = { name: \"Tom\", age: 24 } Reflect.deleteProperty(exam , 'name') //{age: 24} getPrototypeOf //读取 obj 的 _proto_ 属性,obj 不是对象时会报错 Reflect.getPrototypeOf(obj) class Exam{} let obj = new Exam() Reflect.getPrototypeOf(obj) === Exam.prototype // true setPrototypeOf //设置目标对象的 prototype Reflect.setPrototypeOf(obj, newProto) let obj ={} Reflect.setPrototypeOf(obj, Array.prototype); // true apply //改变调用方法中的this指向 //func 表示目标函数 //thisArg 表示目标函数绑定的 this 对象 //rgs 表示目标函数调用时传入的参数列表 Reflect.apply(func, thisArg, args) Reflect.apply(Math.max, Math, [1, 3, 5, 3, 1]); // 5 defineProperty //为目标对象定义属性 Reflect.defineProperty(target, propertyKey, attributes) //value属性名是固定的 const student = {}; Reflect.defineProperty(student, \"name\", {value: \"Mike\"}); // true student.name; // \"Mike\" Generator 主要用于异步编程，交出了函数的执行权（可以自定义暂停） 在 function 后面，函数名之前有个 星号* 函数内部有 yield 表达式，可以定义不同的内部状态 本质上是一个异步任务的容器 function* func(){ yield '1';//定义不同的内部状态 yield '2'; return '3'; } let _func = func() //迭代器: 每个迭代器之间的作用域都是相互独立 //分阶段的执行Generator函数 _func.next() //{ value: ' 返回值 ' ，done: \" false \" } value: 返回值 ；done: 函数是否执行完毕 next() 带参数的会覆盖上一个yield语句的返回值 function* func(){ let n = 1 let v = yield n+11; console.log(v) //abc yield ++n; yield ++n; } let _func = func() console.log(_func.next()) //12 console.log(_func.next(\"abc\"))//2 console.log(_func.next())//3 for of 循环 let _func = func() for( let val of _func){ console.log(val) } return() 返回给定值，并结束遍历 Generator 函数 提供参数时，返回该参数；不提供参数时，返回 undefined function* foo(){ yield 1; yield 2; yield 3; } var f = foo(); f.return(\"foo\");//foo yield* 表达式 用于在 Generator 函数内部，调用另一个 Generator 函数 function* callee() { console.log('callee: ' + (yield)); } function* caller() { while (true) { yield* callee(); } } // 等同于 function* caller() { while (true) { for (var value of callee) { yield value; } } } const callerObj = caller(); callerObj.next(); // {value: undefined, done: false} callerObj.next(\"a\"); // callee: a // {value: undefined, done: false} callerObj.next(\"b\"); // callee: b // {value: undefined, done: false} Module export export const name = 'hello' export function say() { console.log('say') } export class Test { constructor() { this.id = 2 } } as 输入的变量重新取一个名字 import {name as cname} from 'xxx' export default const name = 'hello' let addr = 'BeiJing City' var list = [1, 2, 3] export { name as cname, addr as caddr } export default list //直接导入 import list, { cname as name, caddr } from A //批量导入 import list, * as mod from A console.log(list) console.log(mod.cname) console.log(mod.caddr) "},"三剑客/基础/Promise.html":{"url":"三剑客/基础/Promise.html","title":"Promise","keywords":"","body":"Promise iterable Array，Map，Set 都属于 ES6 的 iterable 类型 Promise.resolve() new Promise方法的语法糖 Promise.resolve(42) new Promise(function (resolve) { resolve(42) }) Promise.reject new Promise方法的语法糖 Promise.reject(new Error(\"Promise reject error\")) new Promise(function (reject) { reject(new Error(\"Promise reject error\")) }) Promise.then 函调函数异步执行 var promise = new Promise((resolve, reject) => {}) promise.then((res) => {}); Promise.catch promise.then(undefined, onRejected) 方法的一个别名 // 第一种写法 Promise.resolve() .then((data) => console.log(data)) .then(undefined, (err) => console.log(err)); // 第二种写法 Promise.resolve() .then((data) => console.log(data)) .catch((err) => console.log(err)); Promise.finally 回调函数不接受任何参数 异步完成后回调 p1.then((res) => console.log(res)) .catch((err) => console.log(err)) .finally(() => console.log(\"finally\")); Promise.all() 接收一个 promise 的 iterable 类型的输入 返回一个Promise实例 需要所有异步任务都同时进行并且完成时可以使用.all方法 任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 会立即抛出错误 var p1 = new Promise((resolve, reject) => {}); var p2 = new Promise((resolve, reject) => {}); var p3 = new Promise((resolve, reject) => {}); Promise.all([p1, p2, p3]).then(values => { console.log(values); }, reason => { console.log(reason) }); /*结果： resx: (3) [{…}, {…}, {…}] resy:{data: {…}, status: 200, statusText: \"OK\", headers: {…}, config: {…}, …} */ Promise.allSettled() 有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时 allSettled在其中一个promise返回错误时还可以继续等待结果 ,所有结果返回后安装传参传入的顺序返回结果 var p1 = new Promise((resolve, reject) => {}); var p2 = new Promise((resolve, reject) => {}); var p3 = new Promise((resolve, reject) => { reject('reject') }); Promise.allSettled([p1, p2, p3).then(values => { console.log(values); }, reason => { console.log(reason) }); //结果： //Promise {} //(5) [{…}, {…}, {…}, {…}, {…}] //0: {status: \"fulfilled\", value: \"one\"} //1: {status: \"fulfilled\", value: \"two\"} //2: {status: \"fulfilled\", value: \"three\"} //length: 5 //[[Prototype]]: Array(0) Promise.any() 某个Promise 变成rejected状态不会结束，必须等到所有参数 Promise 变成rejected状态才会结束 处理多个异步任务返回最快的成功的结果时可以使用 any var p1 = new Promise((resolve, reject) => {}); var p2 = new Promise((resolve, reject) => {}); var p3 = new Promise((resolve, reject) => { reject('reject') }); Promise.any([p1, p2, p3]).then(values => { console.log(values); }, reason => { console.log(reason) }); //结果： //Promise {} // one Promise.race() 遇到立即执行的reject时直接返回了reject的内容 处理多个异步任务但是不要求返回的内容是正确和错误时，返回最快的结果时使用 var p1 = new Promise((resolve, reject) => { setTimeout(resolve, 1000, 'one'); }); var p2 = new Promise((resolve, reject) => { setTimeout(resolve, 2000, 'two'); }); var p3 = new Promise((resolve, reject) => { reject('reject') }); Promise.race([p1, p2, p3]).then(values => { console.log(values); }, reason => { console.log(reason) }); //结果： //reject //Promise {: undefined} "},"三剑客/基础/RegExp.html":{"url":"三剑客/基础/RegExp.html","title":"RegExp","keywords":"","body":"RegExp 注意: iOS&Safari 不兼容 正则表达式的断言匹配[ (?=n) (? iOS&Safari 只能用RegExp对象格式写正则 类型 var re = new RegExp(\"表达式\",\"修饰符\"); var re = /表达式/修饰符; var re = eval(`/${a}/g`).test() //变量书写 普通字符 [...] 匹配 [...] 中的所有字符 .+ () 放在其中指定单纯的字符本意 const str = \"acacaca bababa cdcd\"; const patt1 = /[ab]/g; str.match(patt1) //a,a,a,a,b,a,b,a,b,a ... 匹配除了 [...] 中字符的所有字符 const str = \"acacaca bababa cdcd\"; const patt1 = /[^ab]/g; str.match(patt1) //c,c,c, , ,c,d,c,d [.-.] 表示一个区间，匹配区间里的内容 /[a-z]/g; //匹配小写a到小写z的字符 /[A-Z]/g; //匹配大写A到大写Z的字符 /[A-z]/g; //匹配大写A到小写z的字符 . 匹配除换行符（\\n、\\r）之外的任何单个字符 /[A-z]/g; //等同 /[^\\n\\r]/g \\w | \\W 单词字符 /\\w/g; //匹配任何单词字符,等价于:[a-zA-Z0-9] /\\W/g; //匹配任何非单词字符,等价于:[^a-zA-Z0-9] \\s | \\S 空白字符 /\\s/g; //匹配任何空白字符,等价于:[\\f\\n\\r\\t\\v] /\\S/g; //匹配任何非空白字符,等价于: [^\\f\\n\\r\\t\\v] \\d | \\D 数字字符 /\\d/g; //匹配一个数字字符,等价于:[0-9] /\\D/g; //匹配一个非数字字符,等价于:[^0-9] \\b | \\B 单词边界 /\\b/g; //匹配一个单词边界，指单词和空格间的位置 const str = \"never verb\"; const patt1 = /er\\b/g; str.match(patt1) //只能匹配never中的er /\\B/g; //匹配非单词边界 const str = \"never verb\"; const patt1 = /er\\B/g; str.match(patt1) //只能匹配verb中的er 非打印字符 \\r \\t \\0 \\n 查找回车符 查找制表符 查找NULL字符 查找换行符 限定符 {n} 匹配确定的 n 次 const str = \"Bob food\"; const patt1 = /o{2}/g; str.match(patt1) //只能匹配 \"food\" 中的两个 o {n,} 至少匹配n 次 ,上限无限 /o{1,}/g; //等价于 'o+' /o{0,}/g; //等价于 'o*' const str = \"Bob fooooood\"; const patt1 = /o{2,}/g; str.match(patt1) //能匹配 \"fooooood\" 中的所有 o {n,m} 最少匹配 n 次且最多匹配 m 次 注意在逗号和两个数之间不能有空格 /o{0,1}/g; //等价于 'o?' const str = \"Bob fooooood\"; const patt1 = /o{2,4}/g; str.match(patt1) //oooo oo 贪婪匹配 const str = \"fooooood\"; const patt1 = /^o{2,4}$/g; str.match(patt1) //false str内容必须是2-4位的才为true \\ 转义字符 ( [ { \\ ^ $ | ) ? * + . ] } //需要使用转义字符的 ( ) 原子组 对子表达式进行一个分组 子表达式可以获取供以后使用 //分组 var str=\"abz acz\"; var patt1=/(ab|ac)z/g; //将abac进行分组 str.match(patt1) //重复使用 //验证的值前后需要一致 var str=\"a1@a1\"; var patt1=/(a[1-3])@\\1/g; //a[1-3]进行分组，后续通过\\1 进行使用( 后续如果还存在原子组，则延续\\1\\2\\3 ) str.match(patt1) (?:) 在组记录中忽略其内容 var str = \"a1@a1.com\"; var patt1 = /(a[1-3])@(?:com|org|cn)/g; str.match(patt1) //数组中没有com (?=n) 断言匹配 匹配任何其后紧接指定字符串 n 的字符串 //对其后紧跟 \"all\" 的 \"is\" 进行全局搜索 var str=\"Is this all there is\"; var patt1=/is(?= all)/g; str.match(patt1) //this 中的is被匹配 (? 匹配任何前面紧接指定字符串 n 的字符串 //对其后紧跟 \"all\" 的 \"is\" 进行全局搜索 var str=\"Is this all there is\"; var patt1=/(? (?!n) 匹配任何其后没有紧接指定字符串 n 的字符串 //对其后没有紧跟 \"all\" 的 \"is\" 进行全局搜索 var str=\"Is this all there is\"; var patt1=/is(?= all)/g; str.match(patt1) //前后的IS is被匹配 (? 匹配任何前面没有紧接指定字符串 n 的字符串 //对其前面没有 \"all\" 的 \"is\" 进行全局搜索 var str=\"all Is this all there is\"; var patt1=/(? ？ 禁止贪婪用途，使子表达式倾向少的那一方 +? *? ?? {2,100}? 只能匹配1次 只能匹配0次 只能匹配0次 只能匹配2次 /hd+?/g; //只能匹配1次 /hd*?/g; //只能匹配0次 /hd??/g; //只能匹配0次 /hd{2,100}?/g; //只能匹配2次 n? n+ n* 匹配前一项0次或者1次 匹配前一项一次或多次 匹配前一项0次或多次 ^n n$ **n \\ m ** 匹配任何开头为n的字符串 匹配任何结尾为n的字符串 选择符 - nm之间的一个选择 修饰符 i g m ignore - 不区分大小写 global - 全局匹配 multi line - 多行匹配 s y 特殊字符圆点 . 中包含换行符 \\n 连续检索，当下一个未检索到是停止 对象方法 exec 检索字符串中指定的值，并返回找到的值 var str=\"Hello world!\"; var patt1=/Hello/g; var result1=patt.exec(str);//Hello var patt2=/to/g; var result2=patt.exec(str);//null test 检索字符串中指定的值 有匹配的值返回 true ，否则返回 false var str=\"Hello world!\"; var patt1=/Hello/g; var result1=patt.test(str);//true var patt2=/Runoob/g; var result2=patt.test(str);//false toString 返回正则表达式的字符串值 var patt = new RegExp(\"RUNOOB\", \"g\"); var res = patt.toString(); ///RUNOOB/g search 返回正则表达式相匹配的索引值 没有找到任何匹配的子串，则返回 -1 var str=\"Visit Runoob!\"; var n=str.search(\"Runoob\"); //6 match 找到一个或多个正则表达式的匹配 var str=\"The rain in SPAIN stays mainly in the plain\"; var n=str.match(/ain/g);//ain,ain,ain matchAll 返回一个迭代对象 var str=\"The rain in SPAIN stays mainly in the plain\"; var n=str.matchAll(/ain/g) replace 替换与正则表达式匹配的子串 $1 $& $` $' ? 第一个原子组 匹配到的内容 匹配到的前面的内容 匹配到的后面的内容 别名 var str = \"abab acac adad\"; var patt = new RegExp(\"a\", \"gm\") var n = str.replace(patt,\"s\");//sbsb scsc sdsd var n = str.replace(patt,v=>{ return \"s\" });//sbsb scsc sdsd //$1 第一个原子组 var str = \"a1@a1\"; var patt1 = /(a[1-3])@\\1/g; str.replace(patt1,`$1`) //a1 //$& 匹配到的内容 //$` 匹配到的前面的内容 a1@前面的等号 //$' 匹配到的后面的内容 @a1后面的等号 var str = \"=a1@a1=\"; var patt1 = /(a[1-3])@\\1/g; str.replace(patt1,`$&1`) //a1@a11 //别名 可以通过matchAll直接访问到别名 var str = \"=a1@a1=\"; var patt1 = /(?a[1-3])@\\1/g; str.replace(patt1,`$`) //a1@a1 split 把字符串分割为字符串数组 var str = \"abab-acac/adad\"; var patt = new RegExp(\"-\\/\", \"g\") var n = str.split(patt);//abab,acac,adad global 判断是否设置了 \"g\" 修饰符 ignoreCase 判断是否设置了 \"i\" 修饰符 multiline 判断是否设置了 \"m\" 修饰符 source 返回正则表达式的匹配模式 lastIndex 用于规定下次匹配的起始位置 正则引擎 "},"三剑客/基础/Sass'Less.html":{"url":"三剑客/基础/Sass'Less.html","title":"Sass/Less","keywords":"","body":"Sass/Less postCss 后处理器 --- 在less和sass预处理器处理完后，处理lees/sass的原生css内容 对高级的css语法降级，以此来适配低版本浏览器 前缀补全 ---webkit Sass gem install sass 变量声明 $nav-color: #F90; nav { $width: 100px; width: $width; color: $nav-color; } //编译后 nav { width: 100px; color: #F90; } 变量引用 $highlight-color: #F90; $highlight-border: 1px solid $highlight-color; .selected { border: $highlight-border; } //编译后 .selected { border: 1px solid #F90; } 嵌套CSS #content { article { h1 { color: #333 } p { margin-bottom: 1.4em } } &:hover { color: red } } 嵌套属性 nav { border: 1px solid #ccc { left: 0px; right: 0px; } } //编译后 nav { border: 1px solid #ccc; border-left: 0px; border-right: 0px; } 静默注释 body { color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */ } Less npm install -g less 变量（Variables） @width: 10px; @height: @width + 10px; #header { width: @width; height: @height; } 编译后 #header { width: 10px; height: 20px; } 混合（Mixins） 将一组属性从一个规则集包含（或混入）到另一个规则集的方法 //定义的类 .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } //使用 .post a { color: red; .bordered(); } 嵌套（Nesting） 使用嵌套（nesting）代替层叠或与层叠结合使用的能力 #header { color: black; .navigation { font-size: 12px; } &:after{ content:''; font-size:0 } } @规则嵌套和冒泡 @ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套 @ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡 .component { width: 300px; @media (min-width: 768px) { width: 600px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } } 编译后 .component { width: 300px } @media (min-width: 768px) { .component { width: 600px } } @media (min-width: 768px) and (min-resolution: 192dpi) { .component { background-image: url(/img/retina2x.png) } } calc() 特例 @var: 50vh/2; width: calc(50% + (@var - 20px)); // 结果是 calc(50% + (25vh - 20px)) 映射（Maps） #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } 编译后 .button { color: blue; border: 1px solid green; } 作用域（Scope） @var: red; #page { @var: white; #header { color: @var; // blue } @var: blue; } 导入（Importing） @import \"typo.css\"; "},"三剑客/基础/Flex.html":{"url":"三剑客/基础/Flex.html","title":"Flex","keywords":"","body":"Flex 容器属性 flex-direction 弹性子元素在父容器中的位置 row 横向从左到右排列 row-reverse 横向从右到左排列 column 纵向从上至下排列 column-reverse 纵向从下至上排列 flex-wrap 弹性盒子的子元素换行方式 nowrap 单行 -- 可能溢出容器 wrap 多行 -- 从上至下 wrap-reverse 多行 -- 从下至上 flex-flow flex-direction 、flex-wrap 两个属性简写 justify-content 内容沿着弹性容器的主轴线对齐 元素在行内的对齐 flex-start 行头堆叠 flex-end 行尾堆叠 center 居中对齐 space-between 平均分布 -- 两边靠边 space-evenly 完全平均分布 space-around 平均分布 -- 两边保留元素间距一半 align-items 弹性盒子在侧轴(纵轴)方向上的对齐 flex-start 起始端对齐 flex-end 末尾段对齐 center 居中对齐 baseline 基线对齐 stretch 子容器尺寸拉伸到父容器一致 align-content 各行在所在的flex容器里的对齐 类似 justify-content stretch 伸展占用剩余的空间 flex-start 起始位置堆叠 flex-end 结束位置堆叠 center 居中对齐 space-between 平均分布 -- 两边靠边 space-around 平均分布 -- 两边保留元素间距一半 项目属性 order 项目在容器中出现的顺序 order: number; .flex div:nth-child(1) { order: 2; } .flex div:nth-child(2) { order: 5; } align-self 某个项目设置不同于其它项目的对齐方式 可以覆盖 align-items 属性的值 auto 继承其父容器的值 stretch 拉伸以适合容器 center 容器的中央 flex-star 容器的顶部 flex-end 项目位于容器的底部 baseline 与容器的基线对齐 align-self: flex-start; flex flex-grow、flex-shrink 和 flex-basis 三个属性的简写 两个快捷值，分别为 auto（1 1 auto）和 none（0 0 auto） flex: flex-grow flex-shrink flex-basis; flex:1 1 auto; flex-grow number -- 默认0 项目相对于其他项目的增长量 flex-shrink number -- 默认1 项目相对于其他项目的收缩量 flex-basis string \\ auto \\ inherit 项目的长度 -- 默认auto "},"三剑客/基础/Grid.html":{"url":"三剑客/基础/Grid.html","title":"Grid","keywords":"","body":"Grid 容器( container ) 网格布局的区域 项目( item ) 容器内部采用网格定位的子元素 行( row ) 水平区域 列 ( column) 垂直区域 单元格( cell ) 行和列的交叉区域 n 行和 m 列会产生 n x m 个单元格 网格线( gridLine ) 水平网格线划分出行，垂直网格线划分出列 n 行有 n + 1 根水平网格线，m 列有 m + 1 根垂直网格线 容器属性 display 指定一个容器采用网格布局 grid 采用网格布局 -- 块级元素 inline-grid 采用网格布局 -- 行内元素 template-columns /template-rows grid-template-columns -- 定义每一列的列宽 grid-template-rows -- 定义每一行的行高 display: grid; grid-template-columns: 25% 25% 25% 25%; grid-template-rows: 25% 25% 25% 25%; repeat() 重复的值 repeat(4, 25%) -- (次数，内容) auto-fill 自动填充 repeat(auto-fill, 100px) fr 比例关系 1fr 2fr (后者是前者的两倍宽) minmax 长度范围 minmax(min, max) auto 自己决定长度 100px auto [ ] 指定每一根网格线的名字 [r1] 100px [r2] 100px template-areas grid-template-areas -- 定义区域 display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i'; 合并某区域 grid-template-areas: 'a a a' 'b b b' 'c c c'; 占位符 . 该单元格不属于任何区域 grid-template-areas: 'a . a' 'b . b' 'c . c'; 注意: 区域的命名会影响到网格线 起始网格线自动命名为区域名-start 终止网格线自动命名为区域名-end grid-template grid-template-columns、grid-template-rows 、grid-template-areas 合并简写 auto-columns / auto-rows 当网格只有3列，但是某一个项目指定在第5行。浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns -- 设置浏览器自动创建的多余网格的列宽 grid-auto-rows -- 设置浏览器自动创建的多余网格的行高 grid-auto-columns: 50px; grid-auto-rows: 50px; row-gap / column-gap row-gap -- 行与行的间隔（行间距） column-gap -- 属性设置列与列的间隔（列间距） gap: row-gap: 20px; column-gap: 20px; gap: 20px 20px; auto-flow grid-auto-flow -- 设置子元素顺序 grid-auto-flow: row; grid-auto-flow: row dense; grid-auto-flow: column; grid-auto-flow: column dense; row 先行后列 row dense 先行后列 -- 紧密填满 column 先列后行 column dense 先列后行 -- 紧密填满 justify-items / align-items justify-items -- 单元格内容的水平位置（左中右） align-items -- 单元格内容的垂直位置（上中下） justify-items: start | end | center | stretch; align-items: start | end | center | stretch; place-items: ; place-items: start end; start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 stretch 拉伸，占满单元格的整个宽度（默认值） justify-content / align-content justify-content -- 整个内容区域在容器里面的水平位置（左中右） align-content -- 整个内容区域的垂直位置（上中下） justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; place-content: place-content: space-around space-evenly; start 对齐容器的起始边框 end 对齐容器的结束边框 center 容器内部居中 stretch 拉伸占据整个网格容器 -- 未设置大小时 space-around 平均分布 -- 两边保留项目间距的一半 space-between 平均分布 -- 两边靠边 space-evenly 完全平均分布 grid grid-template-rows 、 grid-template-columns 、 grid-template-areas 、 grid-auto-rows 、 grid-auto-columns 、 grid-auto-flow 、简写 项目属性 column-start / column-end / row-start / row-end 指定项目的四个边框，分别定位在哪根网格线 grid-column-start 左边框所在的垂直网格线 grid-column-end 右边框所在的垂直网格线 grid-column 上方简写 -- start / end grid-row-start 上边框所在的水平网格线 grid-row-end 下边框所在的水平网格线 grid-row 上方简写 -- start / end span 跨越 -- span 2 //项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线 grid-column-start: 2; grid-column-end: 4; //指定为第几个网格线，还可以指定为网格线的名字 grid-column-start: header-start; grid-column-end: header-end; //项目的左边框距离右边框跨越2个网格 grid-column-start: span 2; 简写 grid-column: / ; grid-row: / ; grid-column: 1 / 3; grid-row: 1 / 2; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; grid-area grid-area -- 指定项目放在哪一个区域 可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写 //直接名字指定区域 grid-area: e; //合并简写方式指定区域 grid-area: / / / ; grid-area: 1 / 1 / 3 / 3 justify-self / align-self justify-self -- 单元格内容的水平位置（左中右） align-self -- 单元格内容的垂直位置（上中下） place-self -- 上方合并简写 justify-self: start | end | center | stretch; align-self: start | end | center | stretch; //合并简写 lace-self: ; place-self: center center; start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 stretch 拉伸，占满单元格的整个宽度（默认值） "},"三剑客/基础/性能优化.html":{"url":"三剑客/基础/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 "},"规范/规范.html":{"url":"规范/规范.html","title":"规范","keywords":"","body":"规范 CSS 规范 BEM 命名规范 stick-man // - 连接 不使用驼峰 __head // __ 上级的子组件 --blue // -- 上级的状态 状态 前一个 prev 后一个 next 当前的 current 显示的 show 隐藏的 hide 打开的 open 关闭的 close 选中的 selected 有效的 active 默认的 default 反转的 toggle 禁用的 disabled 危险的 danger 主要的 primary 成功的 success 提醒的 info 警告的 warning 出错的 error 大型的 lg 小型的 sm 超小的 xs 布局 文档 doc 头部 header(hd) 主体 body 尾部 footer(ft) 主栏 main 侧栏 side 容器 box/container 栏目 column 通用部件 列表 list 列表项 item 表格 table 表单 form 链接 link 标题 caption/heading/title 菜单 menu 集合 group 条 bar 内容 content 结果 result 组件 按钮 button(btn) 字体 icon 下拉菜单 dropdown 工具栏 toolbar 分页 page 缩略图 thumbnail 警告框 alert 进度条 progress 导航条 navbar 导航 nav 子导航 subnav 面包屑 breadcrumb(crumb) 标签 label 徽章 badge 巨幕 jumbotron 面板 panel 洼地 well 标签页 tab 提示框 tooltip 弹出框 popover 轮播图 carousel 手风琴 collapse 定位浮标 affix 语义化小部件 品牌 brand 标志 logo 额外部件 addon 版权 copyright 注册 regist(reg) 登录 login 搜索 search 热点 hot 帮助 help 信息 info 提示 tips 开关 toggle 新闻 news 广告 advertise(ad) 排行 top 下载 download JavaScript 规范 "},"三剑客/进阶/数据结构及算法/排序算法.html":{"url":"三剑客/进阶/数据结构及算法/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 "},"三剑客/进阶/数据结构及算法/堆与栈.html":{"url":"三剑客/进阶/数据结构及算法/堆与栈.html","title":"堆与栈","keywords":"","body":"堆与栈 "},"三剑客/进阶/TypeScript/基础篇.html":{"url":"三剑客/进阶/TypeScript/基础篇.html","title":"基础篇","keywords":"","body":"命令行 tsc xxx //执行ts文件，编译成js文件 tsc --init //生成ts配置文件 tsc --watch //ts自动编译成js文件 tsc --noEmitOnError --watch //当ts文件有错误时，不自动编译 tsconfig.json \"target\":\"es5\" //降级编译 编译后的js文件符合es5标准 \"strict\": true //打开严格模式 这个包括下面两个功能 \"noImplicitAny\": true //类型隐患检查 \"strictNullChecks\": true //严格的Null检查 \"rootDir\":\"./src\" //根目录 \"outDir\":\"./dist\" //输出目录 一、类型 类型一般大写字母开头 基本类型 string //字符串 number //数字 boolean //布尔 null //不存在 undefined //未初始化的值 //数组 type[] //arr:number[] 数字类型数组 Array //Array 数字类型数组 //任何 any //obj: any = {} 任何值都可以赋值 其他类型 never //不应该存在的状态 当函数异常\\中止\\死循环就是never void // 没有返回值函数的返回值 object // 任何的不是基本类型的值 object !== Object\\ unknown //代表任何的值，但是不能进行任何访问 function //描述所有函数值的属性，它的返回值总是any 原语 bigint //非常大的整数 let a:bigint = 100n symbol //全局唯一引用 let a = Symbol(1) let b = Symbol(1) a == b //答案为false,因为symbol具有全局唯一性 二、类型注释 如果未注释类型，则会根据首次赋值来自动注释类型 匿名函数自动根据传入的值自动注释 //参数注释 let person: number = 1 //冒号+类型 //函数注释 function gteer(name: string) {} //: string 表示形参类型注释 function gteer(): string {} //string表示返回值类型注释(void表示没有返回值) () => string //箭头函数返回值类型 //对象注释 function gteer(pt:{x:number, y?:number}) //问好表示可不传y值 //联合类型 let id: number | string 类型别名 //使用type定义类型 type Point = { x:number,y:number } function getData(pt:Point) { } type ID = number | string function getData(id:ID) {} //扩展类型别名 type Bear = Point & { z:number } //通过&扩展 也可以扩展接口 接口 //使用interface定义类型 interface Point { x:number y:number } const point:Point = {x:1,y:2} //扩展接口 interface Bear extends Point1，Point2 { //此处扩展可以合并多个其他接口 z:number } const bear:Bear = {x:1,y:2,z:3} //添加新字段 interface Point { a:numbe } //重复定义，就可以新增加字段 泛型类型 function identity(arg:Type):Type{ return arg } const x = identity('hello') // const x:string 类型断言 // string不能直接断言成number,需要有覆盖关系 const x = ('hello' as unknown) as number //unknown 未知的 const B = A //断言A为number类型 // 固定类型 let x = {} as const x! //断言x不是null或者undefined 文字类型 //字符串文字类型 let x: 'true'|'false' = \"true\" //数字文字类型 let x:-1 | 1 | 0 = 0 //布尔文字类型 let x: true | false = true 枚举 enum direction { a = 1, b, c, d } console.log(direction.a，direction.b) //1 2 3 4 会在每个后面依次加1 三、类型缩小 typeof 类型守卫 object \\ string \\ number \\ bigint \\ boolean \\ symbol \\undefined \\ function if(typeof strs === \"object\") {} 真值缩小 条件、&&、||、if语句、！ 通过对上方的使用，过滤null和undefined 等值缩小 ===, !===, ==, != function example (x:string | number,y:string | boolean){ if(x === y){} //当两者都是string时执行里面内容 } let a: number | null | undefined if( a != null ){ } //当a等于null或undefined时，都不会执行里面内容 in 操作符缩小 type a1 = { a: ()=> void } type b1 = { b: ()=> void } type c1 = { a?: ()=> void; b?: ()=> void } function test( value: a1 | b1 | c1 ){ if( 'a' in a1 ){ //a1对象中是否有a属性 return (a as a1 ).a() //因为c1也有a属性，所以加个 as a1 缩小范围 } } instanceof 操作符缩小 x instanceof Foo //检查Foo是否是X的实例 if( x instanceof Date ){] //是否是Date上的实例 分配缩小 let x = Math.randow() 类型谓词 type Fish = { name:string swim: ()=> void } type Bird = { name: string fly: ()=> void } function isFish(pet: Fish | Bird):pet is Fish { return (pet as Fish).swim !== undefined } 联合类型 unions interface a { name:\"a\" radius:number } interface b{ name:\"b\" leftLength:number } type c = a | b //联合类型 function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength } } 穷进性检查 type c = a | b function getDate(shape:c){ switch(share.name){ case 'a'： return shape.radius case 'b'： return shape.leftLength default: //never 任何类型都不能分配给never let d: never = shape //never 不应该存在的状态 可以分配给任何类型 return d } } 四、函数类型 函数类型表达式 //fn : (a: string) => void type fnType = (a: string) => void function greeter(fn : fnType) { fn(\"hello\") } function prinTo(s:string){ console.log(s) } greeter(prinTo) //结果为 \"hello\" 调用签名 创建一个除了函数类型外还有其他类型的对象 也可以使用 interface 创建 type funType = { a: string (b: number) : booleam //参数列表和返回类型之间是：而不是=> } function getData(fn:funType){ cosnole.log(fn.a + fn(6)) } function fn1(n:number){ return true } fn1.a = 'hello' getData(fn1) //结果 hello true 构造签名 class ctor { s: string newfun(s: string) { this.s = s } } type funType = { new (a: string) : ctor //这里返回类或者构造函数 也可填写其他返回值类型 } function fn(ctor: funType){ return new ctor('hello') } const f = fn(ctor) console.log(f.s) //结果 hello 泛型函数 类型推断 数组元素是什么类型，Type就是什么类型 保持输入和输出类型一致 Type 名可以随意取 function getData(arr: Type[]): Type | undefined { return arr[0] } getData(['a','b']) //返回值类型string 一般不写 TS会自行推断 getData([1,2]) //返回值类型number getData([]) //返回值类型undefined function getArray(arr: Input[], func: (arg: Input) => Output): Output[] { return arr.map(func) //map直接放函数是map的语法 } const parsed = getArray(['1','2','3'],(n) => parseInt(n)) 限制条件 // 传入a或b的参数，必须要有length这个属性 function longest( a: Type, b: Type ){ return a.length + b.length } const logestAttay = longest([1,2],[3,4]) const logestString = longest('11','22') 使用受限值 function getData( obj:Type, num: number ):Type { if(obj.length>num){ return obj }else{ // 当返回值不是Type时，可以在前面加一个泛型就好了 return { length: num } } } const arr = getData([1,2,3],6) 指定类型参数 function getData(arr1: Type[], arr2: Type[]): Type[] { return {...arr1,...arr2} } // 这儿强制分别规定泛型类型 const att = getData([1,2,3],['string']) 约束准则 1、尽可能使用类型参数本身，而不是对其约束 function getData(arr: Type[]){ return arr[0] } //correct function getData(arr Type){ return arr[0] } //error 2、尽可能少的使用类型参数 function getData(arr:Type[], func:(arg:Type)=> boolean){} //correct function getData( //error arr: type[], func: func ) 3、一个类型参数只出现在一个地方时，若非必要则尽量不写 function gerData(s:string){} //correct function getData(s :str){} //error 4、当函数里传递回调函数时，永远不要写一个可选参数 函数重载 基本语法 多人合作时，重载签名相当于是定义好了的函数，实现签名就是我们将重载签名拿来使用 尽可能使用联合类型的参数，而不是重载参数 ts可以把this当作参数名（注意不能使用箭头函数） //重载签名 function makeDte(timestamp: number): Date function makeDte(m: number, d:number , y:number): Date //实现签名 function makeDte(mOrtTimestamp: number, d?: number, y?:number): Date { if(d !== undefined && y !== undefined){ return new Date(y, mOrtTimestamp,d) }else{ return new Date(mOrtTimestamp) } } 函数形参展开 function getData(...a: number[]){ return a[0] } getData(1,2,3,4) 参数解构 type abc = {a: number, b: number, c: number} function sum({a, b, c}: abc){ console.log(a + b + c) } sum({a: 10, b: 3, c: 32}) 五、对象类型 只读属性（readonly） interface someType{ readonly prop: string //readonly 写了后，属性就变成了只读 readonly list: { //内部的属性可以修改，list不能修改 name: 'a' } } 索引签名 interface stringArray { //string 表示index必须是string number 是表示数组，可以使用数子得到对应的参数 [idnex: number]: string //index相当于数组索引的意思 } cosnt myArray:stringArray = ['a','b'] cosnt item = myArray[0] interface TextString { // string 是表示props必须是string，可以使用属性得到对应的属性值 [props: string]: number } cosnt textString: TextString = { x:100, y:200 } cosnt item = textString['x'] 六、从类型中创建类型 泛型 基本语法 function getData(arg: Type): Type { } let data = getData(\"hello\") //定义了泛型类型 let data = getData(\"hello\") //自动推断类型为string 泛型接口 interface a{ (arg: Type): Type } function c(arg:Type):Type{ return arg } let b:a = c 泛型类 calss a{ b: numType add:(x：numType) => numType } let mya = new a() //此处的number就是给泛型类属性加类型 约束中使用类型参数 // Key extends keyof Type 意思是 key是包含在type中 function getData(obj: Type, key: Key) { return obj[key] } let x = { a:1, b:2, c:3 } getData(x,'a') //主要是a,b,c就没有问题 泛型中使用类类型 function create(c: { new (): Type }): Type { retuQ YHGB VNrn new c() } keyof 类型操作符 将类型对象属性解析成属性联合类型 type point = { x:number, y:number } type P = keyof point //等同于 'x' | 'y' const p1:P = 'x' const p2:P = 'y' type map = { [k: string]: boolean } //因为js[]语法底层会把number转换成string，所以m的类型是number | string type M = keyof map const myArray = [ { name:'a', age:11 }, { name:'b', age:12 }, ] // Person类型 {name: string,age:number} type Person = typeof myArray[number] //number代表是任何一个数组下标，占位符 typeof 类型操作符 解析属性属于什么类型 是对象则返回对象的返回值类型 let s = \"hello\" let n: typeof s //此时n的类型就是s的类型 string //ReturnType 获取函数返回值类型 ts内置函数 type Predicate = (x: unkown)=> boolean type K = ReturnType 索引访问类型 type List = { a: number; b:string; c:boolean } type A = List['a' | 'b'] 条件类型 举例 interface a { live():void } interface b extends a { woof():void } type c = b extends a ? number : string //a被b约束，语法类似三元表达式 约束 //T 是否存在 {message: unknown } type MessageOf = T extends {message: unknown } ? T['message'] : never interface a { message: string } type b = MessageOf //结果为string 条件类型内推理 infer 定义泛型变量 获取返回值类型 七、类 类属性 class point { //class 关键词定义类 a: number constructor(){ //当point实例化时，会执行此函数，进行数据初始化 this.a = 0 //this默认指向类的实例 } } const p = new point() //()表示实例化类 readonly 修饰符 防止在构造函数之外进行赋值 class point { readonly name:string = 'hello' constructor(enterNmae?: string){ //只能在constructor中修改只读属性 if(enterNmae !== undefined){ this.name = enterNmae } } } const g = new point('通过传值进行更改') console.log(g) 构造器 -- constructor 构造函数不能有类型参数 构造函数不能有返回类型注释 class point { //class 关键词定义类 a: number; b: number; //有默认值可以不写类型，会自动推断。 //不写默认值实例化不传值是会报错 constructor(x:number = 0 , y:number = 0){ this.a = x this.b = y } } const p = new point(1,2) //类继承必须使用super函数 class base { k = 4 } class point extends base { constructor(){ super() } } 类的方法 class point { a: number = 10 b: number = 11 scale(n: number): void { //和外部函数使用没区别 this.a *= n this.b *= n } } const p = new point() p.scale(10) console.log(p.a,p.b) Getters/Serters 存取器 如果只存在get，没有set，则该属性自动是只读的 如果没有指定setter参数的类型，则从getter的返回类型推断出来 访问器和设置器必须是相同的成员可见性 class C { _length = 0 get length(){ return this._length } set length(value) { this._length = value } } let c: C = new C() let a = c.length //会执行类里get关键字的函数 c.length = 100 //会执行类里set关键字的函数 索引签名 class myClass { [s: string]: boolean | ((s: string) => boolean) x = true check(s: string) { return this[s] as boolean } } 类继承 - implements 子句 一个类去继承或者实现一个接口 实现父级类的公共内容 父级类不会改变类的类型，子级类可以进行兼容 父类可选属性，继承的子类可以选择不实现 interface A { x: number y: number } class B implements A { //除了A中的可选属性，其他属性必须写上 x = 0 y = 0 } 类继承 - extends 子句 一个类继承另外一个类 继承的类具备父类所有的属性和方法，并且还可以定义自己的一些属性和方法 class A { x:number = 1 } class B extends A { y:number = 2 } 类重写 覆盖类的时候，类型需要兼容 class base { greet() { console.log(\"hello\") } } class Derived extends base { greet(name?: string) { //直接覆盖父类greet方法 if (name === undefined) { super.greet() //super 指向父类的方法 this指向属性 } else { console.log(name) } } } const d = new Derived() d.greet() d.greet(\"子类的方法\") 初始化顺序 父类: 基类 子类：派生类 1、基类的字段被初始化 2、基类构造函数运行 3、派生类的字段被初始化 4、派生类构造函数运行 class Base { name = 'base' constructor() { console.log(this.name) } } class Derived extends Base { name = 'derived' } const d = new Derived() 继承内置类型 class MsgError extends Error {} //Error 内置类型 成员的可见性 -- public 公开的，默认值。任何对象在任何地方都可以访问 class Base { public name = 'base' //public 默认值，可不写 } const d = new Base() d.name 成员的可见性 -- protected protected 受保护的。只能在当前类和子类中进行访问 派生类可以暴露基类受保护的成员 二次赋值即可 class Base { protected base() { return 'base' } } class Derived extends Base { title = super.base() test() { console.log(super.base()) } } const d = new Derived() d.test() 成员的可见性 -- private 私有的。只能在当前类中进行访问 class Base { private x = 1 base() { console.log(this.x) } } const d = new Base() d.base() TypeSctipr 允许跨实例的私有访问 class A { private x = 10 public sameAs(other: A) { //通过函数暴露私有化变量 return other.x } } const a = new A() console.log(a.sameAs(a)) 静态成员 -- static 静态名称避免使用：name,length,call等特殊名字 TypeScript 没有静态类的概念，因为有函数和普通对象 修饰符可以连着使用，这儿也可以加上成员可见性 基类可以被派生类继承 class myClass { static x = 0; static printX() { myClass.x //可以直接获取 } } const a = myClass.x 类里的static区块 把静态成员私有化，类私有域 class myClass { static #x = 0; //加了#号就只能在类内部使用 static printX() { return myClass.#x } static { //静态区块，默认会执行 console.log(\"hell\") } } 泛型类 静态成员不能使用泛型 class Box{ contents: Type constructor(value: Type) { this.contents = value } } const a = new Box(`1111`) const b: Box = new Box(`1111`) const c = new Box(`1111`) 类运行时的this class MyClass { name: 'MyClass' //原代码 getName() { //这样写，下面obj里c.getNam调用时this指向会边 return this.name } //解决方法1 //利用箭头函数，固定this指向 //会浪费更多的内存，不能在派生类中调用这个函数 getName = ()=>{ return this.name } //解决方法2 //this: MyClass 作用是告诉这个函数this指向地方，提前报错 getName(this: MyClass) { return this.name } } const c = new MyClass() const obj = { name: 'obj', getName: c.getName } console.log(obj.getName()) this 类型 class Box { content: string = '' sameAS(other: this) { //通过传入的值来固定this的指向 return other.content === this.content } } class DerivedBox extends Box { otherContent: string = '?' } const bsse = new Box() const derived = new DerivedBox() derived.sameAS(derived) 基于类型守卫的this ？ 类和方法返回值的位置使用 this is 类型 前面的是固定写法 class Box{ value?: T hasValue(): this is { value: T } { return this.value !== undefined } } const box = new Box() box.value = 'hello' if (box.hasValue()) { console.log(box.value) } 参数属性 class Box { //x加了public后，外部也可以访问了 constructor(public x: number) { this.x = x } } const p = new Box(100) p.x = 200 类表达式 const box = class { content: Type constructor(value: Type) { this.content = value } } const m = new box('hello') console.log(m.content) 抽象类和成员 -- abstract 不能被实例化，只能当作基类，派生类继承 abstract class Base { abstract getNmae(): string //抽象成员 不能被实现 printName() { console.log(this.getNmae) } } class Derived extends Base { getNmae() { return 'world' } } const b = new Derived() b.getNmae() b.printName() 类之间的关系 内部类型一样，可以相互兼容 class A { x = 0 y = 0 } class B { x = 0 y = 0 } const p: A = new B 类可以包含使用 class A { x = 0 y = 0 } class B { x = 0 y = 0 z = 0 } const p: A = new B //b当成了a的继承类 一个空的类可以传入任何参数 class A {} function fn(x:A){ } fn(window) //这儿传入什么，A就会有什么参数 八、模块 模块在自己的范围内执行 ES模块语法 export default function A() { //导出模块 return 'hello' } import hell from './hell' // 引入模块， 一般不写后缀，ts后缀不能写 heel() export let a = 1 export let b = 1 import {a,b} from './hell' console.log(a,b) 额外的导入语法 export let a = 1 export default class B {} //默认的导出 //B1 是类B的别名，as 启用别名 import B1, {a as a1} from './hell' // * 导入所有的东西 import * as math from './hell' // default() 导出默认的导出 const C = new math.default() TS特定的ES模块语法 export type dataType = { a: string b: number c: boolean } export interface dataInterface { a: string b: number c: boolean } import type { dataType,dataInterface } from './hell' export let a = 1 import { a, type dataType, type dataInterface } from './hell' commonJs语法 function getData(): void { } let a = 1 module.exports = { //导出 a, getData } exports.getData = getData //导出 cosnt data = require('./test')//导入 九、内置方法 Partial 将一个传递进来的类型所有属性设置成可选的 interface Person { name: string; age: number; } type PartialPerson = Partial // type PartialPerson = { // name?: string | undefined; // age?: number | undefined; // } Required 将传递的类型里所有的属性变成必选的 interface Person { name?: string; age: number; } type RequiredPerson = Required // type RequiredPerson = { // name: string; // age: number; // } Omit 第一个是类型，第二个是去掉类型中的某几个属性 interface User { id: number; name: string; email: string; age: number; } type OmitUser = Omit // type OmitUser = { // email: string; // age: number; // } Pick 第一个是类型，第二个是要留下哪几个属性 interface User { id: number; name: string; email: string; age: number; } type PickUser = Pick // type PickUser = { // id: number; // name: string; // } Record 用来约束一个类型的 第一个参数用来约束 key 的类型，第二个参数用来约束 value 的类型 type User = Record const user: User = { name: 'John', age: 20, email: '' } type User2 = Record const user2: User2 = { name: 'John', age: 20, email: '', } "},"三剑客/进阶/TypeScript/tsconfig.html":{"url":"三剑客/进阶/TypeScript/tsconfig.html","title":"tsconfig","keywords":"","body":"tsconfig { \"compilerOptions\": { \"target\": \"ESNext\", //遵循那个版本的语法es5 es6 \"useDefineForClassFields\": true, //是否使用定义类字段 \"module\": \"ESNext\", //编译后要遵循的模块规则 \"strictNullChecks\": true,//检查元素是否为空 \"moduleResolution\": \"Node\", //选择模块解析策略，有'node'和'classic'两种类型 \"strict\": true, //是否启动所有类型检查 \"noImplicitThis\": true,//不允许使用不明确指向的this \"noImplicitAny\": true,//不允许使用隐式any类型 \"jsx\": \"preserve\", //指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react' \"resolveJsonModule\": true, //允许导入带有“json扩展名的模块 \"isolatedModules\": true, //将每个文件作为单独的模块 \"esModuleInterop\": true, //允许export=导出，由import from 导入 \"lib\": [\"ESNext\", \"DOM\"], //包含在编译中的库文件 \"skipLibCheck\": true, //// 所有声明文件（*.d.ts）的类型检查，解决打包不报错 \"noEmit\": true, //不输出任何文件 \"skipDefaultLibCheck\": true, //是否跳过默认库声明文件的类型检查 \"baseUrl\": \"./\", //解析非绝对模块名的基准目录 \"paths\": { // 设置路径映射 路径别名 \"@\": [\"src\"], \"@/*\": [\"src/*\"], \"@comp/*\": [\"src/components/*\"], \"@utils/*\": [\"src/utils/*\"], \"@interfaces/*\": [\"src/types/*\"], \"@stores/*\": [\"src/stores/*\"], \"@imgs/*\": [\"src/assets/images/*\"], \"@hooks/*\": [\"src/hooks/*\"] }, \"types\": [\"vite/client\"] //加载的声明文件包 }, \"include\": [ //指定被编译文件所在的目录。 \"src/**/*.ts\", \"src/**/*.d.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"shims-vue.d.ts\" ], \"references\": [ //项目引用，它允许将 TS 程序组织成更小的部分 { \"path\": \"./tsconfig.node.json\" } ] } "},"三剑客/进阶/TypeScript/ts补充.html":{"url":"三剑客/进阶/TypeScript/ts补充.html","title":"ts 补充","keywords":"","body":"ts 补充 注意事项 不确定类型 , 应该使用unknown 当属性可选时，应该用类继承的方式去书写 vue2 补充 @Watch('message',{ immediate:true, // immediate表示在watch中首次绑定的时候，是否执行handler， // 值为true则表示在watch中声明的时候，就立即执行handler方法， // 值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。 }) "},"vue/vue2.html":{"url":"vue/vue2.html","title":"vue2","keywords":"","body":"基础 创建项目 npm install -g @vue/cli 安装vuecli vue create vue 创建vue项目 知识 查兼容性 caniuse.com vue3生命周期销毁名字改动 vue修饰符keyup后面可以直接跟键位值 keyup.65 可以给input标签加上vlaue来通过$event 获取 多选框可以直接通过value通过model添加进数组 方法可以直接写到标签内，getData() 直接return出去了， betterScroll 实现页面中拖动滚动拉动等属性功能 window 远程桌面连接 动态添加对象属性 vue2 无法直接拦截，vue3可以直接改 vue.set(对象,属性,true) vue set(vm.classObj,\"dd\",true) 组件： //中央事件主线 var bus = new Vue //通过new vue 创建实例 bus.$emit(\"kerwin\",data) //传入数据 bus.$On(\"kerwin\",(data)=>{}) //接受数据 对象组件传值 post: { id: 1, title: 'My Journey with Vue' } 组件使用v-model searchText = newValue\" /> value: { get() { return this.modelValue }, set(value) { this.$emit('update:modelValue', value) } } 透传 可以在js中访问组件的所有透传 this.$attrs ... //changeValue 将会透传到main根标签上 ... ... 插槽： 父组件通过插槽问子组件属性 默认插槽 具名插槽 Here's some contact info 指令： 自定义指令 this默认指向是window // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { inserted(el,binding) { // inserted 被绑定元素插入父节点时调用 } }) vue.directive('focus',(el,binding)=>{}) //简写 创建或更新都会执行 //局部指令 directives: { focus: { inserted (el) { } }， focus: (el){}，//简写 } v-focus=\"{index:1,name:q}\" //只有一个参数，但是可以传数组和对象 vue3中，指令的生命周期名字改成和组件生命周期一致了 $nextTick() 页面渲染完毕之后再加载 vue.config.js 文件配置 @ 别名 =》永远指向src的绝对路径 module.exports={ devServer :{ proxy :{ //配置反向代理 '/ajax':{ //确定应该将哪些请求代理到目标主机 target:\"https://baidu.com\",//要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { '^/ajax': '',}, ///路径重写 } }, }, configureWebpack:{ resolve:{ alias:{ //配置别名 'assets':'@/assets', 'components':'@/components' } } } } 路由： router.js Vue.use(VueRouter) //注册路由插件，两个全局组件 router-view router-link routers:[ { path: '/bill', component: Layout, //跳转路径 redirect: '/bill/equipmentList', //路由重定向 alwaysShow: true, //是否显时 name: '账单管理', meta:{isShhow:true} children: [ //嵌套路由 { path: 'billList', name: '账单列表', component: () => import('@/shopViews/bill/billList'), }, ] }, { //路由重定向 path:\"*\", redirect:\"/index\" //未匹配到时 重定向到index } ] const touter = new VueRouter({ mode:\"history\",//路由模式 routes }) 声明式导航 编程式导航 this.$router.push('/index') //路由跳转 router路由大对象 route当前匹配的路由 this.$router.replace('/') //和push功能一样，但是不会留下历史记录 //返回上一级 router.back() //动态路由 path:'/index/:myId' //动态路由 router.js文件 this.$router.push(`/index/${id}`) this.$toute.params.myId //拿到当前路由参数 //命名路由 name:'kerwin' //router.js 路由中命名 this.$router.push({ //跳转到名字为kerwi的路由 name:'kerwi', params:{ id, } }) 路由模式 hash模式（location.hash + hashchange 事件） window.onhashchange 监听路径是否改变 hash 模式的实现方式就是通过监听 URL 中的 hash 部分的变化，触发haschange事件，页面做出不同的响应。但是 hash 模式下，URL 中会带有 #，不太美观。 history模式 后端需要配置，当url无匹配资源时，返回同一个index.html页面 history 路由模式的实现，基于 HTML5 提供的 History 全局对象 history.pushState() //向当前浏览器会话的历史堆栈中添加一个状态，会改变当前页面url，但是不会伴随这刷新 history.replaceState()//将当前的会话页面的url替换成指定的数据，replaceState 会改变当前页面的url，但也不会刷新页面 全局路由守卫 meta:{isShhow:true} //to可以获取到meta的值 to.meta.isShhow router.beforEach(to,from,next)=>{ //to 即将进入的路由对象 from 正要离开的路由对象 next() //直接放行 next('/login') //也可重定向 next({ path:'/login', query:{path:'index'} //可以拼接参数 }) } 独享路由守卫 { path: '/bill', component: Layout, redirect: '/bill/equipmentList', alwaysShow: true, name: '账单管理', meta:{isShhow:true}, beforEach(to,from,next)=>{ //写在路由内部，为独享路由守卫 next() } }, 局部路由守卫 本质上是路由的生命周期 beforeRouteEnter(to,from,next)=>{}组件创建前调用，不能使用组件实例this beforeRouteUpdate(to,from,next)=>{}路由被改变，但是组件被复用时调用 beforeRouteLeave(to,from,next)=>{}导航离开时该组件调用 路由懒加载 按需加载 component: () => import('@/shopViews/bill/billList'), 组件UI库 elmentUi pc端 饿了吗开发 地址 Vant 移动端 有赞开发 地址 axios 请求 import axios from \"axios\"; const service = axios.create({ //创建axios实例 baseURL: '', timeout: 10000 }); service.interceptors.request.use( //发请求前拦截 config => {}, error => {} ); service.interceptors.response.use( //响应后拦截 response => {}, error => {} ); export default service; mixins 混入 地址 var mixin = new Vue({ created () { this.$store.commit('changeId',1) },//当没有cerated才会生效 mounted(){ this.$store.commit('changeId',2) } methods:{ //当没有相同的时，会添加进去，有不添加 a(){} } }) mixins: [mixin] //混入文件写了后，可以引入需要功能的文件中 动态绑定 动态属性 当值为 null 意为显式移除该绑定 在 HTML attribute 名称中都是不合法的都不可以，如空格、引号 避免在名称中使用大写字母，因为浏览器会强制将其转换为小写 不能使用复杂的动态参数 ... //等同于 :B=\"url\" //等同于 @B=\"change\" let A = 'B' 通过计算属性绑定class computed: { classObject() { return { active: this.isActive, text-danger: this.error } } } 通过对象绑定:style styleObject: { color: 'red', fontSize: '13px' } 依赖注入 为组件后代提供数据（provide） //提供静态数据 provide: { message: 'hello!' } //提供响应式数据 provide() { return { // 显式提供一个计算属性 message: computed(() => this.message) } } 获取上层组件提供的数据（inject） //声明需要的数据 inject: ['message'] //注入别名 inject: { message: { /* 本地属性名 */ from: 'message', // 注入来源名 当与原注入名同名时，这个属性是可选的 default: 'default' //注入默认值 } 内置组件 Transition v-enter-from 进入动画的起始状态 v-enter-active 进入动画的生效状态 v-enter-to 进入动画的结束状态 v-leave-from 离开动画的起始状态 v-leave-active 离开动画的生效状态 v-leave-to 离开动画的结束状态 //有名字的class名会以name为头 hello /* 进入和离开动画可以使用不同 持续时间和速度曲线。 */ .slide-fade-enter-active { transition: all 0.3s ease-out; } .slide-fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); } .slide-fade-enter-from, .slide-fade-leave-to { transform: translateX(20px); opacity: 0; } TransitionGroup 用于对 v-for 列表中的元素或组件的插入、移除和顺序改变添加动画效果。 每个元素都必须有一个独一无二的 key .list-move, /* 对移动中的元素应用的过渡 */ .list-enter-active, .list-leave-active { transition: all 0.5s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateX(30px); } /* 确保将离开的元素从布局流中删除 以便能够正确地计算移动的动画。 */ .list-leave-active { position: absolute; } Teleport 将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 Open Modal Hello from the modal! Close "},"vue/vue3.html":{"url":"vue/vue3.html","title":"vue3","keywords":"","body":" filters过滤器被删除 文件template下可以放多个根节点，而不像vue2只能放一个根节点 生命周期 onBeforeMount() 组件挂载之前被调用 onMounted() 组件挂载完成后执行 onBeforeUpdate() 组件更新完成前执行 onUpdated() 组件更新完成后执行 onBeforeUnmount() 组件在被卸载前调用 onUnmounted() 组件在被卸载后调用 onErrorCaptured() 捕获后代组件传递的错误时调用 onRenderTracked() 组件渲染过程中追踪到响应式依赖时调用 onRenderTriggered() 当响应式依赖的变更触发了组件渲染时调用 onActivated() KeepAlive -- 组件被插入到 DOM 中时调用 onDeactivated() KeepAlive -- 组件从 DOM 中被移除时调用 onServerPrefetch() 组件实例在服务器上被渲染之前调用 import { reactive,onBeforeMount,onMounted } from \"vue\" setup(){ onBeforeMount(()=>{}) onMounted(()=>{}) } vue3 功能介绍 副作用： 执行会直接或间接影响其他函数的执行 指令 //全局指令 createApp(App).directive('focus', { mounted(el,binding) { //生命周期名字换了 } }) 路由 import { useRouter,useRoute } from 'vue-router' const router = useRouter() //router == this.$router const route = useRoute() //route == this.$route 取值 路由模式 const router = createRouter({ history: createWebHistory(), //history模式 history: createWebHashHistory(), //hash模式 routes }) 声明式导航 自定义hooks 组合式函数约定用驼峰命名法命名，并以“use”作为开头 尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数 组合式函数中使用 ref() 将逻辑代码分离页面，写在外部的js文件中 //页面vue文件 import {getData} from './app.js' //引入逻辑js文件 setup(){ const obj = getData() return { obj } } //app.js文件 逻辑代码 import {onMouted} from \"vue\" function getData() // const obj = ref([]) cosnt obj = reactive({ list.[] }) onMouted(()=>{ obj.list = [1,2,3] }) return obj } exprot { getData } VNode 钩子 每个组件或html标签上，我们可以使用一些特殊的（文档没写的）钩子作为事件 onVnodeBeforeMount onVnodeMounted onVnodeBeforeUpdate onVnodeUpdated onVnodeBeforeUnmount onVnodeUnmounted CSS 功能 深度选择器 -- :deep() .a :deep(.b) {} css获取js变量 -- v-bind const theme = { color: 'red' } p { color: v-bind('theme.color'); } vue3 API介绍 app.config.globalProperties 注册能够被应用内所有组件实例访问到的全局属性的对象 app.config.globalProperties.mes = '111' this.$mes //111 reactive() 创建响应式对象 reactive参数不能是字符串或者数字，否则会警告 👎重新赋值一个新的对象会\"断开\"响应式 change import { reactive } from \"vue\" setup () { const obj = reactive({ //可以写多个reactive函数 myname: \"toing\" //类似data中的值 }) const data = reactive({}) //可以直接创建空对象、空数组 const handleClick = () => { //触发的方法 obj.myname = \"changeToing\" } return {obj,handleClick,data} //要返回 }, 快速赋值reactive const data = reactive({ a:null,b:null }) const setData = ()=>{ const info = {a:1,b:2} Object.assign(data,info) } shallowReactive() reactive() 的浅层作用形式 只有属性的值会被原样存储和暴露 ref 的属性不会被自动解包 isReactive() 检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理 ref 访问原生dom节点 import { ref } from \"vue\" setup () { const myref = ref() //创建ref函数 const handleClick = () => { //触发的方法 console.log(myref.value) } return {myref} }, ref() 接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向属性.value 当 ref 赋值或者被赋值 reactive 时，ref会被解包（响应栈地址改变） 当在某个响应式数组或 Map 这样的原生集合类型中时， ref 元素不会解包 此处默认省略了value 实际上refText.value--> change import { ref } from \"vue\" setup () { const refText= ref(\"kerwin\") //可以直接拦截字符串 const handleClick = () => { //触发的方法 refText.value = \"changeToing\" } return {refText,handleClick} }, isRef() 检查某个值是否为 ref isRef(foo) unref() 参数是 ref，则返回内部值，否则返回参数本身 val = isRef(val) ? val.value : val 计算的一个语法糖 function useFoo(x: number | Ref) { const unwrapped = unref(x) // unwrapped 现在保证为 number 类型 } shallowRef() ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。 只对 .value 的访问是响应式的 triggerRef() 强制触发依赖于一个浅层 ref 的副作用 , 通常在对浅引用(shallowRef)的内部值进行深度变更后使用 const shallow = shallowRef({ greet: 'Hello, world' }) // 这次变更不应触发副作用，因为这个 ref 是浅层的 shallow.value.greet = 'Hello, universe' // 打印 \"Hello, universe\" triggerRef(shallow) toRef() 基于响应式对象上的一个属性，创建一个对应的 ref。 创建的 ref 与其源属性保持同步，改变源属性的值将更新 ref 的值，反之亦然。 const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, 'foo') // 更改该 ref 会更新源属性 fooRef.value++ console.log(state.foo) // 2 // 更改源属性也会更新该 ref state.foo++ console.log(fooRef.value) // 3 toRefs() 把reactive里的每个属性，转化成ref对象，再通过...展开，变成多个ref对象 在template中，用ref语法，js中用reactive语法 -- import { reactive,toRefs } from \"vue\" setup () { const obj = reactive({ myname: \"toing\", myage:\"100\" }) return { ...toRefs(obj),//在template中不用写obj.了 } }, 将一个响应式对象转换为一个普通对象 普通对象的每个属性都是指向源对象相应属性的 ref 每个单独的 ref 都是使用 toRef() 创建的 从组合式函数中返回响应式对象时 , 使用它，外部可以解构/展开返回的对象而不会失去响应性： function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // 在返回时都转为 ref return toRefs(state) } // 可以解构而不会失去响应性 const { foo, bar } = useFeatureX() isProxy() 查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理 computed() 只读 const plusOne = computed(() => count.value + 1) 可写 const plusOne = computed({ get: () => count.value + 1, set: (val) => { count.value = val - 1 } }) 获取计算属性 plusOne.value readonly() 返回一个原值的只读代理 const copy = readonly(original) shallowReadonly() readonly() 的浅层作用形式 只有根层级的属性变为了只读 ref 的属性不会被自动解包 const state = shallowReadonly({ foo: 1, nested: { bar: 2 } }) // 更改状态自身的属性会失败 state.foo++ // ...但可以更改下层嵌套对象 isReadonly(state.nested) // false isReadonly() 检查传入的值是否为只读对象 watch() 监听器 //监听一个 const count = ref(0) watch(count, (count, prevCount) => {},{deep:true}) //监听多个 watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {}) immediate 立即触发回调 deep 深层级变更时触发回调 flush:‘post’ 回调中能访问被 Vue 更新后的 DOM props&emit props:['myname'] setup(props,{emit}){ const myname = props.myname //接受父组件数据 const handleClick=()=>{ emit(\"isShow\",11) //子传父 } return{myname,handleClick} } v-model:visible = visible emit(\"update:visible\", false); watch watch(()=>obj.name,(newValue,oldValue)=>{ console.log(newValue,oldValue) }) 依赖注入功能 provide() 提供一个值，可以被后代组件注入 import { ref, provide } from 'vue' import { fooSymbol } from './injectionSymbols' // 提供静态值 provide('foo', 'bar') // 提供响应式的值 const count = ref(0) provide('count', count) // 提供时将 Symbol 作为 key provide(fooSymbol, count) inject() 注入一个由祖先组件或整个应用 提供的值 import { inject } from 'vue' import { fooSymbol } from './injectionSymbols' // 注入值的默认方式 const foo = inject('foo') // 注入响应式的值 const count = inject('count') // 通过 Symbol 类型的 key 注入 const foo2 = inject(fooSymbol) // 注入一个值，若为空则使用提供的默认值 const bar = inject('foo', 'default value') // 注入时为了表明提供的默认值是个函数，需要传入第三个参数 const fn = inject('function', () => {}, false) 插槽 useSlots() / useAttrs() useSlots 和 useAttrs 是真实的运行时函数 与 setupContext.slots 和 setupContext.attrs 等价 import { useSlots, useAttrs } from 'vue' const slots = useSlots() //获取子插槽数据 const attrs = useAttrs() //透传 TypeScript 标注类型 props 标注类型 传递给 defineProps 的泛型参数本身不能是一个导入的类型 interface Props { foo: string bar?: number } const props = defineProps() Props 解构默认值 withDefaults 帮助程序为默认值提供类型检查 确保返回的 props 类型删除了已声明默认值的属性的可选标志 export interface Props { msg?: string labels?: string[] } const props = withDefaults(defineProps(), { msg: 'hello', labels: () => ['one', 'two'] }) 通过 响应性语法糖开启，这个需要手动开启 interface Props { name: string count?: number } // 对 defineProps() 的响应性解构 // 默认值会被编译为等价的运行时选项 const { name, count = 100 } = defineProps() emits 标注类型 带调用签名的类型字面量 // 运行时 const emit = defineEmits(['update:change', 'update']) // 基于类型 const emit = defineEmits() ref 标注类型 const year: Ref = ref('2020') //上下两个方法等同 const year = ref('2020') year.value = 2020 // 成功！ reactive 标注类型 不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 import { reactive } from 'vue' interface Book { title: string year?: number } const book: Book = reactive({ title: 'Vue 3 指引' }) computed 标注类型 const double = computed(() => { // 若返回值不是 number 类型则会报错 }) 事件处理函数 标注类型 function handleChange(event: Event) { (event.target as HTMLInputElement).value } provide / inject 标注类型 provide 提供 InjectionKey 接口，继承自 Symbol 的泛型类型 , 用来在提供者和消费者之间同步注入值的类型 key 的类型放在单独的文件中，这样可以被多个组件导入 import { provide, inject } from 'vue' import type { InjectionKey } from 'vue' const key = Symbol() as InjectionKey provide(key, 'foo') // 若提供的是非字符串值会导致错误 inject // 第二个bar为默认值，没有的话类型则是 string | undefined const foo = inject('foo', 'bar') const foo = inject('foo') as string //强制转换类型 模板引用 标注类型 import { ref, onMounted } from 'vue' const el = ref(null) onMounted(() => { el.value?.focus() }) 组件模板引用 标注类型 如果想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的 Takeover 模式。 defineExpose ----> [组件暴露出自己的属性] import { ref } from 'vue' const isContentShown = ref(false) const open = () => (isContentShown.value = true) defineExpose({ //定义暴露 open }) 为了获取 MyModal 的类型，需要通过 typeof 得到类型，再使用 TypeScript 内置的 InstanceType 工具类型获取实例类型 import MyModal from './MyModal.vue' const modal = ref | null>(null) const openModal = () => { modal.value?.open() } "},"vue/uniApp.html":{"url":"vue/uniApp.html","title":"uniApp","keywords":"","body":"uniApp 注意事项 可以直接使用defineProps接收页面传参 vscode开发 插件 uni-create-view 右键目录文件夹快速创建页面与组建，自动创建路由 uni-helper 代码提示安装包 uniapp小程序扩展 组件内容悬停展示 ts类型校验 ctrl+i 代码提示 //安装小程序类型声明文件 npm install -D @types/wechat-miniprogram //uniapp类型声明文件 npm install -D @uni-helper/uni-app-types //uni-ui 类型声明文件 -- 非官方 npm install -D @uni-helper/uni-ui-types \"compilerOptions\": { \"types\": [ \"@dcloudio/types\", \"@types/wechat-miniprogram\", \"@uni-helper/uni-app-types\", \"@uni-helper/uni-ui-types\" ] }, \"vueCompilerOptions\": { \"nativeTags\": [\"block\", \"component\", \"template\", \"slot\"] }, 解决json文件注释问题 一般情况下,仅允许下面两个文件添加注释 pinia持久化 // 创建 pinia 实例 const pinia = createPinia() // 使用持久化存储插件 pinia.use(persist) // TODO: 持久化 { persist: { storage: { getItem(key) { return uni.getStorageSync(key) }, setItem(key: any, value) { uni.setStorageSync(key, value) }, } }, }, uniapp 类型 uniHelper. 相关类型 注册组件实例类型 import XtxGuess from '@/components/XtxGuess.vue' // 组件实例类型 export type XtxGuessInstance = InstanceType 生成骨架屏 微信开发者工具提供了自动生成骨架屏代码的能力。 使用时需要把自动生成的 xxx.skeleton.vue 和 xxx.skeleton.wxss 封装成 vue 组件 "},"vue/vuex.html":{"url":"vue/vuex.html","title":"vuex","keywords":"","body":"vuex 文档地址 vue devtools 小工具 vuex 默认管理在内存，刷新页面后公共状态会丢失 vuex 持久化 todo 后端数据的缓存快照，较少重复数据请求 actions、mutations 中的方法可以相互调用 vue2 state import { mapState,mapActions,mapMutations } from 'vuex' state:{id:1} //公共状态 类似data this.$store.state.id //查看state的公共状态 this.id //查看state的公共状态 computed: { ...mapState(['id']) ...mapState({ //取别名 userId:(state) => state.id }) } getters getters:{ //类似计算属性 getdoosId:state.id=>(id)=>{ return state.id == id ? true :false } } computed: { ...mapGetter(['getdoosId']) } actions actions:{ //支持异步和同步 requert（store, data）{} //store 下面的为解构的 requert（{ commit, state }, data）{ http().then(id=>{ //异步请求 commit.changeId(id) //实质上还是通过store.commit,更改state值 }) } } this.$store.dispatch('requert',data )//触发actions方法 分发 this.$store.dispatch('requert',data ).then()//有返回值，就可以then this.requert(data) //同上面分发语法一致 methods: { ...mapActions([ 'requert', ]), } mutations mutations:{ //统一管理，可以被devtools记录 只支持同步函数 changeId(state,enterId){ state.id = enterId //更改state的公共状态 } } this.$store.commit('changeId',2) //触发mutations方法 交付 import { mapMutations } from 'vuex' this.changeId(2) // 同上面交付语法一致 methods: { ...mapMutations([ 'changeId', ]), } modules 将需要写的内容模块化出去 namespaced //命名空间 当有多个模块时，需要定义命名空间 import demo from './demo' export default new Vuex.Store({ modules:{ demo //模块的名称 } ) Vuex 持久化 vuex-persistedstate vuex-persist npm 1 vuex-persistedstate --save //安装 import createPersistedState from \"vuex-persistedstate\" //在需要的地方安装使用 const store =newVuex.Store({ plugins: [createPersistedState()] //缓存vuex所有数据 plugins: [createPersistedState({ //缓存配置 storage:'localStorage', //存储的位置 key:'vuexData', //键位名字，默认vuex reducer:(state){ //需要保存的值。默认情况下，保存整个状态。 id:state.id } })] }) vue3 import { useStore } from 'vuex' //引入逻辑js文件 setup(){ const store = useStore() //store == this.$store const count = computed(() => store.state.count), const double = computed(() => store.getters.double) const increment = () => store.commit('increment'), const asyncIncrement = () => store.dispatch('asyncIncrement') } TypeScript // store.ts import { InjectionKey } from 'vue' import { createStore, useStore as baseUseStore, Store } from 'vuex' export interface State { count: number } export const key: InjectionKey> = Symbol() export const store = createStore({ state: { count: 0 } }) // 定义自己的 `useStore` 组合式函数 export function useStore () { return baseUseStore(key) } // main.ts import { createApp } from 'vue' import { store, key } from './store' const app = createApp({ ... }) // 传入 injection key app.use(store, key) app.mount('#app') // vue 组件 import { useStore } from './store' export default { setup () { const store = useStore() store.state.count // 类型为 number } } "},"vue/pinia.html":{"url":"vue/pinia.html","title":"pinia","keywords":"","body":"pinia 定义store 可以对defineStore的返回值进行任意命名 最好以 use 开头且以 Store 结尾。比如：useUserStore defineStore 的第二个参数可接受两类值：Setup 函数 和 Option 对象 import { defineStore } from 'pinia' // 第一个参数是你的应用中 Store 的唯一 ID。 export const useStore = defineStore('main', {}) 对象 类型 export const useCounterStore = defineStore('counter', { state: () => ({ count: 0 }), getters: { double: (state) => state.count * 2, }, actions: { increment() { this.count++ }, }, }) 函数 类型 export const useCounterStore = defineStore('counter', () => { const count = ref(0) const plusOne = computed(() => count.value + 1) function increment() { count.value++ } return { count, increment } }) 响应式解构(storeToRefs) 使用 storeToRefs 将为每一个响应式属性创建引用 同时会跳过任何 action 或非响应式(非 ref/响应式)属性 const { name, doubleCount } = storeToRefs(store) State 定义为一个返回初始状态的函数， 可以同时支持服务端和客户端。 //对象类型 state: () => { return { // 所有这些属性都将自动推断出它们的类型 count: 0, name: 'Eduardo', } }, //函数类型 const count = ref(0) TypeScript interface State { name: string age: number } const useStore = defineStore('storeId', { state: (): State => { return { name: '123', age: 123, } }, }) 访问 通过 store 实例访问 state，直接对其进行读写 const store = useStore() store.count++ computed: { // 与从 store.count 中读取的数据相同 ...mapState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapState(useCounterStore, { myOwnName: 'count', // 你也可以写一个函数来获得对 store 的访问权 double: store => store.count * 2, // 它可以访问 `this`，但它没有标注类型 magicValue(store) { return store.someGetter + this.count + this.double }, }), }, 重置 -- $reset() 调用 store 的 $reset() 方法将 state 重置为初始值 const store = useStore() store.$reset() 变更/替换 -- $patch 补丁对象在同一时间更改多个属性 const store = useStore() store.$patch({ count: store.count + 1, age: 120, }) 函数方法来修改元素集合 store.$patch((state) => { state.items.push({ name: 'shoes', quantity: 1 }) state.hasChanged = true }) 访问修改 -- 函数类型 -- mapWritableState() computed: { // 可以访问组件中的 this.count，并允许设置它。 ...mapWritableState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapWritableState(useCounterStore, { myOwnName: 'count', }), }, this.count++ //修改state.count属性 订阅 -- $subscribe() 更改内容后，触发一次 const cartStore = useSomeStore() cartStore.$subscribe((mutation, state) => { mutation.type // 和 cartStore.$id 一样 mutation.storeId // 'cart' // 只有 mutation.type === 'patch object'的情况下才可用 mutation.payload // 传递给 cartStore.$patch() 的补丁对象。 // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem('cart', JSON.stringify(state)) }) 当组件被卸载时，将被自动删除 组件卸载后依旧保留它们，将 { detached: true } 作为第二个参数，将 state subscription 从当前组件中分离 const someStore = useSomeStore() // 在组件被卸载后，该订阅依旧会被保留。 someStore.$subscribe(callback, { detached: true }) 可以直接在pinia实例上侦听整个state watch( pinia.state, (state) => { // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem('piniaState', JSON.stringify(state)) }, { deep: true } ) Getter typescript 必须设置函数返回类型 可以 通过 this 访问到整个 store 实例 //对象类型 getters: { doubleCount(state) { return state.count * 2 }, doublePlusOne(): number { return this.doubleCount + 1 }, }, //函数类型 const plusOne = computed(() => count.value + 1) 访问 const store = useStore() store.doubleCount computed: { ...mapGetter(useCounterStore, ['count']) }, 访问其他store中的getter import { useOtherStore } from './other-store' getters: { otherGetter(state) { const otherStore = useOtherStore() }, }, Action 通过 this 访问整个 store 实例 action可以是异步的 actions: { async increment() { const preferences = await fetchPreferences() this.count++ }, }, function increment() { count.value++ } 访问 const main = useMainStore() main.randomizeCounter() const store = useStore() store.randomizeCounter() methods: { ...mapActions(useCounterStore, ['increment']) // 与上述相同，但将其注册为this.myOwnName() ...mapActions(useCounterStore, { myOwnName: 'doubleCount' }), }, 访问其他 store 的 action import { useAuthStore } from './auth-store' actions: { fetch() { const auth = useAuthStore() } }, 订阅 -- $onAction() 监听 action 和它们的结果 after 表示在 promise 解决后，在 action 解决后执行回调函数 nError 在 action 抛出错误或 reject 时执行回调函数 const unsubscribe = someStore.$onAction( ({ store, // store 实例，类似 `someStore` args, // 传递给 action 的参数数组 after, // 在 action 返回或解决后的钩子 onError, // action 抛出或拒绝的钩子 }) => { // 这将在 action 成功并完全运行后触发。 // 它等待着任何返回的 promise after((result) => {}) // 如果 action 抛出或返回一个拒绝的 promise，这将触发 onError((error) => {}) } ) // 手动删除监听器 unsubscribe() 当组件被卸载时，将被自动删除 组件卸载后依旧保留它们，将 { detached: true } 作为第二个参数，将 state subscription 从当前组件中分离 const someStore = useSomeStore() // 在组件被卸载后，该订阅依旧会被保留。 someStore.$onAction(callback, true) Plugins 给所有的store批量添加属性、方法等 任何由插件返回的属性都会被 devtools 自动追踪 state 变更或添加(包括调用 store.$patch())都是发生在 store 被激活之前，不会触发订阅函数 import { createPinia } from 'pinia' // 在安装此插件后创建的每个 store 中都会添加一个名为 `secret` 的属性。 // 注册插件（本质上是一个有返回值的函数） function SecretPiniaPlugin(context) { context.pinia // 用 `createPinia()` 创建的 pinia。 context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。 context.store // 该插件想扩展的 store context.options // 定义传给 `defineStore()` 的 store 的可选对象。 // ... } const pinia = createPinia() // 将该插件交给 Pinia pinia.use(SecretPiniaPlugin) // 在另一个文件中 const store = useStore() store.secret // 'the cake is a lie' 插件中调用 -- $subscribe 可以在插件中使用 store.$subscribe 和 store.$onAction pinia.use(({ store }) => { store.$subscribe(() => { // 响应 store 变化 }) store.$onAction(() => { // 响应 store actions }) }) TypeScript 标注插件类型 import { PiniaPluginContext } from 'pinia' export function myPiniaPlugin(context: PiniaPluginContext) { // ... } 导航守卫中使用 import { createRouter } from 'vue-router' const router = createRouter({}) router.beforeEach((to) => { const store = useStore() if (to.meta.requiresAuth && !store.isLoggedIn) return '/login' }) pinia-plugin-persistedstate 状态持久化 pinia-plugin-persistedstate import { defineStore,createPinia } from 'pinia' defineStore('store', { state: () => ({ saved: '' }), persist:{ key:'menuList',//存储的键值 storgae:'localStorage',//存储的类型[localStorage | sessionStorage] paths:['saved'], //指定存储的值 }, }) const pinia = createPinia(); pinia.use(piniaPluginPersistedstate); "},"vue/vue补充.html":{"url":"vue/vue补充.html","title":"vue 补充","keywords":"","body":"vue 中动态引入图片为什么要是 require 为什么无法编译？ 动态引入时,编译的是 src 后面的变量，就导致与图片资源编译过后的资源地址不一致， 导致无法正确的引入资源 为什么加上 require 就好了? 通过 require 方法拿到的文件地址，是资源文件编译过后的文件地址 静态的引入时，为什么返回的是编译过后的文件地址？ 在 webpack 编译的 vue 文件的时候，遇见 src 等属性会默认的使用 require 引入资源路径 "},"vue/Dome/瀑布流.html":{"url":"vue/Dome/瀑布流.html","title":"瀑布流","keywords":"","body":"瀑布流 vue3 + Gaid const data = [ { height: 160, color: \"#ef3429\" }, ] .masonry { width: 230px; display: grid; grid-template-columns: repeat(auto-fill, 50px); column-gap: 10px; row-gap: 1px; } vue2 + flex import data from \"./data.json\"; export default { data() { let data1 = [], //第一列 data2 = [], //第二列 data3 = [], //第三列 i = 0; while (i .masonry { display: flex; flex-direction: row; .colmun { display: flex; flex-direction: column; flex: 1; padding: 0 2px; .item { margin-bottom: 5px; width: 100%; } } } "},"vue/Dome/SSR.html":{"url":"vue/Dome/SSR.html","title":"SSR","keywords":"","body":"SSR "},"vue/Dome/websocket.html":{"url":"vue/Dome/websocket.html","title":"websocket","keywords":"","body":"websocket "},"vue/Dome/storage封装.html":{"url":"vue/Dome/storage封装.html","title":"storage 封装","keywords":"","body":"storage 文章地址 const config = { type: \"loaclStorage\",// 本地存储类型 localStorage/sessionStorage prefix: 'CBD_1.0.0',// 名称前缀 建议：项目名 + 项目版本 expire: 60 * 60 * 24 * 30,//过期时间 单位：秒 isEncrypt: true, // 是否加密 } interface indexObj { [key: string]: any } // 名称前自动添加前缀 function autoAddPrefix(key: string) { const prefix = config.prefix ? config.prefix + '_' : ''; return prefix + key; } // 移除已添加的前缀 function autoRemovePrefix(key: string) { const len: number = config.prefix ? config.prefix.length + 1 : 0; return key.substr(len); } // 设置storage // { key:键值,value:数据,expire:过期时间,noRenewal:是否不续期 } export function setStorage(key: string, value: any, expire?: number, noRenewal?: boolean) { if (!value) value = null expire = (expire ? expire : config.expire) * 1000 let data: (object | string) = { value: value,//存储值 time: Date.now(),//存储时间戳 expire: expire, //过期时间 noRenewal, } data = JSON.stringify(data); key = autoAddPrefix(key); // if (config.isEncrypt) data = encrypt(data) //加密 (window)[config.type].setItem(key, data) } // 获取storage // { key:键值 } export function getStorage(key: string) { key = autoAddPrefix(key) let data = (window)[config.type].getItem(key) if (!data || JSON.stringify(data) === \"null\") return null // if (config.isEncrypt) data = decrypt(data) //解密 const nowTime = Date.now() if (data.expire && data.expire window)[config.type].removeItem(autoAddPrefix(key)); } // 清空 clearStorage export const clearStorage = () => { (window)[config.type].clear(); } // 判断是否可用 JSON.parse export function isJson(value: any) { if (Object.prototype.toString.call(value) === '[object String]') { try { const obj = JSON.parse(value); const objType = Object.prototype.toString.call(obj); return objType === '[object Object]' || objType === '[object Array]'; } catch (e) { return false; } } return false; } // 派发storage的数据变化 export function dispatchEventStroage() { const signSetItem = localStorage.setItem localStorage.setItem = function (key, val) { signSetItem.apply(this, arguments) //更改setItem的this指向，arguments传入的参数数组（name,value） let setEvent: any = new Event('setItemEvent') //构造函数 setEvent.key = key setEvent.value = val window.dispatchEvent(setEvent) //发送事件到监听器上 } } // 监听storage的数据变化 // window.addEventListener(\"setItemEvent\", function (e: any) { // const newdata = JSON.parse(e.value); // }); "},"vue/Dome/web分页搜索存储.html":{"url":"vue/Dome/web分页搜索存储.html","title":"web 分页搜索存储","keywords":"","body":"web 分页搜索存储 vue2+ts+Mixins import { Component, Vue } from 'vue-property-decorator'; //页面分页信息保存 interface pagingInt { name: string; pagingInfo: object; } @Component export default class PagingStroage extends Vue { pageObj: any; //对页面分页和过滤进行存储 filters: any; newPageObj: any; filterConfig: any; created() { this.getStoragePagingInfo(); } beforeDestroy() { this.setStoragePagingInfo(); } pageRoute: any = null; //设置当前页码分页信息 getStoragePagingInfo() { this.pageRoute = this.$route; //获取当前分页信息 const pagingInfo = this.getStoragePaging(this.pageRoute); if (!pagingInfo) return; //将存储的分页信息赋值给pageObj if (pagingInfo.pageObj) { this.pageObj = { ...this.pageObj, ...pagingInfo.pageObj }; } //处理存储的过滤信息，并且赋值 if (pagingInfo.filters) { this.filters = { ...this.filters, ...pagingInfo.filters }; for (let key in pagingInfo.filters) { const value = pagingInfo.filters[key]; if (this.filterConfig[key]) { this.filterConfig[key].value = value; } if (key === 'endTime' || key === 'startTime') { this.filterConfig.date.option[key].value = value; } } } } //存储当前分页信息 setStoragePagingInfo() { if (!this.newPageObj) return; let pagingInfo: any = { pageObj: this.newPageObj.current || this.newPageObj.pageSize ? this.newPageObj : null, filters: this.filters || null, }; this.setStoragePaging(this.pageRoute, pagingInfo); } //获取分页信息 getStoragePaging(route: any) { let dataJson: any = window.sessionStorage.getItem('pagingInfo'); let data: pagingInt[] = dataJson ? JSON.parse(dataJson) : []; if (data.length > 0 && route) { let pagingInfo: any = null; let newData: pagingInt[] = []; data.forEach((item: pagingInt) => { if (item.name === route.name) { pagingInfo = item; } else { newData.push(item); } }); if (newData.length > 0) { window.sessionStorage.setItem( 'pagingInfo', JSON.stringify(newData) ); } else { window.sessionStorage.removeItem('pagingInfo'); } if (pagingInfo) { return pagingInfo.pagingInfo; } } return null; } //设置分页信息 setStoragePaging(route: any, pagingInfo: object) { if (!pagingInfo) return; const newData: pagingInt = { name: route.name, pagingInfo, }; let data: any = window.sessionStorage.getItem('pagingInfo'); data = data ? JSON.parse(data) : []; data = [...data, newData]; window.sessionStorage.setItem('pagingInfo', JSON.stringify(data)); } } //清空分页信息 export function removeStoragePaging() { setTimeout(() => { window.sessionStorage.removeItem('pagingInfo'); }, 0); } "},"vue/Dome/虚拟列表.html":{"url":"vue/Dome/虚拟列表.html","title":"虚拟列表","keywords":"","body":"虚拟列表 InfiniteList.vue import { ref, computed, nextTick, reactive, watchEffect, onUnmounted } from 'vue' const props = defineProps }>() // 列表HTMLElementDom const ulRef = ref(null) // 屏幕高度 const screenH = document.documentElement.clientHeight const data = reactive({ // 列表第一项的高度（起始高度） initH: 0, // 一行的高度 unitH: 0, // 屏幕范围内能显示个数 displayCount: 1, // 列表起始值 startIdx: 0 }) const listData = computed(() => { let endIdx = data.startIdx + data.displayCount if (endIdx >= props.listData.length) endIdx = props.listData.length return props.listData.slice(data.startIdx, endIdx).map((v, k) => { v.idx = data.startIdx + k + 1 return v }) }) function scrollHandler() { // 当前滚动高度 const curScrollTop = document.documentElement.scrollTop if (curScrollTop > data.initH) { const addCount = Math.floor((curScrollTop - data.initH) / data.unitH) ulRef.value.style.setProperty('padding-top', `${addCount * data.unitH}px`) data.startIdx = addCount } else { ulRef.value.style.setProperty('padding-top', '0px') data.startIdx = 0 } } watchEffect(() => { if (props.listData.length > 0) { nextTick(() => { // 列表距离顶部距离 data.initH = ulRef.value.getBoundingClientRect().top + document.documentElement.scrollTop // 计算每行高度 data.unitH = ulRef.value.children[0].offsetHeight // 计算屏幕内能显示的行数 data.displayCount = Math.ceil(screenH / data.unitH) // 设置列表总高度 = 一行高度 * 行数 const listH = data.unitH * props.listData.length ulRef.value.style.setProperty('height', `${listH}px`) window.removeEventListener('scroll', scrollHandler) window.addEventListener('scroll', scrollHandler) }) } }) onUnmounted(() => { window.removeEventListener('scroll', scrollHandler) }) .ulRef { box-sizing: border-box } list.vue 111 sfas 0\" :listData=\"songs\"> {{ listItem.idx }}{{ listItem.name }} import { reactive, ref, onMounted } from 'vue'; import InfiniteList from '@comp/InfiniteList/index.vue' import { TestList } from \"@api/Test\" let songs = ref([]) // 列表数据 const getTestList = async () => { let res = await TestList() songs.value = res.list console.log(songs.value.length > 0) } getTestList() "},"vue/Dome/二维码显示.html":{"url":"vue/Dome/二维码显示.html","title":"二维码显示","keywords":"","body":"二维码显示 //hint 二维码所需地址 import VueQrcode from \"@chenfengyuan/vue-qrcode\"; "},"vue/Dome/canvas图片导出.html":{"url":"vue/Dome/canvas图片导出.html","title":"canvas 图片导出","keywords":"","body":"canvas 图片导出 import html2canvas from \"html2canvas\"; const imgUrl = ref(\"\"); const sharePage: any = ref(null);//ref 获取节点 const save = () => { //将ref获取到的节点的内容转换成bese64图片格式 html2canvas(sharePage.value, { useCORS: true }).then((canvas) => { let dataURL = canvas.toDataURL(\"image/png\"); imgUrl.value = dataURL; }); }; "},"vue/Dome/表格导出.html":{"url":"vue/Dome/表格导出.html","title":"表格导出","keywords":"","body":"表格导出 import { Component, Ref, Prop, Vue, Watch, } from \"vue-property-decorator\"; import { Columns } from \"@/components/types/ATable\"; import FileSaver from \"file-saver\"; //将表格保存电脑 import XLSX from \"xlsx\"; //转换为表格格式 @Component export default class ExportModal extends Vue { @Ref() readonly tableExport!: any; @Prop({ type: String, default: \"导出列表\", }) title!: string; // 导出列表 名称 @Prop({ type: Array as () => Columns, default: () => { return [{}]; }, }) columns!: Columns; @Prop({ type: [Array, Function], required: true, }) getTable!: Array | Function; @Prop({ type: Boolean, default: false, }) visible!: boolean; @Watch(\"visible\", { immediate: true, }) async onVisibleChange() { if (this.visible) { this.timer = null; } } timer:any = null; loading:boolean = true; done(){ let that = this; this.timer = window.setTimeout(function(){ that.handleExport(); },2000) } // 导出数据 handleExport() { // 获取表格元素 let els = this.$refs.tableExport; /* 或者用id */ let wb = XLSX.utils.table_to_book(document.getElementById(\"tableExport\")) /* get binary string as output */ let wbout = XLSX.write(wb, { bookType: \"xlsx\", bookSST: true, type: \"array\", }); // 文件名 let filename = `${this.title}.xlsx`; try { FileSaver.saveAs( new Blob([wbout], { type: \"application/octet-stream\" }), filename ); } catch (e) { console.log(e); } this.loading = false; this.onCancel(); return wbout; } onCancel() { window.clearTimeout(this.timer); this.$emit(\"update:visible\", false); } } "},"vue/Dome/css-日夜按钮.html":{"url":"vue/Dome/css-日夜按钮.html","title":"css-日夜按钮","keywords":"","body":" import { reactive, ref } from 'vue'; const active = ref(false) const changeBtn = ()=>{ active.value = !active.value } body { background: #d9deea; } div { position: relative; width: 220px; height: 90px; background: radial-gradient(circle at 18% 20px, #fff, #fff 6px, transparent 7px, transparent), radial-gradient(circle at 35% 45px, #fff, #fff 1px, transparent 2px, transparent), radial-gradient(circle at 10% 70px, #fff, #fff 2.5px, transparent 3.5px, transparent), radial-gradient(circle at 25% 15px, #fff, #fff 3px, transparent 4px, transparent), radial-gradient(circle at 15% 50px, #fff, #fff 1.5px, transparent 2.5px, transparent), radial-gradient(circle at 30% 75px, #fff, #fff 5px, transparent 6px, transparent), radial-gradient(circle at 5% 30px, #fff, #fff 0.5px, transparent 1.5px, transparent), radial-gradient(circle at 25% 60px, #fff, #fff 0.5px, transparent 1.5px, transparent), radial-gradient(circle at 7% 35px, #fff, #fff 0.5px, transparent 1.5px, transparent), linear-gradient(90deg, #2b303e, #2b303e 50%, #5a81b4 50%, #5a81b4); background-repeat: no-repeat; background-size: 200% 100%; background-position: 100% 0; border-radius: 90px; box-shadow: 0 -3px 4px #999, inset 0 3px 5px #333, 0 4px 4px #ffe, inset 0 -3px 5px #ddd; cursor: pointer; overflow: hidden; transition: .5s all; &::before, &::after { content: \"\"; position: absolute; transition: .5s all; } &::before { width: 75px; height: 75px; border-radius: 50%; background: #e9cb50; inset: 7.5px; box-shadow: 0 0 5px #333, inset 2px 2px 3px #f8f4e4, inset -2px -2px 3px #665613; z-index: 1; } &::after { width: 70px; height: 70px; inset: 10px; border-radius: 50%; box-shadow: 10px 60px 0 10px #fff, 65px 60px 0 5px #fff, 95px 70px 0 10px #fff, 135px 45px 0 5px #fff, 170px 35px 0 10px #fff, 195px -5px 0 10px #fff, -10px 0 0 50px rgba(255, 255, 255, .2), 15px 0 0 50px rgba(255, 255, 255, .15), 40px 0 0 50px rgba(255, 255, 255, .21), 10px 40px 0 10px #abc1d9, 70px 35px 0 10px #abc1d9, 95px 40px 0 10px #abc1d9, 135px 20px 0 10px #abc1d9, 155px 15px 0 10px #abc1d9, 190px -20px 0 10px #abc1d9; } } div:hover::before { filter: contrast(90%) brightness(110%); scale: 1.05; } div.active { background-position: 0 0; &::before { translate: 130px; background: radial-gradient(circle at 50% 20px, #939aa5, #939aa5 6.5px, transparent 7px, transparent), radial-gradient(circle at 35% 45px, #939aa5, #939aa5 11.5px, transparent 12px, transparent), radial-gradient(circle at 72% 50px, #939aa5, #939aa5 8.5px, transparent 9px, transparent), radial-gradient(#cbcdda, #cbcdda); } &::after { transform: translate(130px); box-shadow: 10px 60px 0 10px transparent, 65px 60px 0 5px transparent, 95px 70px 0 10px transparent, 135px 45px 0 5px transparent, 170px 35px 0 10px transparent, 195px -5px 0 10px transparent, 10px 0 0 50px rgba(255, 255, 255, .2), -15px 0 0 50px rgba(255, 255, 255, .15), -40px 0 0 50px rgba(255, 255, 255, .21), 10px 40px 0 10px transparent, 70px 35px 0 10px transparent, 95px 40px 0 10px transparent, 135px 20px 0 10px transparent, 155px 15px 0 10px transparent, 190px -20px 0 10px transparent; } } "},"vue/Dome/request.html":{"url":"vue/Dome/request.html","title":"request","keywords":"","body":"axios vue2+ts import axios, { AxiosInstance, AxiosPromise, AxiosRequestConfig, AxiosResponse, } from 'axios'; axios.defaults.withCredentials = true; declare type Methods = | 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH'; /** * transformRequest 函数数组 */ interface Config { data?: any; params?: any; url?: string; headers?: any; responseType?: string; transformRequest?: Array; } export default class Request { private instance: AxiosInstance | null = null; constructor() { if (this.instance === null) { this.instance = axios.create({ baseURL: process.env.VUE_APP_URL, timeout: 50000, // request timeout }); this.initInterceptors(); } } /** * 初始化请求响应的拦截器 */ private initInterceptors(): void { this.instance!.interceptors.request.use( (config: AxiosRequestConfig) => { return config; }, error => { Promise.reject(error); } ); this.instance!.interceptors.response.use( (response: AxiosResponse) => { return response; }, error => { return error; } ); } createAPI(url: string, method: Methods, data: any = {}): AxiosPromise { const config: Config = {}; if (method === 'get' || method === 'GET') { config.params = data; } else { config.data = data; } return this.instance!(Object.assign(config as any, { method, url })); } createFormAPI( url: string, method: Methods, data: any = {}, responseType?: string ) { if (!responseType) { responseType = 'json'; } const config: Config = { data: data, headers: { 'Content-Type': 'application/x-www-form-urlencoded', }, responseType, transformRequest: [], }; config.transformRequest = [ function (data: { [x: string]: string | number | boolean }) { let ret = ''; for (const key in data) { ret += `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}&`; } return ret; }, ]; return this.instance!(Object.assign(config as any, { method, url })); } } vue3+ts import axios, { AxiosInstance, AxiosError, AxiosRequestConfig, AxiosResponse, AxiosPromise, } from \"axios\"; import qs from \"qs\"; import router from \"@/routers\"; import { GlobalStore } from \"@/stores\"; import { ElMessage } from \"element-plus\"; import { checkStatus } from \"@utils/index\"; import { ResultEnum } from \"./enum\"; const config = { // 默认地址请求地址，可在 .env.*** 文件中修改 baseURL: import.meta.env.VITE_API_URL as string, // 设置超时时间（10s） timeout: ResultEnum.TIMEOUT as number, // 跨域时候允许携带凭证 withCredentials: true, }; class RequestHttp { service: AxiosInstance; public constructor(config: AxiosRequestConfig) { // 实例化axios this.service = axios.create(config); /** * @description 请求拦截器 * 客户端发送请求 -> [请求拦截器] -> 服务器 * token校验(JWT) : 接受服务器返回的token,存储到vuex/pinia/本地储存当中 */ this.service.interceptors.request.use( (config: AxiosRequestConfig): any => { const globalStore = GlobalStore(); const token = globalStore.token; const sessionId = globalStore.sessionId; return { ...config, headers: { ...config.headers, token, sessionId }, }; }, (error: AxiosError) => { return Promise.reject(error); } ); /** * @description 响应拦截器 * 服务器换返回信息 -> [拦截统一处理] -> 客户端JS获取到信息 */ this.service.interceptors.response.use( (response: AxiosResponse) => { const { data } = response; const globalStore = GlobalStore(); // * 登陆失效（code == 401） if (data.code == ResultEnum.OVERDUE) { ElMessage.error(data.msg); globalStore.setToken(\"\"); router.replace(\"/login\"); return Promise.reject(data); } // * 全局错误信息拦截（防止下载文件得时候返回数据流，没有code，直接报错） if (data.code && data.code !== ResultEnum.SUCCESS) { ElMessage.error(data.msg); return Promise.reject(data); } // * 成功请求（在页面上除非特殊情况，否则不用在页面处理失败逻辑） return data; }, async (error: AxiosError) => { const { response } = error; // 请求超时 && 网络错误单独判断，没有 response if (error.message.indexOf(\"timeout\") !== -1) ElMessage.error(\"请求超时！请您稍后重试\"); if (error.message.indexOf(\"Network Error\") !== -1) ElMessage.error(\"网络错误！请您稍后重试\"); // 根据响应的错误状态码，做不同的处理 if (response) checkStatus(response.status); // 服务器结果都没有返回(可能服务器错误可能客户端断网)，断网处理:可以跳转到断网页面 if (!window.navigator.onLine) router.replace(\"/500\"); return Promise.reject(error); } ); } // * 常用请求方法封装 get(url: string, params?: object): AxiosPromise { return this.service.get(url, { params }); } post(url: string, params?: object): AxiosPromise { return this.service.post(url, params); } formPost(url: string, params?: object): AxiosPromise { return this.service.post(url, qs.stringify(params)); } } export default new RequestHttp(config); uni-app /* * @Author: xiangzhenxing * @Date: 2024-01-05 16:00:05 * @LastEditors: xiangzhenxing * @LastEditTime: 2024-04-26 16:55:42 * @Description:请求包装 */ import { ResultEnum } from './enum' import { GlobalStore } from '@/stores/index' import type { BaseResponse, OptionsInt } from '@interfaces/request' import router from '@utils/router' const globalStore = GlobalStore() const config = { // 设置超时时间（10s） timeout: ResultEnum.TIMEOUT as number, // 跨域时候允许携带凭证 withCredentials: true, } const requestInterceptor = { invoke(options: OptionsInt) { const token = globalStore.token if (token) { options.header = { token: token, ...options.header } } const baseUrl = import.meta.env.VITE_API_URL options.url = baseUrl + options.url options = { ...options, ...config } if (options.showLoading) { uni.showLoading({ title: '加载中', }) } }, } uni.addInterceptor('request', requestInterceptor) let uniRequest: UniApp.RequestTask | null = null const loginRoutePath: string = '/pages/login/index' const request = async (data: any) => { try { const requestInfo: UniApp.RequestSuccessCallbackResult | UniApp.RequestTask = await uni.request( { ...data }, ) uniRequest = requestInfo as UniApp.RequestTask const res: BaseResponse = (requestInfo as UniApp.RequestSuccessCallbackResult) .data as BaseResponse uni.hideLoading() // 登录失效 if (res.code === ResultEnum.OVERDUE || res.code === ResultEnum.Unauthorized) { uni.showToast({ title: res.msg, duration: 5000, icon: 'error', }) console.log('清楚了数据') await globalStore.clearStore() router.replace(loginRoutePath) return Promise.reject(res) } return Promise.resolve(res) } catch (error: any) { if (data.showLoading) uni.hideLoading() return Promise.reject(error) } } // 打断请求 export const controllerCancelFn = () => { uniRequest!.abort() } class requestMethod { get(url: string, showLoading: boolean = false, params?: object): Promise> { const data = { url, method: 'GET', data: params, showLoading, } return request(data) } post(url: string, showLoading: boolean = false, params?: object): Promise> { const data = { url, method: 'POST', data: params, showLoading, header: { 'content-type': 'application/json', }, } return request(data) } formPost( url: string, showLoading: boolean = false, params?: object, ): Promise> { const data = { url, method: 'POST', data: params, showLoading, header: { 'content-type': 'application/x-www-form-urlencoded', }, } return request(data) } } export default new requestMethod() 配置文件 export enum ResultEnum { SUCCESS = \"200\", ERROR = \"500\", OVERDUE = \"401\", TIMEOUT = 30000, TYPE = \"success\", } export const checkStatus = (status: number): void => { switch (status) { case 400: ElMessage.error(\"请求失败！请您稍后重试\"); break; case 401: ElMessage.error(\"登录失效！请您重新登录\"); break; case 403: ElMessage.error(\"当前账号无权限访问！\"); break; case 404: ElMessage.error(\"你所访问的资源不存在！\"); break; case 405: ElMessage.error(\"请求方式错误！请您稍后重试\"); break; case 408: ElMessage.error(\"请求超时！请您稍后重试\"); break; case 500: ElMessage.error(\"服务异常！\"); break; case 502: ElMessage.error(\"网关错误！\"); break; case 503: ElMessage.error(\"服务不可用！\"); break; case 504: ElMessage.error(\"网关超时！\"); break; default: ElMessage.error(\"请求失败！\"); } }; "},"vue/Dome/URLScheme.html":{"url":"vue/Dome/URLScheme.html","title":"URLScheme","keywords":"","body":"URLScheme 注意： 不支持在微信浏览器使用 结构 [scheme]://[host][:port]/[/path]?[query] scheme:协议名称，由开发人员自定义 host:域名 port:端口 path:页面路径 query:请求参数 设备判断 // 游览器标识 const ua = navigator.userAgent.toLowerCase(); // 是否微信内 const isWeixin = ua.indexOf(\"micromessenger\") !== -1; // 是否android终端 const isAndroid = /(Android)/i.test(ua); // 是否ios终端 const isIOS = /(iPhone|iPad|iPod|iOS|Mac)/i.test(ua); vue-h5 uniapp-app "},"vue/Dome/嵌套组件.html":{"url":"vue/Dome/嵌套组件.html","title":"嵌套组件","keywords":"","body":"嵌套组件 uni-app tab.vue {{ title }} import { getCurrentInstance, nextTick, onMounted, reactive, ref } from 'vue' const props = defineProps({ name: { type: [Number, String], }, title: { type: String, }, }) const instance: any = getCurrentInstance() const parent: any = instance.parent const state = reactive({ nodeWidth: 0, uid: instance.uid, }) const change = () => { parent.exposed.getLineIndex(state.uid, props.name) } onMounted(() => { uni .createSelectorQuery() .in(instance) .select('.tab-box') .boundingClientRect((res: any) => { state.nodeWidth = res.width }) .exec() }) defineExpose({ state, props }) .tab-box { padding: 12px; } tabs.vue import { computed, nextTick, onMounted, reactive, ref, getCurrentInstance } from 'vue' const props = defineProps({ active: { //绑定当前选中标签的标识符 type: [Number, String], default: 0, }, color: { //标签主题色 type: String, default: '#1989fa', }, background: { // 标签栏背景色 type: String, default: 'white', }, duration: { //动画时间，单位秒，设置为 0 可以禁用动画 type: [Number, String], default: 0.3, }, lineWidth: { //底部条宽度，默认单位 px type: [Number], default: 40, }, lineHeight: { //底部条高度，默认单位 px type: [Number], default: 3, }, titleActiveColor: { type: String, }, titleInactiveColor: { type: String, }, }) const state: any = reactive({ scrollTop: 0, oldScrollTop: 0, index: 0, active: props.active, activeUid: 0, maxWidth: null, }) const scroll = (e: any) => { state.oldScrollTop = e.detail.scrollTop } const scrollTo = async (val: number) => { state.scrollTop = state.oldScrollTop await nextTick() state.scrollTop = val } const instance: any = getCurrentInstance() onMounted(() => { getChildrenWidth() }) //线条相关代码 const lineInfo: any = reactive({ childrenInfoArr: [], lineLocationArr: [], isName: false, }) const getChildrenWidth = () => { const childrenProxy: any = instance.proxy.$children setTimeout(() => { lineInfo.childrenInfoArr = childrenProxy.map((item: any, index: Number) => { if (item.props.name) lineInfo.isName = true state.maxWidth += item.state.nodeWidth return { width: item.state.nodeWidth, name: item.props.name ? item.props.name : item.props.title, uid: item.state.uid, } }) console.log(childrenProxy) getLinkLocation() }, 300) } const getLinkLocation = () => { const childrenInfoArr = lineInfo.childrenInfoArr const length = childrenInfoArr.length const padding = 8 let countWidth: number = 0 for (let index = 0; length > index; index++) { if (index === 0) { countWidth = childrenInfoArr[index].width / 2 + padding + countWidth lineInfo.lineLocationArr.push({ name: childrenInfoArr[index].name, width: countWidth, }) } else { countWidth = (childrenInfoArr[index - 1].width + childrenInfoArr[index].width) / 2 + countWidth lineInfo.lineLocationArr.push({ name: childrenInfoArr[index].name, width: countWidth, }) } } } const lineOffset = computed(() => { if (lineInfo.lineLocationArr.length === 0) return -9999 if (lineInfo.isName) { getLineOffset() } else { return lineInfo.lineLocationArr[state.active].width } }) const getLineOffset = () => { const lineItem: any = lineInfo.lineLocationArr.find((item: any) => item.name === state.active) return lineItem ? lineItem.width : '' } const getLineIndex = (uid: any, name?: number | string) => { if (lineInfo.isName) { state.active = name } else { lineInfo.childrenInfoArr.forEach((item: any, index: number) => { if (item.uid === uid) { state.active = index } }) } // getLineOffset emit('change', state.active) emit('update:active', state.active) } defineExpose({ scrollTo, getLineIndex }) type EmitProps = { (e: 'change', key: string | number): void (e: 'update:active', key: string | number): void } const emit = defineEmits() .tabs-box { width: 200vw; position: relative; padding: 15px 8px; padding-top: 0; .line { position: absolute; bottom: 15px; left: 0; z-index: 1; } } "},"React/React18.html":{"url":"React/React18.html","title":"React18","keywords":"","body":"React18 index.js StrictMode严格模式，检测一些危险的操作(使用默写废弃或者不推荐的api)，执行两次生命周期 import React from \"react\"; import ReactDOM from \"react-dom/client\"; import \"./index.css\"; import App from \"./App\"; import reportWebVitals from \"./reportWebVitals\"; // react-dom 把react组件从一个真正的dom里卸载或渲染真正的dom const root = ReactDOM.createRoot(document.getElementById(\"root\")); //渲染真实dom root.render( //react严格语法模式，可要可不要 ); // root.unmount() 卸载真实dom reportWebVitals(); 添加样式 -- className 使用className关键字添加 内联 style 属性 使用驼峰命名法编写，必须使用对象写法 类名和样式要写在css文件里 只针对于组件生效，文件名必须为 xx.module.css import xxCss from \"./xxCss.module.css\" 显示数据 -- {} 使用大括号嵌入js元素 行内使用时，不加引号“” const user = { name:'哈喽' } return ( {user.name} ); 条件渲染( v-if ) react渲染undefined、null、空字符串、false不会渲染任何内容 复杂判断 let content if(isLogin){ content = }else{ content = } return {content} 多次判断 {isLogin ? () : ( )} 单次判断 {isLogin && } 渲染列表 -- map 外层必须有父元素 必须给数组中的每一项都指定一个 key const list = [ {title:'A',id:1}, {title:'B',id:2}, {title:'C',id:3}, ] const nodeList = list.map(item=>{ {item.title} }) return {nodeList} //可以直接在jsx中使用放法 {people.map(person => )} 响应事件 一定要传递函数，而不是调用函数 function ckickButton(){ function handleClick(){ console.log(\"触发了事件\") } return ( 点击事件 ) } export default function Toolbar() { const onPlayMovie=() => alert('Playing!') const onUploadImage=() => alert('Uploading!') return ( Play Movie Upload Image ); } function Button({ onClick, children }) { return ( {children} ); } 阻止事件冒泡 事件处理函数接收一个 事件对象 作为唯一的参数 e.stopPropagation() -- 阻止触发绑定在外层标签上的事件处理函数 function Button({ onClick, children }) { return ( { e.stopPropagation(); onClick(); }}> {children} ); } 阻止默认行为 某些浏览器事件具有与事件相关联的默认行为 e.preventDefault() -- 阻止少数事件的默认浏览器行为。 export default function Signup() { return ( { e.preventDefault(); alert('提交表单！'); }}> 发送 ); } JSX规则 只能返回一个根元素，如果包含多个元素，需要用一个父标签把它们包裹起来 标签必须闭合 使用驼峰式命名法给大部分属性命名 组件 子传父和父传子 都用回调函数 export default导出 标签和 return 关键字如果不在同一行，则必须把它包裹在一对括号 没有括号包裹的话，任何在 return 下一行的代码都将被忽略 方法加了<>就会解析成element 组件首字母必须大写 export default function MyApp() { const count = 1 function handleClick(){ return console.log('触发') } return ( ); } function MyButton({ count=100, onClick }) { //需要用{}解构 return ( Clicked {count} times ); } function Profile(props) { return ( ); } 组件插槽 import Avatar from './Avatar.js'; function Card({ children }) { return ( {children} ); } export default function Profile() { return ( ); } 纯粹 只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量 输入相同，则输出相同。 给定相同的输入，组件应该总是返回相同的 JSX 组件不应依赖于彼此的渲染顺序 注意： 禁止在组件中嵌套组件 状态管理 -- use 开头的函数被称为 Hook 只能在你的组件（或其他 Hook）的 顶层 调用 Hook useState 保存每次更新后的记录 多次渲染同一组件，每个组件都有自己的state 相同位置的相同组件会使得 state 被保留下来 使用 key 来重置 state(使用 key 重置表单) function MyButton() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( Clicked {count} times ); } 构建原则 合并关联的 state 避免互相矛盾的 state 避免冗余的 state 避免重复的 state 避免深度嵌套的 state 合并关联 const [position, setPosition] = useState({ x: 0, y: 0 }); 更新状态中对象 状态可以持有任何类型的 JavaScript 值 不应该直接改变你在 React 状态中持有的对象和数组 使用 ... 展开语法来复制你想改变的对象和数组 setPosition({ ...position, x: 100 }) 更新状态中数组 更新存在状态中的数组时，你需要创建一个新数组 setList(list.map(item => { return { ...item, seen: nextSeen }; })); useReducer 将组件的所有状态更新逻辑整合到一个外部函数中 const [`有状态的值`, ` dispatch 函数`] = useReducer(`reducer 函数`, `初始的 state`); const [tasks, dispatch] = useReducer(tasksReducer, initialTasks); function tasksReducer(tasks, action) { //tasks 原始值 //action 传入的内容 } 注意： educers 必须是纯粹的 每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化 . useContext -- 组件深层传递 创建组件 context.js 组件 （组件名随意） import { createContext } from 'react'; export const testContext = createContext(500); 在需要赋值的父组件插入 在需要的子组件的地方插入 import { testContext } from './Context.js'; const testContext = useContext(testContext); useRef 更改 ref 不会重新渲染组件 不要在渲染过程中读取或写入 将 ref 视为应急方案 import { useRef } from 'react'; const inputRef = useRef(null); //返回的对象 { current: 0 } // 你向 useRef 传入的值 操作dom 不能在组件上直接使用，需要传入后，重新赋值 const MyInput = forwardRef((props, ref) => { return ; }); useEffect 通常用于暂时“跳出” React 代码并与一些 外部 系统进行同步 useEffect 包裹副作用，把其中的代码分离到渲染逻辑的计算过程之外 useEffect(() => { // 这里的代码会在每次渲染后执行 }); useEffect(() => { // 这里的代码只会在组件挂载后执行 }, []); useEffect(() => { //这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行 }, [a, b]); 1、声明 Effect 每当组件渲染时，React 将更新屏幕， useEffect 中的代码就会运行 import { useEffect } from 'react'; useEffect(() => { // 每次渲染后都会执行此处的代码 }); 2、 指定 Effect 依赖 将 依赖属性 传入 useEffect 的第二个参数 , 如果在上一次渲染时依赖属性与当前相同，就跳过重新运行 Effect 如果 ref 是从父组件传递的，则必须在依赖项数组中指定它 import { useState, useRef } from 'react'; useEffect(() => { },[`依赖属性`]); useEffect(() => { if (isPlaying) { ref.current.play(); } else { ref.current.pause(); } }, [isPlaying]); 3、 必要时添加清理（cleanup）函数 在开发环境中，React 会在初始挂载组件后，立即再挂载一次，所以组件被卸载时，也要调用清理函数 不加清楚函数，会执行两遍useEffect 在执行下一轮渲染的 Effect 之前清理上一轮渲染的 Effect useEffect(() => { const connection = createConnection(); connection.connect();//请求连接 return () => { connection.disconnect(); //断开连接 }; }, []); 注意： 避免当 prop 变化时，在 Effect 中调整/重置 state 避免在 Effect 中处理属于事件特定的逻辑 避免链接多个 Effect 仅仅为了相互触发调整 state 避免把只需要执行一次的逻辑放在 Effect 中 避免在 Effect 中传递数据给父组件 避免没有清除逻辑的获取数据 "},"微信/微信公众号.html":{"url":"微信/微信公众号.html","title":"微信公众号","keywords":"","body":"微信公众号 注意 JS-SDK说明文档 微信内置浏览器WeixinJSBridge 微信浏览器内部尚未初始化 sendMessage 进行绑定 if(document.addEventListener){ document.addEventListener('WeixinJSBridgeReady',sendMessage,false); }else if(document.attachEvent){ document.attachEvent('WeixinJSBridgeReady' , sendMessage); document.attachEvent('onWeixinJSBridgeReady' , sendMessage); } 常用参数 WeixinJSBridge.call('closeWindow'); //关闭当前浏览器 WeixinJSBridge.call(‘hideToolbar’); //隐藏右下面工具栏 WeixinJSBridge.call(‘showToolbar’); //显示右下面工具栏 WeixinJSBridge.call(‘hideOptionMenu’); //隐藏右上角三个点按钮。 WeixinJSBridge.call(‘showOptionMenu’); //显示右上角三个点按钮。 分享好友 （menu:share:appmessage） WeixinJSBridge.on('menu:share:appmessage', function(argv){ WeixinJSBridge.invoke('sendAppMessage',{ \"appid\":\"\", //appid 设置空就好了。 \"img_url\": imgUrl, //分享时所带的图片路径 \"img_width\": \"120\", //图片宽度 \"img_height\": \"120\", //图片高度 \"link\":url, //分享附带链接地址 \"desc\":\"我是一个介绍\", //分享内容介绍 \"title\":\"标题，再简单不过了。\" }, function(res){ /*** 回调函数，最好设置为空 ***/ }); }); 分享朋友圈 （menu:share:timeline） WeixinJSBridge.on('menu:share:timeline', function(argv){ WeixinJSBridge.invoke('shareTimeline',{ \"appid\":\"\", //appid 设置空就好了。 \"img_url\": imgUrl, //分享时所带的图片路径 \"img_width\": \"120\", //图片宽度 \"img_height\": \"120\", //图片高度 \"link\":url, //分享附带链接地址 \"desc\":\"我是一个介绍\", //分享内容介绍 \"title\":\"标题，再简单不过了。\" }, function(res){ /*** 回调函数，最好设置为空 ***/}); }); }); 分享到微博（menu:share:weibo） WeixinJSBridge.on('menu:share:weibo', function(argv){ WeixinJSBridge.invoke('shareWeibo',{ \"content\":dataForWeixin.title+' '+dataForWeixin.url, \"url\":dataForWeixin.url }, function(res){ /*** 回调函数，最好设置为空 ***/ }); }); 获取网络状态 WeixinJSBridge.invoke('getNetworkType',{},function(e){ // 在这里拿到e.err_msg，这里面就包含了所有的网络类型 e.err_msg }); //wifi wifi网络 //edge 非wifi,包含3G/2G //fail 网络断开连接 //wwan 2g或者3g "},"微信/小程序.html":{"url":"微信/小程序.html","title":"小程序","keywords":"","body":"小程序 注意： rpx 标准尺寸 750rpx background-image-- 不支持本地路径！需要使用网络图片或者base64格式 生命周期 应用生命周期 -- app.js 定义 描述 onLaunch 小程序初始化 onShow 小程序启动或切前台 onHide 小程序切后台 页面生命周期 描述 onLoad 监听页面加载 onShow 监听页面显示 -- 组件使用 onHide 监听页面隐藏 onReady 页面初次渲染完成 onUnload 监听页面卸载 组件生命周期 描述 created 组件实例创建完成 attached 组件已挂载页面时触发 ready 组件初次渲染完成 moved 在组件实例被移动到节点树另一个位置时执行 detached 组件销毁 error 组件方法抛出错误 注意： 5 秒后执行挂起状态 挂起30 分钟后销毁 tabBar页面相互切换，不会销毁页面 使用左上角的返回，会销毁当前页面 项目结构 app.json -- 全局配置 project.config.json -- 项目公共配置文件 -- 本地设置更改 project.private.config.json -- 项目私人配置 -- git 忽略文件 sitemap.json -- 配置小程序以及页面是否允许被微信索引 切换渲染模式 删除 app.json 下方的代码，可将 Skyline 模式切换成 WebView \"renderer\": \"skyline\", \"rendererOptions\": { \"skyline\": { \"defaultDisplayBlock\": true, \"disableABTest\": true, \"sdkVersionBegin\": \"3.0.0\", \"sdkVersionEnd\": \"15.255.255\" } }, \"componentFramework\": \"glass-easel\", iconfont 导入 直接在iconfont中导入对象需要的文件 使用类名，使用 icon -- 如：icon-haoping 字体格式建议添加 base64 格式 -- 不然会报【渲染层错误】 @font-face { font-family: \"iconfont\"; /* Project id 4457676 */ src: url(\"base64地址\") format(\"woff2\"), url(\"//at.alicdn.com/t/c/font_4457676_5nlv7pq039b.woff?t=1709802057436\") format(\"woff\"), url(\"//at.alicdn.com/t/c/font_4457676_5nlv7pq039b.ttf?t=1709802057436\") format(\"truetype\"); } .icon-haoping:before { content: \"\\e6c6\"; } .icon-icon:before { content: \"\\e66d\"; } .icon-shijian:before { content: \"\\e8a9\"; } .icon-peisongjilu:before { content: \"\\eb46\"; } 事件 传入函数名，不调用 绑定事件 bind 可以省略冒号 batch -- 阻止事件冒泡 事件传参 data-* *为传参的数据 currentTarget -- 事件绑定者 -- 父级以及父级的数据使用 target -- 事件触发者 -- 自己组件传的数据 多单词，中划线-拼接会转换成小驼峰，小驼峰写法会全部转成小写 //index.js Page({ btnHandler(event) { console.log(event);//{target:{dataset:{id:1,name:tom}}} }, }); //index.wxml 按钮 mark:* mark -- 获取到自己和父节点上所有的数据 //index.js Page({ btnHandler(event) { console.log(event);//{mark:{id:1,name:tom,title：标题}} }, }); //index.wxml 按钮 WXML 语法 data -- 数据 page({ data:{ id:1 } }) 绑定 布尔值一定要使用双大括号 {{id}} setData 更新数据 驱动视图更新 created生命周期中，setData无法使用 page({ data:{ id:1 }, updateId(){ this.setData({ id:this.data.id + 1 }) } }) 对象 新增/修改 this.setData({ ...this.data.user, \"user.a\":2 }) 删除 //单个删除 delete this.data.user.a this.setData({ user:this.data.user }) //多个删除 -- 删除a,b const {a,b,...rest} = this.data.user this.setData({ user:rest }) 数组 新增/修改 this.setData({ \"list[1]\":6 list:[...list,2,3] }) 删除 //单个删除 this.data.list.solice(1,1) this.setData({ list:this.data.list }) //多个删除 -- 删除a,b const newList = this.data.list.filter(item=>item!==2) this.setData({ list:newList }) model: 只能单一字段绑定 不能使用路基参数，不支持数组和对象,例如： wx:for 配套使用 wx:key 使用属性，不用使用item，直接写入需要属性的那个值即可 如果其中的值不是对象，则可使用*this，*this代表的是item本身 属性默认字段 -- item wx:for-item -- 更改属性默认字段 索引默认字段 -- index wx:for-index -- 更改索引默认字段 {{item}} - {{index}} {{item}} - {{index}} {{item}} - {{index}} {{newItem}} - {{newIndex}} 可以使用来包装元素，类似template的作用 {{item.name}} wx:if wx:elif/wx:else可配套使用 hidden api 分类 异步 api --- 通常接受一个object类型的参数，例：wx.request({}) 同步 api --- 约定以Sync结尾，例：wx.setStorageSync() 事件监听 api --- 约定以on开头，例：wx.onAppHiden() api 描述 getApp() 获取到全局唯一的 App 实例 wx.getAccountInfoSync() 获取当前账号信息 wx.openSetting 调起客户端小程序设置界 - 更改授权开关 wx.getSetting 获得用户所有的授权信息 组件 创建组件文件夹，然后使用微信开发者工具选项新建component来创建组件文件 注册 全局组件 //app.json \"usingComponents\": { \"table\":\"./components/table/table\" } 页面组件 在使用的页面文件下使用直接写入组件名称文件夹，不用创建components文件夹 ) //index.json -- 当前使用组件的文件夹json文件 \"usingComponents\": { \"banner\":\"./banner/banner\" } slot 默认插槽 具名插槽 //banner.js options:{ multipleSlots:true // 启用多slot支持 } //banner.wxml //index.wxml 1 1 CSS 不允许使用标签选择器、ID 选择器、属性选择器 子选择器，只能用于view和子组件，不建议使用 继承样式，都会从组件外继承 自定义组件，只会对自己的 css 文件样式生效 样式隔离 isolated -- 开启样式隔离 -- 默认值 apply-shared -- 页面样式影响到组件，但组件 中指定的样式不会影响页面 shared -- 页面样式影响到组件，组件中指定样式也影响页面和其他设置 apply-shared 或 shared 的组件 //banner.js options:{ \"styleIsolation\": \"isolated\" } 穿透 修改官方组件文件 全局样式不需要设置 组件需要将styleIsolation设置成shared 为了防止影响其他样式，要在 css 前面增加一层嵌套 options:{ \"styleIsolation\": \"isolated\" } externalClasses 外部样式类 把要接受的外部类写入就会生效 Component({ externalClasses:['text-class'] }) 监听器 - observers observers:{ name:function(value){}, count:(value)=>{}, 'name,count':function(nameVlaue,countVlaue){} \"obj.name\":(value)=>{},//对象 \"obj.**\":(value)=>{},//监听对象所有属性,**通配符 \"arr[1]\":(value)=>{},//数组 } properties/triggerEvent properties -- 接受外部数据 -- 类似 vue3 的props type数据类型 支持String、Number、Object、Array null表示不限制类型 value默认值 properties: { name: { type: String, value: \"\", }, }, methods: { update(){ this.properties.name } }, //wxml {{name}} triggerEvent-- 输出外部数据 -- 类似 vue3 的emit //banner.js this.triggerEvent('getNmae',this.data.name) //home.wxml selectComponent -- 类似 vue 的 ref 使用 css 选择器来获取 this.selectComponent('.id') Behavior-- 类似 vue2 中的 mixins //behavior.js const behavior = Behavior({组件所有属性都支持}) export default behavior //banner.js import behavior from \"./behavior\" Component({ behavior:[behavior] }) NPM 仅能安装小程序定制的 npm 包 vant Weapp 调整目录结构 1、将小程序源码放入src目录下 assets、代码、app.js、app.json、app.less、sitemap.json 2、project.config.json { \"miniprogramRoot\": \"./src\",//设置微信小程序源码目录 \"setting\":{ \"packNpmManually\": true, //允许对npm目录自定义 \"packNpmRelationList\": [{ \"packageJsonPath\": \"./package.json\",//node_modules 源对应的 package.jso \"miniprogramNpmDistDir\": \"./src\"//node_modules 的构建结果目标位置 }], } } 3、npm init -y创建package.json文件 4、 重新打开文件，工具 -- 构建npm 分包 整个小程序所有分包大小不超过 20M（开通虚拟支付后的小游戏不超过 30M） 单个分包/主包大小不能超过 2M 主包和分包目录是同级的 \"pages\":[], //主包 \"subpackages\": [ { \"root\": \"packageA\", //分包根目录 \"name\": \"pack2\", //分包别名，分包预下载时可以使用 \"pages\": [ //分包页面路径，相对于分包根目录 \"pages/apple\", \"pages/banana\" ] } ] 独立分包 独立分包中不能依赖主包和其他分包中的内容 主包中的 app.wxss 对独立分包无效 App 只能在主包内定义 独立分包中暂时不支持使用插件 \"subpackages\": [ { \"root\": \"packageA\", //分包根目录 \"name\": \"pack2\", //分包别名，分包预下载时可以使用 \"pages\": [ //分包页面路径，相对于分包根目录 \"pages/apple\", \"pages/banana\" ] \"independent\": true //分包是否是独立分包 } ] 分包预下载 同一个分包中的页面享有共同的预下载大小限额 2M , A包+B包+C包 === 2MB \"preloadrule\": { \"pages/index\": { //进入页面触发预下载 \"network\":\"all\", //在指定网络下预下载 all: 不限网络 \"packages\": [ \"important\"]; //进入页面后预下载分包的 root 或 name } , \"indep/index\": { \"network\":\"wifi\", //仅wifi下预下载 \"packages\": [ \"__APP__\"]; //__APP__ 表示主包 } } VSCode 插件 插件名 描述 WXML - Language Service 针对 wxml 文件代码补全等功能 微信小程序开发工具 供小程序预览、打包上传、代码补全、语法高亮、项目模版等 微信小程序助手-Y 快速创建/删除 page 和 component 文件结构 小程序开发助手 代码提示 + 语法高亮 地址逆解析 打开腾讯位置服务 微信小程序 JavaScript SDK 文档 行政划分 表单验证 async-validator import Schema from 'async-validator' validatorAddress(params) {' const rules = { name: [ { required: true, message: '请输入收货人姓名' }, { type: string, message: 'name不是字符串' , { pattern: 正则, message: '收货人姓名不合法' }, { min: 2,max:3, message: '名字最少2个字，最多3个字' } ], } // 传入验证规则进行实例化 const validator = new Schema(rules) // 调用实例方法对请求参数进行验证 // 注意：我们希望将验证结果通过 Promise 的形式返回给函数的调用者 return new Promise((resolve) => { validator.validate(params, (errors) => { if (errors) { // 如果验证失败，需要给用户进行提示 wx.toast({ title: errors[0].message }) // 如果属性值是 false，说明验证失败 resolve({ valid: false }) } else { // 如果属性值是 true，说明验证成功 resolve({ valid: true }) } }) }) }, "},"Flutter/Dart.html":{"url":"Flutter/Dart.html","title":"Dart","keywords":"","body":"Dart 下载地址 安装方式 vscode插件 出现乱码，settings.json配置\"code-runner.runInTerminal\": true Dart 高亮 Code Runner 允许dart文件 main -- 入口方法 main(){} void main(){} //表示main方法没返回值，等同于ts的const a = ():void{} 变量 var 定义 自动推导类型，不能和ts一样在后面跟类型 不会进行变量提升 var str = \"\" 类型定义 String str = \"\" int number = 123 常量 可以通过is关键词判断类型 const 定义处值不能为空，必须有值 const bar = 1000 final 默认可以不赋值，但是只能被赋一次 final time = new DateTime.now() 类型 string -- 字符串 三个引号可以达到模板字符串的作用 String str = \"123\" String srt = \"\"\" 1213 123 \"\"\" 字符串拼接 String str1 = \"123\"; String str2 = \"456\"; print(\"$str1$str2\"); print(str1 + str2); 类型转换 int number = 123 var str = number.toString() numbers -- 数值 int - 整数 double - 浮点数 int a = 123 double a= 1.23 类型转换 String str = \"123\" var num = int.parse(str) String str = \"1.23\" var num = double.parse(str) boolean -- 布尔值 bool show = true List -- 数组/集合 本质上是js的数组 var list = [] List list = [] var list = [] var list = new List() //2.0创建方法，仅作参考 var list = List.filled(2, \"\"); //创建指定长度集合 常用方法 js相同方法：length、join、split、forEach、set、map forEach 修改方法里的值，不会改变原数组 方法 描述 add 增加 addAll 拼接数组 remove 删除 -- 删除对应参数 removeAt 删除指定位置 -- 传入索引值 finllRange(1,4,123) 修改 - 在数组1-4索引位的替换为123 insert(1,123) 增加指定位置的一个值 insertAll(1,[123,123]) 增加指定位置的多个值 toList 转化成list Maps -- 映射 key 必须加引号 比较像js的对象 //普通定义 var param = { \"name\":'张三', \"age\":18 } //Map 定义 Map param = { \"name\":'张三', \"age\":18 } //new map定义 var param = new Map() param[\"name\"] = \"张三\" param[\"age\"] = 18 print(param['name']) 常用方法 js相同方法：forEach、map、set 方法 描述 keys 查看所有key值 values 查看所有values值 isEmpty 是否为空 remove(key) 删除 -- 删除对应参数 addAll({}) 拼接数组 containsValue(value) 判断value值是否存在 any 检测元素是否都有符合条件的 every 检测元素元素是否都符合条件 运算符 --- 基本上和js一致 函数 方法使用箭头函数只能写一行 int printInfo(int n){ return n } //前面写返回类型，没有则写void void main() { printInfo() } 参数 可选参数 --- [] 默认参数 --- = 命名参数 --- {} 方法直接传入即可 //可选参数 int printInfo(int n,[String sex，int age]){ return n } //默认参数 int printInfo(int n,[String sex='男']){ return n } //命名参数 int printInfo(int n,{String sex，int age}){ return n } printInfo(123，sex:'男',age:18) 方法 int fun(int n ){ return n } //命名方法 final fun = (int n ){ return n } //匿名方法 ((int n ){ print(n) })(123) //自执行方法 class - 类 首字母大写驼峰写法 class Person { String name = \"name\"; int age = 18; void getInfo() { print(\"${this.name}---${this.age}\"); } void setAge(int age) { this.age = age; } } void main() { Person p1 = new Person(); print(p1.name); p1.setAge(20); p1.getInfo(); } 默认构造函数 构造函数名和类名一致 class Person { String? name; int? age; Person(String name, int age) { //简写` Person(this.name, this.age)` this.name = name; this.age = age; } void getInfo() { print(\"${this.name}---${this.age}\"); } } void main() { Person p1 = new Person('name', 20); print(p1); } 命名构造函数 在实例化时就可直接调用 class Person { String? name; int? age; Person(this.name, this.age); Person.now(String text) { print(text); } } void main() { Person p1 = new Person.now(\"命名构造函数\"); } 私有属性/方法 在属性和方法前面加_定义为私有 同文件下,定义私有无效,必须跨文件 class Person { String? _name; int? _age; Person(this._name, this._age); String _info() { return \"${this._name}---${this._age}\"; } void getInfo() { print(this._info); } } void main() { Person p1 = new Person('name', 18); p1.getInfo(); } get/set get -- 计算属性 set -- 监听器 class Rect { int height; int width; Rect(this.height, this.width); get area { return this.width * this.height; } set areaHeight(int value) { this.height = value; } } void main() { Rect r = new Rect(3, 4); r.areaHeight = 6; print(r.area); } 初始化实例变量 class Rect { int height; int width; Rect():height=2,width=3{}; } static -- 静态 静态方法不能访问非静态成员,非静态方法可以访问静态成员 静态成员和方法,不用实例化即可访问 静态成员在类中直接访问 class person { static String name = \"name\"; int age = 20 ; static void show(){ print(name); } void printInfo(){ print(name); print(this.age); } } main(){ person.show() } 操作符 ? -- 条件运算符 as -- 类型转换 is -- 类型判断 .. -- 级联操作(连缀) class Person { String name; int age; Person(this.name, this.age); info() { print(\"${this.name}---${this.age}\"); } } void main() { Person p1 = new Person('name', 18); p1..name = \"name1\" ..age = 20 ..info(); } 继承 父类属性可直接通过this使用,方法则需要访问super extends --- 继承父类里可见的属性的方法, 不会继承构造函数 super -- 本质上是父类的实例 class Person { String name; int age; Person(this.name, this.age); info() { print(\"${this.name}---${this.age}\"); } } class Web extends Person { Web(super.name, super.age); //默认构造函数传参 Web(String name, int age) : super(name, age); //默认构造函数传参 Web.now(super.name, super.age);//命名构造函数传参 super.info() //子类调用父类方法 @override //覆写时建议写入 void info() { print(\"覆写的类\"); } } void main() { Web p1 = new Web('name', 18); } 抽象类 -- abstract extends - 继承 - 复用抽象类里的方法并且要使用抽象方法约束子类使用 主要用于定义标准 不能直接实例化,只有继承它的子类才可以 没有方法体的方法称为抽象方法,并且继承的子类必须实现抽象类里的抽象方法 抽象类的普通方法和普通类没有区别 abstract class Painting { color(); //抽象方法 text() {} //普通方法 } class Draw1 extends Painting { @override color() { print(\"red\"); } } class Draw2 extends Painting { @override color() { print(\"pink\"); } } void main() { Draw1 p1 = new Draw1(); p1.color(); Draw2 p2 = new Draw2(); p2.color(); } 多态 -- 父类不去实现,让继承的子类实现,每个子类有不同的表现 将子类的实例赋值给父类的引用,这样就无法使用子类里的方法的属性 void main() { Painting p1 = new Draw1(); p1.color(); Painting p2 = new Draw2(); p2.color(); } 接口 implements - 接口 - 单纯的使用抽象方法和属性当作标准使用 class Draw1 implements Painting1,Painting2 {} mixin -- 待记录 泛型 泛型方法 T getData(T value) { return value; } void main(){ getData(''); getData(123); } 泛型类 class ListInfo{ List list = []; void add(T value){ this.list.add(value); } } main(){ ListInfo list = new ListInfo(); list.add(123); } 泛型接口 abstract class Cache { getByKey(String key); void setByKey(String key, T value); } class FileCache implements Cache { @override getByKey(String key) { return null; } @override void setByKey(String key, T value) {} } main() { FileCache f = new FileCache(); f.setByKey('index', ''); } "},"Flutter/Flutter.html":{"url":"Flutter/Flutter.html","title":"Flutter","keywords":"","body":"Flutter vscode插件 Dart 高亮 "},"打包工具/vite.html":{"url":"打包工具/vite.html","title":"vite","keywords":"","body":"vite vite与webpack的区别 webpack 支持commonjs和esmdule两种规范 侧重点是兼容性 统一模块化代码时，会将所有的依赖全部读一遍 vite 仅支持esmdule规范 侧重点是浏览器端的开发体验 按需加载所需的页面，减少加载时间 依赖预构建 路径补全 在处理中，遇到有非绝对路径或者相对路径，则会进行路径补全 找寻依赖的过程是由当前目录依次向上查找，直到搜寻到根目录或找到对应依赖为止 import _ from \"lodash\" //相等 imprt _ from \"/node_modeles/.vite/lodash\" 作用 vite会找到对应的依赖，然后调用esbuild，将其他规范的代码转换成esmodule规范，然后放到当前目录下面（node_modules/.vite/），同时对esmodule规范的各个模块进行统一集成 依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。在生产构建中，将使用 @rollup/plugin-commonjs。 解决的问题： 将不同的三方包中会有不同的导出格式进行统一 对路径的处理可以直接进行使用.vite/，方便路径重新 解决网络多包传入性能问题（一个包可能有无数个引用依赖），无论有多少个额外的export 和 import，vite都尽可能的将它们集成，最后只生成一个或者多个模块（将需要引入的额外依赖，修改代码，使其按需加载） 配置文件 语法提示配置 defineConfigvite代码提示 import { defineConfig } from \"vite\"; export default defineConfig()=>{} 环境处理 import { defineConfig, ConfigEnv, UserConfig } from \"vite\"; import viteBaseConfig from \"./vite.base.config\" import viteDevConfig from \"./vite.dev.config\" import viteProdsConfig from \"./vite.prod.config\" const envResolver = { \"build\": () => { return { ...viteBaseConfig, ...viteDevConfig } }, \"server\": () => { return { ...viteBaseConfig, ...viteProdsConfig } }, } export default defineConfig(({ mode, command }: ConfigEnv): UserConfig => { return }) //ConfigEnv 传递的类型 //command:'build' | 'serve' 当前所处环境 export default defineConfig(({ mode, command }: ConfigEnv): UserConfig => { return envResolver[command]() }) 环境变量 指定模式的文件（例如 .env.production）会比通用形式的优先级更高 （例如 .env）。 .env # 所有情况下都会加载 .env.local # 所有情况下都会加载，但会被 git 忽略 .env.[mode] # 只在指定模式下加载 .env.[mode].local # 只在指定模式下加载，但会被 git 忽略 服务端(vite.config.js) vite是通过dotenv的第三方库解析 dotenv dotenv自动读取.env文件，并且将其变量注入到process(node全局对象)下 loadEnv mode -- package.json文件命令行 --mode 后面的内容 process.cwd() -- 返回当前node进程的工作目录 prefixes -- 更改加载的默认前缀（默认： VITE_ ） 步骤： 找到.env文件，解析其中变量，并放进一个对象 将传入的mode拼接成 .dev.${mode}，根据提供的目录(process.cwd())去取对应的配置文件，并放进一个对象 注意：后者的对象读覆盖前者的对象 import { loadEnv } from 'vite' export default defineConfig(({ mode}: ConfigEnv): UserConfig => { const viteEnv = loadEnv(mode, process.cwd(), '') }) 客户端 Vite 在一个特殊的 import.meta.env 对象上暴露环境变量 默认 VITE_为前缀，可在config中使用envPrefix更改默认前缀 加载静态资源 本质上做的事情是一个字符串的替换 path.resolv将路径适配成服务端可识别的 __dirname始终返回当前文件所在的目录 import { resolve } from \"path\"; resolve: { alias: [ { find: \"@\", replacement: resolve(__dirname, \"./src\") }, ] }, vite插件 在生命周期的不同阶段中去调用不同的插件以达到不用的目的 vite-aliases 检测当前目录下包括src在内的所有文件夹，并且自动生成别名 使用vite-aliases,就不需要resolve.alias了 plugins: [ ViteAliases() ] vite-plugin-html 动态的去控制整个html文件的内容 本质上是读取文件，字符串替换 createHtmlPlugin({ inject: { data: { title: '主页', } },//html中的title }) vite独有钩子 plugins: [{ config(options){}, //解析 Vite 配置前调用 configureServer(server){ server.middlewares.user(()=>{}) }, //配置开发服务器的钩子 }] 性能优化 分包策略 定制分包条件 把不会常规更新的文件，单独打包处理 build: { rollupOptions: { output:{ manualChunks:(id:string)=>{//id：文件名 // 默认环境在es6之前，可在tsconfig文件里compilerOptions.lib配置 if(id.includes(\"node_modules\")){ return 'vendor' //vendor 打包后的单独文件名 } } }, }, }, 多出口分包 一个项目有多个出口时，配置对应的html文件 build: { rollupOptions: { input:{ main:path.resolve(_dirname,'./index.html'), product:path.resolve(_dirname,'./product.html') } }, }, gzip压缩 -- vite-plugin-compression 将所有的静态文件压缩，减少体积 得到.gz文件，浏览器会花费直接进行解压，最好设置压缩门槛 viteCompression({ verbose: true, disable: false, threshold: 10240, algorithm: \"gzip\", ext: \".gz\" }), cdn加速 -- 内容分发网络 将以来的第三方模块，写成cdn形式，保证自己代码的小体积 vite-plugin-cdn-import import importToCDN from 'vite-plugin-cdn-import' plugins: [ importToCDN({ modules: [ { name: 'react', //需要 CDN 加速的包名称 var: 'React', //全局分配给模块的变量 path: `umd/react.production.min.js`,//指定 CDN 上的加载路径 } ], }), ], 处理跨域 跨域限制是服务器响应了，但是浏览器在中间拦截了 发送请求是不会被拦截的 server: { // 服务器主机名，如果允许外部访问，可设置为 \"0.0.0.0\" host: \"0.0.0.0\", port: 9032, cors: true, // 跨域代理配置 proxy: { \"/api\": { target: \"http://47.108.254.19:8001/\", //重定向地址 changeOrigin: true, rewrite: (path) => path.replace(/^\\/api/, \"\") //删除请求地址中多余的字段 } } }, vite.config.js import { defineConfig, loadEnv, ConfigEnv, UserConfig } from \"vite\"; import viteCompression from \"vite-plugin-compression\"; import { resolve } from \"path\"; export default defineConfig(({ mode }: ConfigEnv): UserConfig => { const viteEnv = loadEnv(mode, process.cwd(), \"\"); return { resolve: { alias: [ { find: \"@\", replacement: resolve(__dirname, \"./src\") }, ] }, server: { // 服务器主机名，如果允许外部访问，可设置为 \"0.0.0.0\" host: \"0.0.0.0\", port: 9032, cors: true, // 跨域代理配置 proxy: { \"/api\": { target: \"http://47.108.254.19:8001/\", //test/ changeOrigin: true, rewrite: (path) => path.replace(/^\\/api/, \"\") } } }, optimizeDeps: { exclude: [], // 将指定数组中的依赖不进行依赖预构建 }, envPrefix: 'ENV_',//更改env文件获取变量默认前缀 css: { preprocessorOptions: { //配置css预处理器 less: { //整个配置对象会给到less的执行参数(全局参数)中去 -- 可以写入less的命令行语句 additionalData: `@import \"@/assets/styles/parameter.less\";` //引入附加的less文件 } }, postcss: {}, //配置关于postcss的内容，优先级比配置文件高, }, build: { //构建打包后的配置 outDir: \"dist\", //配置输出目录名 assetsDir: \"static\", //配置输出目录中的静态目录名字 rollupOptions: { //配置rollup（模块打包工具）的构建政策 output: { //控制输出 assetFileNames: \"assets/[ext]/[name]-[hash].[ext]\",//静态资源 chunkFileNames: \"assets/js/[name]-[hash].js\", entryFileNames: \"assets/js/[name]-[hash].js\", }, }, chunkSizeWarningLimit: 1500,//大于1500kb的图片会被转化成base64格式 emptyOutDir: true, //清楚输出目录中的所有文件 -- 默认为true }, plugins: [//插件 viteCompression({ verbose: true, disable: false, threshold: 10240, algorithm: \"gzip\", ext: \".gz\" }), ], } }) "},"打包工具/webpack.html":{"url":"打包工具/webpack.html","title":"webpack","keywords":"","body":"webpack 命令行 webpack-cil 命令行 npx webpack --help //查看参数 npx webpack --watch //会一直监听文件变化 webpack.config.js // [contenthash] 根据文件的内容生产一个哈希的字符串 // [ext] 表示原有的扩展名 const HtmlWebpackPlugin = require('html-webpack-plugin') // webpack构建后生成html文件 const MiniCssExtractPlugin = require('mini-css-extract-plugin') // 抽离css文件 const CssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin') // 抽离css文件 module.exports = { entry, //入口文件 output: { //输出文件 filename, //文件名，也可以编辑路径 srtipt/[name].[contenthash].js path, //打包的输出路径 必须为绝对路径 clean: true, //删除上一次的打包内容 assetModuleFilename: 'image/[contenthash][ext]', //设置资源模块文件名和路径 pubicPath, //html中link标签上引入的域名 }, mode, //打包环境类型 production development devtoll: 'evel', //错误定位 plugins: [ //插件 new HtmlWebpackPlugin({ //必须实例化 template, //模板的路径 fileName, //文件名 inject, //文件里 script 标签生成地方 }), new MiniCssExtractPlugin() //参数和上面一样 ], devServe: { //基础的服务 static, //需要启动的路径 }, module: { //配置模块 rules: [ //配置规则 { test: /\\.png$/, //匹配规则 //asset/resource 可以加载全部文件 type: 'asset/resource', //发送单独的文件，并且导出url 本地的图片资源 generator: { filename, //设置资源的文件名 优先级高于assetModuleFilename } }, { test: /\\.svg$/, type: 'asset/lnline', // 导出资源的data的url，bese64 }, { test: /\\.text$/, type: 'asset/source', // 导出资源的源代码 }, { test: /\\.jpg$/, type: 'asset', //resource和lnline选择,默认情况下 大于8k就会生成一个资源文件,否则则是bese64 parser: { //解析器 dataUrlCondition: { //条件 maxSize, //更改asset生产资源的判断条件，默认是8k } } }, { test: /\\.(css | less)/, //当匹配到时，执行下方use // 注意：下方数组中有执行顺序，从后到前，先执行的less-loader use: [miniCssExtractPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.js/, exclude: /node_modules/, //排除条件 use: { loader: 'babel-lader', options: { parser: ['@babel/perser-env'], plugins: [ [ \"@babel/plugin-transform-runtime\" ] ] } } } ] }, optimization: { //优化 minimizer: [ //压缩 new CssMinimizerWebpackPlugin() ], splitChunks: { //将公共的方法分离成一个文件 cacheGroups: { //缓存组 vendor: { test: /[\\\\]node_modules[\\\\]/, name: 'vendors', //打包的名 chunks: 'all' } } } }, performance: { //性能配置 hints: false, //提示关闭 }, resolve: { //模块解析 alias: { //配置别名 'assets': '@/assets', 'components': '@/components' }, extensions: ['.json', 'js', 'vue'], //配置扩展名优先级，从前往后 }, externalsType: 'script', //下方链接放入的标签类型 externals: { //定义外部的第三方包 //$ 表示暴露的Jquery别名 jquery: ['JQuery的链接', '$'] }, } 代码分离 入口起点 使用entry配置手动的分离代码 entry: { //配置多入口 index: './index.js', another: './another.js', }, output: { //输出文件 //[name]根据入口名，自动生成出口文件名 filename:'[name].js', //文件名 path, //输出路径 必须为绝对路径 }, 防止重复 使用Entry dependencies 或者 SplitChunksPlugin 去重和分离代码 Entry dependencies entry: { index: { import: 'index.js', //入口文件路径 dependOn: 'shared', //将共享的文件定义出来,shared为文件名 }, output: { import: 'output.js', //入口文件路径 dependOn: 'shared', //将共享的文件定义出来 }, shared: 'lodash', //将lodash分离出来，单独为一个文件 }, SplitChunksPlugin optimization: { splitChunks: { //将公共的方法分离成一个文件 chunks: 'all' } } 动态导入 通过模块的内调函数来分离代码 function getInfo(){ import('lodash') //动态导入 .then(res){ return res } } 懒加载 //当执行add这个方法时，才加载index.js这个文件，并且index.js会被打包成一个包 // /*webpackChunkName:'indexInt'*/ 修改index.js打包后的文件名 function add(){ import( /*webpackChunkName:'indexInt'*/ './index.js') .then(res=>{}) } 预获取/预加载模块 //预获取(prfetch) //webpackPrfetch 首页内容加载完毕，在网络空闲的时候，提前下载好index.js文件 function add(){ import( /*webpackPrfetch:true*/ './index.js').then(res=>{}) } //预加载(preload) //webpackPrfetch 和懒加载类似,但是页面模块会并行加载 function add(){ import( /*webpackPrfetch:true*/ './index.js').then(res=>{}) } 缓存 当文件内容改变，文件名没有变化时，浏览器则会使用上一次的缓存 [contenthash] 根据文件的内容生产一个哈希的字符串 缓存第三方库 optimization: { splitChunks: { //将公共的方法分离成一个文件 cacheGroups: { //缓存组 vendor: { test: /[\\\\]node_modules[\\\\]/, name: 'vendors', //打包的名,保持文件名不变化，浏览器下次访问直接使用缓存 chunks: 'all' } } } } 拆分开发和生产环境配置 深合并 const { merge } = require('webpack-merge') module.exports = (env)=>{ switch(true){ case env.dev; return merge(commonConfig,devConfig) //代码合并 } } source-map devtoll: 'evel' evel 默认值 每个module都会封装在evel中【 末尾有注释 、能锁定代码错误行数 】 source-map 生成一个sourceMap文件【 末尾有注释 、能锁定代码错误行数 】 hidden-source-map 和上方一样 【 末尾没有注释 、不能锁定代码错误行数 】 inline-source-map DataUrl形式的map文件链接 【 末尾有注释 、能锁定代码错误行数 】 evel-source-map module都会封装在evel中,后方生成DataUrl的map文件链接 【 末尾有注释 、能锁定代码错误行数 】 cheap-source-map 只保留代码行数的map文件【不能锁定代码错误行数 】 cheap-module-source-map 只保留代码行数的map文件,对于外部的混入,也可以剔除出去【 、能锁定代码错误行数 】 推荐使用 devServe const path = qeruire('path') module.exports = { mode: 'development', entry: './main.js', devServe: { static: path.resolve(__dirname, './dist'), //指向当前的物流路径 compress: true, //是否进行代码压缩 port: 3000, //配置端口号 headers: {}, //请求头信息配置 proxy: {}, //设置代理 https: true, //将http改成https http2: true, //和上面一样，自带有https自签名证书 //当是单页面应用时，路由可能识别不了，可以配置historyApiFallback来避免报错 historyApiFallback: true, host: '0.0.0.0', //开发服务器主机, hot: true, //模块热替换，默认true liveReload: true, //热更新功能，默认true } } 模块解析 resolve: { //模块解析 alias: { //配置别名 'assets': '@/assets', 'components': '@/components' }, extensions: ['.json', 'js', 'vue'], //配置扩展名优先级，从前往后 } webWorks index.js const worker = new Worker(new URL('./work.js',import.meta.url)) worker.postMessage({}) //数据传给worker中 worker.onmessage = (message)=>{} //worker返回的结果 work.js self.onmessage = (message)=>{ //接受主线程发过来的信息 self.postMessage({ //把信息返回给主线程 info:111 }) } 外部扩展 externalsType: 'script', //下方链接放入的标签类型 externals: { //定义外部的第三方包 //$ 表示暴露的Jquery别名 jquery: ['JQuery的链接', '$'] } sideEffects 文件是否具体副作用 package.json sideEffects:true //保留所有未引用的文件 sideEffects:false //删除所有未引用的文件 css文件注入后不会被引用 sideEffects:['*.css','index.js'] //指定保留的文件名 shimming 预置依赖 兼容 第三方库的全局变量 实现follify(运行时环境的垫片) 按需加载 预置全局变量 const webpack = require('webpack') module.exports = { plugins: [ new webpack.ProvidePlugin({ //将下方的lodsh和jquery配置成全局变量 _: 'lodsh', $: 'JQuery' }) ], } 覆盖打包后文件的this指向 当模块运行在common.js上下文时，this指向的是module.exports中 module: { rules: { rest: require.resolve('./index.js'),// require.resolve 路径解析 use: 'imports-loader?wrapper=window' //覆盖this指向为window } } 模块联邦（Module Federation） 待引用应用 const { ModuleFederationPlugin } = require('webpack').container module.exports = { plugins: [ new ModuleFederationPlugin({ name: 'anv', //模块联邦的名字，后续其他模块用名字来访问知道模块 filename: 'index.js', //使用此模块联邦的应用名 remotes, //引用其他应用的模块联邦名字 exposes: { //暴露给外部使用的组件 './Header': './sec/head.js', //前面是key值，外部应用使用时拼接用的 }, shared: {}, //共享的模块 }) ] } 引用应用 module.exports = { plugins: [ new ModuleFederationPlugin({ //使用上面的模块联邦 //nav为上面的模块联邦名 name: 'anv', //index.js为上面的应用名 filename: 'index.js', remotes: { nav: 'nav@http://xxxxx:3000/index.js' } }) ] } //这儿的haider就是上面的 './Header': './sec/head.js' import('nav/Header').then(message=>{}) babel transformRuntime 全部辅助函数，兼容 await和async 语法糖 \"babel-loader\": \"^6.26.0\",//webpack中babel解析es6的桥梁，解析成低版本js代码 \"@babel/core\": \"^7.8.4\",//babel核心模块 \"@babel/plugin-transform-runtime\": \"^7.18.5\", //需要transformRuntime时，自动require打包 \"@babel/preset-env\": \"^7.18.2\",//babel预设 babel插件的集合 \"@babel/register\": \"^7.8.3\", 补充 绝对路径 const path = qeruire('path') //__dirname 获取到当前文件的绝对路径 //./dist 基于上面的路径，获取到dist的绝对路径 path.resolve(__dirname,'./dist') 查看模块依赖图 --- webpack-bundle-analyzer "},"工具导航/在线小工具.html":{"url":"工具导航/在线小工具.html","title":"在线小工具","keywords":"","body":"在线工具 时间戳在线 草料二维码 正则表达式在线测试 RGB到十六进制颜色转换器 "},"工具导航/插件工具官网.html":{"url":"工具导航/插件工具官网.html","title":"插件工具官网","keywords":"","body":"插件工具官网 ECharts NutUI-Bingo lucky-canvas Vue I18n "},"工具语法/git.html":{"url":"工具语法/git.html","title":"git","keywords":"","body":"git SourceTree git init //初始化仓库 git add . //添加到暂存区 git status //查看git此时提交状态 git commit -m '提交备注' //提交到本地仓库 git log //查看提交记录 git reset --hard HEAD~1 //回退上一个版本，~2就是回退两个版本 git reflog //操作记录 git reset --hard 6位版本号 //切换提交版本 操作记录处获取版本号 git remote add 别名(origin) 远程仓库地址 //绑定git远程仓库 git push -u origin 推送的分支名称 //将内容推送到远程仓库，-u记住地址，下次直接git push origin 推送的分支名称 git clone 仓库地址 //项目克隆 git pull 远程仓库地址 分支名称 //拉取远程仓库 --force //强制推送 git branch -a //查看所有分支 git checkout -b aa //创建新的分支aa git checkout aa //切换到aa分支的 git push origin aa //推送aa分支到远程仓库aa分支 git push origin master:aa //推送master分支到远程仓库aa分支 git push origin :aa //删除远程仓库aa分支 git branch -d aa //删除本地aa分支 .gitigonre 忽略文件 node_modules //忽略node_modules 文件夹 /dist //忽略dist 文件夹 "},"工具语法/mockjs.html":{"url":"工具语法/mockjs.html","title":"mock","keywords":"","body":"使用mockjs 项目安装mock npm install mockjs npm install @types/mockjs 项目中新建mock文件 //引入mock模块 import Mock from 'mockjs' 将mock文件在app.vue中导入 import \"./mock/mock.ts\"; mock语法 方法 参数 注释 @boolean min?, max?, current? 布尔值 @natural min?, max? 自然数 @integer min?, max? 整数 @float min?, max?, dmin?, dmax? 浮动数 @cword pool?, min?, max? 文本 @ctitle min?, max? 标题 @csentence null 句子 @cparagraph null 段落 @increment null 自增id @cname null 姓名 @id null 身份证 @city(true) null 地址 @image size?, background?, foreground?, format?, text? 图片 @date yyyy-MM-dd hh:mm:ss 时间 @name true 名字 @cname null 中文名 @url null 路径 @email null 邮箱 @ip null ip @county(true) null 地址 @guid null guid 生成字符串 生成指定次数字符串 import Mock from 'mockjs' Mock.mock({ \"string|4\":\"哈哈\" }) 生成指定范围长度字符串 Mock.mock({ \"string|1-8\":\"哈哈\" }) 生成文本 生成一个随机字符串 Mock.mock({ \"string\":\"@cword\" }) 生成指定长度和范围 Mock.mock({ string:\"@cword(1)\", str :\"@cword(10,15)\" }) 生成标题和句子 生成标题和句子 Mock.mock({ title:\"@ctitle(8)\", sentence:\"@csentence\" }) 生成指定长度的标题和句子 Mock.mock({ title:\"@ctitle(8)\", sentence:\"@csentence(50)\" }) 生成指定范围的 Mock.mock({ title:\"@ctitle(5,8)\", sentence:\"@csentence(50,100)\" }) 生成段落 随机生成段落 Mock.mock({ content:\"@cparagraph()\" }) 生成数字 生成指定数字 Mock.mock({ \"number|80\":1 }) 生成范围数字 Mock.mock({ \"number|1-99\":1 }) 生成自增id 随机生成标识 Mock.mock({ id:\"@increment\" }) 生成姓名-地址-身份证 随机生成姓名-身份证-地址 Mock.mock({ name:\"@cname()\", idCard:\"@id()\", address:\"@city(true)\" }) 随机生成图片 生成图片：@image('200x100', '#50B347', '#FFF', 'Mock.js') Mock.mock({ name:\"@image('200x100', '#50B347', '#FFF', 'Mock.js')\" }) 参数1：图片大小 参数2：图片背景色 参数3：图片前景色 参数4：图片格式 参数5：图片文字 生成时间 @Date 生成指定格式时间：@date(yyyy-MM-dd hh:mm:ss) 指定数组返回的参数 指定长度：‘date|5’ 指定范围:'data|5-10' 数组组合 Mock.mock({ 'list|50-99':[ { name:'@cname', address:'@city(true)', id:'@increment()' } ] }) mock拦截请求 Mock.mock('api/post/news','post/get',(data:any)=>{ let { id,status } = data return{ status:200, message:\"获取数据成功\" } }) mock 多个拦截 封装 在 app.vue 引用 import \"./mock/mock.ts\" 文件 (main.ts报错) ts 中引用 mockjs 需要在 shims-vue.d.ts 中添加声明(declare module 'mockjs';) mock.js import Mock from 'mockjs'; import * as mockList from './index'; interface mockInfoInf { path: string; code?: string; data: any; msg?: string; total?: number; ok?: boolean; } const defaultMockInfo: mockInfoInf = { path: 'mock', code: '200', data: '', msg: '成功', }; function init() { let mockmockInfos: Array = []; for (let key in mockList) { const mockInfo = (mockList)[key]; if (mockInfo.show) { mockmockInfos.push(mockInfo); } } mockmockInfos.forEach((mockInfo: mockInfoInf) => { initMock(mockInfo); }); } function initMock(mockInfo: mockInfoInf) { mockInfo = { ...defaultMockInfo, ...mockInfo }; const path = new RegExp(mockInfo.path.replace('/', '\\\\/')); const data = mockInfo.data.data ? mockInfo.data.data : mockInfo.data; const response = { code: mockInfo.code, data, msg: mockInfo.msg, }; Mock.mock(path, (data: any) => { handleRequest(data); return response; }); } function handleRequest(data: any) { let path: string = ''; let param: any = {}; if (data.type === 'GET') { if (data.url.includes('?')) { const urlArray = data.url.split('?'); path = urlArray[0]; if (urlArray.length === 2 && urlArray[1].includes('&')) { const paramArray = urlArray[1].split('&'); paramArray.forEach((item: any) => { const itemArray = item.split('='); const key = itemArray[0]; const value = itemArray[1]; param[key] = value; }); } } else { path = data.url; } } if (data.type === 'POST') { path = data.url; param = JSON.parse(data.body); } console.log({ path }); console.table(param); } init(); index.js import Mock from 'mockjs'; /* @increment 自增id @cname 随机姓名 @id 随机身份证 @city(true) 随机地址 @boolean 随机布尔值 @natural 随机自然数 @cword 随机字符串 @ctitle 随机标题 @csentence 随机句子 @cparagraph 随机段落 @image('200x100', '#50B347', '#FFF', 'Mock.js') 随机图片 @date(yyyy-MM-dd hh:mm:ss) 随机时间 */ //banner export class banner { static show: boolean = true; static path: string = '/TicketBuyList'; static data: any = Mock.mock({ pageSize: 10, total: 100, totalPage: 10, 'list|50-99': [ { id: '@increment()', name: '@cname', tickeName: '黑龙江@city门票', buyNum: '@natural(1,10)', }, ], }); } export class banner21 { static show: boolean = true; static path: string = '/admin/languageCfg/store'; static msg: string = '成功'; static data: any = Mock.mock({ 'data|50-99': [ { name: '@cname', address: '@city(true)', id: '@increment()', }, ], }); } "},"工具语法/Markdown.html":{"url":"工具语法/Markdown.html","title":"Markdown","keywords":"","body":"Markdown # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 *斜体文本* **粗体文本** ***粗斜体文本*** *** ~~删除线~~ 下划线 * 第一行 * 第二行 1. 第一行 2. 第二行 > 区块引用 >> 区块嵌套引用 ` 行代码 ` ​``` 代码块 [链接名称](链接地址) ![图片描述](本地链接或者URL地址) ### Typora 快捷键 ```css Ctrl + 1 ：一级标题 Ctrl + 2 ：二级标题 Ctrl + 0 ：段落 Ctrl + = ：提升标题等级 Ctrl + - ：降低标题等级 Ctrl + Home ：跳转到文首 Ctrl + End ：跳转到文末 Ctrl + Tab ：应用内窗口切换 Ctrl + / ：源代码模式 Ctrl + \\ ：清除样式 Ctrl + [ ：减少缩进 Ctrl + ] ：增加缩进 Ctrl + 逗号 ：偏好设置 Ctrl + B ：加粗 Ctrl + D ：选中当前词 Ctrl + E ：选中当前格式文本 Ctrl + I ：斜体 Ctrl + U ：下划线 Alt + shift + 5 ：删除线 Ctrl + J ：跳转到所选内容 Ctrl + K ：超链接 Ctrl + L ：选中当前行 Ctrl + shift + I ：插入图片 Ctrl + shift + K ：插入代码块 Ctrl + shift + M ：插入公式 Ctrl + shift + [ ：有序列表 Ctrl + shift + ] ：无序列表 Ctrl + O ：打开 Ctrl + P ：快速打开 Ctrl + T ：插入表格 Alt + Ctrl + P ：选择段落或块 Ctrl + shift + 1 ：大纲 Ctrl + shift + 2 ：文档列表 Ctrl + shift + 3 ：文件树 Ctrl + shift + 9 ：实际大小 Ctrl + shift + D ：删除当前词 Ctrl + shift + E ：使用上一次设置导出 Alt + Ctrl + shift + P ：删除块 Alt + Ctrl + shift + L ：删除当前行或句 Alt + Ctrl + shift + E ：删除当前格式文本 shift + F10 ：快捷操作弹窗 shift + F12 ：开发者工具 "},"工具语法/Moment.html":{"url":"工具语法/Moment.html","title":"Moment","keywords":"","body":"Moment Moment 原型通过 moment.fn 公开 Moment.prototype.format == moment.fn.format == moment＃format 解析 moment() 获取当前的日期和时间 moment() //上下相同 moment(new Date()) moment(Number) 时间戳转换 moment(1318781876406) moment(Date) 使用预先存在的原生 Javascript Date 对象来创建 Moment var day = new Date(2011, 9, 16); var dayWrapper = moment(day); 默认值 moment(5, \"DD\"); // 本月的第 5 天 moment(5, \"HH\"); // 今天 5:00:00.000 moment(\"4 05:06:07\", \"DD hh:mm:ss\"); // 本月的第 4 天 05:06:07.000 moment(3, \"MM\"); // 今年第三个月（三月） moment(\"Apr 4 05:06:07\", \"MMM DD hh:mm:ss\"); // 今年四月的第 4 天 05:06:07.000 取值/赋值 millisecond() 获取或设置毫秒，接受 0 到 999 之间的数字 超出范围，则会冒泡到秒钟 moment().millisecond(Number); moment().milliseconds(Number); second() 获取或设置秒钟 , 接受 0 到 59 之间的数字 超出范围，则会冒泡到分钟 moment().second(Number); moment().seconds(Number); minute() 获取或设置分钟 , 接受 0 到 59 之间的数字 超出范围，则会冒泡到小时 moment().minute(Number moment().minutes(Number); hour() 获取或设置小时, 接受 0 到 23 之间的数字 超出范围，则会冒泡到日期 moment().hour(Number); moment().hours(Number); date() 获取或设置月份的日期, 接受 1 到 31 之间的数字 超出范围，则它将会冒泡达到月份 moment().date(Number); month() 获取或设置月份，接受 0 到 11 之间的数字 超出范围，则会冒泡到年份 月份是零索引的，因此一月是月份 0 支持月份名称设置 moment().month(string | number); year() 获取或设置年份，接受 -270,000 至 270,000 之间的数字 moment().year(Number); moment().years(Number); 链接操作 链接多个操作以构造一个日期，应从年份、月份、日期等依次开始 moment().year(year).month(month).date(day) dayOfYear() 获取或设置年份的日期，接受 1 到 366 之间的数字 超出范围，则会冒泡到年份 moment().dayOfYear(Number); day() 获取或设置星期几，此方法可用于设置星期几，其中星期日为 0、星期六为 6 超出范围，则会冒泡到其他星期 也支持星期名称 moment().day(Number|String); moment().days(Number|String); week() 获取或设置年份的星期 moment().week(Number); moment().weeks(Number); quarter() 获取或设置季度 ，接受 1 到 4之间的数字 超出范围，则会冒泡到下一年 moment().quarter(Number); moment().quarters(Number); get(string) moment().get('year'); moment().get('month'); moment().get('date'); moment().get('hour'); moment().get('minute'); moment().get('second'); moment().get('millisecond'); set(string,number) moment().set('year', 2013); moment().set('month', 3); moment().set('date', 1); moment().set('hour', 13); moment().set('minute', 20); moment().set('second', 30); moment().set('millisecond', 123); moment().set({'year': 2013, 'month': 3}); max () 返回给定的 moment 实例的最大值 moment.max(Moment[,Moment...]); moment.max(Moment[]); moment.max(a, b); // b min() 返回给定的 moment 实例的最小值 moment.min(Moment[,Moment...]); moment.min(Moment[]); moment.min(a, b); // a moment.min([a, b]); // a 操作 add() 通过增加时间来改变原始的 moment 可以使用单词简写 moment().add(Number, String); moment().add(Duration); moment().add(Object); moment().add(7, 'days'); moment().add(7, 'd'); subtract() 通过减去时间来改变原始的 moment moment().subtract(Number, String); moment().subtract(Duration); moment().subtract(Object); moment().subtract(7, 'days'); startOf(String) 将原始的 moment 设置为时间单位的开头 moment().startOf('year'); // 设置为今年1月1日上午 12:00 moment().startOf('month'); // 设置为本月1日上午 12:00 moment().startOf('quarter'); // 设置为当前季度的开始，即每月的第一天上午 12:00 moment().startOf('week'); // 设置为本周的第一天上午 12:00 moment().startOf('isoWeek'); // 根据 ISO 8601 设置为本周的第一天上午 12:00 moment().startOf('day'); // 设置为今天上午 12:00 moment().startOf('date'); // 设置为今天上午 12:00 moment().startOf('hour'); // 设置为当前时间，但是 0 分钟、0 秒钟、0 毫秒 moment().startOf('minute'); // 设置为当前时间，但是 0 秒钟、0 毫秒 moment().startOf('second'); // 与 moment().milliseconds(0); 相同 endOf(String) 将原始的 moment 设置为时间单位的末尾 moment().endOf(\"year\"); // 将 moment 设置为今年的 12 月 31 日 23:59:59.999 显示 format() 显示格式 moment().format(); moment().format(String); 年份:YYYY 月份:M 月份的日期:D 小时24:HH 小时12:hh 分钟:mm 秒钟:ss 季度:Q 年份的星期:w 星期几：d 子午线：A(AM PM) 年份的日期：DDD Unix 时间戳:X(秒) x(毫秒) valueOf() 获得当前时间戳 moment().valueOf(); +moment(); daysInMonth() 获取当月天数 moment().daysInMonth(); toArray() 返回一个数组，该数组反映了 new Date() 中的参数 moment().toArray(); // [2013, 1, 4, 14, 40, 16, 154]; toJSON() 获取UTC（世界时）格式的json字符串 moment().toJSON(); //'2023-05-05T07:08:31.045Z' toObject() 返回一个包含年份、月份、月份的日期、小时、分钟、秒钟、毫秒的对象 moment().toObject(); //{years: 2023, months: 4, date: 5, hours: 15, minutes: 11, …} 查询 isBefore() 检查一个 moment 是否在另一个 moment 之前 moment('2010-10-20').isBefore('2010-10-21'); // true isSame() 检查一个 moment 是否与另一个 moment 相同 moment('2010-10-20').isSame('2010-10-20'); // true isAfter() 检查一个 moment 是否在另一个 moment 之后 moment('2010-10-20').isAfter('2010-10-19'); // true isBetween() 检查一个 moment 是否在其他两个 moment 之间 moment('2010-10-20').isBetween('2010-10-19', '2010-10-25'); // true moment('2010-10-20').isBetween('2010-10-19', undefined); // true, 因为 moment(undefined) 等效于 moment() "},"设计原则/类之间的关系.html":{"url":"设计原则/类之间的关系.html","title":"类之间的关系","keywords":"","body":"类之间的关系 泛化关系 -- 继承 对已有类型进行扩展 派生类继承非抽象类的基类，并且对基类进行一个更细致化的扩展 suv是小汽车的一个泛化关系，suv是小汽车的一个派生类 class Car { showType() { console.log(\"基类的方法\") } } class SvuCar extends Car{ showType(): void { console.log('对基类的二次扩展') } } 实现关系 -- 继承 实现了基类定义了但是不能实现的功能 基类属于一个抽象类，需要派生类进行一个继承，去实现对应的功能 车则是一个抽象的定义，而小汽车则是对车进行了二次的定义并且实现了，所以小汽车是对车进行了一个实现定义的关系 abstract class Transfrom { abstract move(): void } class Bike extends Transfrom { move() { return '实现transfrom' } } const a = new Bike a.move() //'实现transfrom' 聚合关系 -- 非强关联 由几个类进行组合一个类，进行一个方法的实现 类A和类B，类A包含类B， 类B是类A的成员变量 双方不是平级的，是整体和部分的关系 学生聚合起来，组成学习小组，xx学习小组撤销了，学生并不会因此消失 class Student { //学生 name: string constructor(name: string) { this.name = name } } class Group { //小组 member: Array constructor() { this.member = new Array() } add(item: Student) { this.member = [...this.member, item] } } const group = new Group() group.add(new Student('小x')) //添加小组成员 组合关系 -- 强关联 由多个类组成一个类，进行一个方法的实现 A类由B类C类组成,A类消失，B类C类也随之消失 双方不是平级的，是整体和部分的关系 若干个班级组成xx学校，xx学校消失了，xx学校xx班级也随之消失 class School { //学校 grades: Array = new Array() initGrades(...grade: Grade[]) { this.grades = [...this.grades, ...grade] } deinit() { this.grades = new Array() } } class Grade { //班级 name: string constructor(name: string) { this.name = name } } const school = new School() school.initGrades(new Grade('一年级x班'), new Grade('二年级x班')) 关联关系 -- 强关联 A类中使用B类，A类就对B类进行一个关联 A类销毁时，A类对类的关联也随之消失 关联关系双方是平级的，是个体和个体的关系 class IdCar { //身份证 id: number constructor(id: number) { this.id = id } } class Civics { //公民信息 name: string idCard: IdCar constructor(name: string, id: number) { this.name = name this.idCard = new IdCar(id) } ShowMeYourCard(): IdCar { return this.idCard } } 依赖关系 -- 临时性 -- 动态性 当A类某个参数依赖于B类，当A类需要某个参数时，B类则对A类进行依赖注入 class IdCar { //身份证 id: number constructor(id: number) { this.id = id } } class Civics { //公民身份信息 name: string idCard: IdCar constructor(name: string, idCar: IdCar) { this.name = name this.idCard = idCar } } let a = new Civics('张三',new IdCar(123))//公民内部的IdCar就是初始化的注入 "},"设计原则/设计原则.html":{"url":"设计原则/设计原则.html","title":"设计原则","keywords":"","body":"设计原则 单一职责原则表达实现类要职责单一 里氏替换原则表达不要破坏继承体系 依赖倒置原则表达面向接口编程 接口隔离原则表达在设计接口的时候要精简单一 迪米特法则表达要降低耦合 开闭原则是总纲，表达要对扩展开放，对修改关闭。 单一职责原则(SRP) 定义 一个类应该只有一个发生变化的原因，即一个类只负责一项职责 核心 解耦和增强内聚性 优点 降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多。 提高类的可读性，提高系统的可维护性。 变更引起的风险降低，变更是必然的，如果 SRP 遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 开闭原则(OCP) 定义 软件中的实体（类，模块，函数等等）应该对扩展开放，对修改封闭 一个实体是允许在不改变它的源代码的前提下变更它的行为 优点 保持系统的可维护性和代码的重用性 想遵守开闭原则 , 在做系统设计（概要设计、详细设计）的时候就要*考虑到未来的扩展和改变 里氏替换原则(LSP) 定义 派生类（子类）对象可以在程序中代替其基类（父类）对象 优点 实现开闭原则的重要方式之一 克服了继承中重写父类造成的可复用性变差的缺点 类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性 替换原则 任何基类可以出现的地方，子类一定可以出现 子类必须完全实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类可以实现自己特有的方法 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格（类向上转换是安全的，向下转换则不一定是安全） 子类的实例可以替代任何父类的实例，不成立则不符合替换原则 注意点 子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法 LSP 是继承复用的基石 里氏代换原则是对开闭原则的补充 依赖倒置原则(DIP) 定义 高层模块，低层模块，细节都应该依赖抽象 高层模块不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 细节 -- 较为具体的东西，比如具体的类 抽象 -- 具有契约性、共同性、规范性的表达 优点 减少类间的耦合性 降低并行开发引起的风险 提高代码的可读性和可维护性 注意点 分清细节与抽象 变量的声明类型尽量是抽象类或接口 尽量不要覆写基类的方法 继承要遵循里氏替换原则 迪米特法则(LOD) 定义 只和对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法 两个软件实体无须直接通信，那么就不应当发生直接的相互调用 ，可以通过第三方转发该调用 依赖者的角度来说，只依赖应该依赖的对象 被依赖者的角度说，只暴露应该暴露的方法 优点 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性 实现原则 类的划分：应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用 类的结构设计： 每一个类都应当尽量降低其成员变量和成员函数的访问权限 类的设计 ： 只要有可能，一个类型应当设计成不变类 对其他类的引用： 一个对象对其他对象的引用应当降到最低 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法） 注意点 过度使用迪米特法则会系统产生大量的中介类，增加系统复杂性，模块之间的通信效率降低。所以，在釆用时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 接口隔离原则(ISP) 定义 客户端不应该依赖它不需要的接口 一个类对另一个类的依赖应该建立在最小的接口上 优点 建立单一接口， 不是该功能的功能不需要 尽量细化接口，接口中的方法尽量少 提高系统的灵活性和可维护性 区别 单一职责原则 注重的是职责 主要是约束类，其次才是接口和方法 针对的是程序中的实现和细节 接口隔离原则 注重对接口依赖的隔离 主要约束接口 , 主要针对抽象 针对程序整体框架的构建 注意点 接口尽量小，但是要有限度 只暴露给调用的类它需要的方法 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好 组合/聚合复用原则(CARP) 定义 尽量使用组合/聚合，尽量不要使用继承 复用方式 组合 -- 任何环境 将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能 优点： 新对象存取成分对象的唯一方法是通过成分对象的接口 复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的 复用所需的依赖较少 每一个新的类可以将焦点集中在一个任务上 组合/聚合是动态行为 缺点： 有较多的对象需要管理 继承 -- 一些环境 继承复用通过扩展一个已有对象的实现来得到新的功能 优点： 新的实现比较容易，因为基类的大部分功能都可以通过继承自动的进入子类 修改或扩展继承而来的实现较为容易 缺点： 继承复用破坏了包装，因为继承超类的的实现细节暴露给子类。由于超类的内部细节常常对子类是透明的，因此这种复用是透明的复用，又称“白箱”复用 如果基类的实现发生改变，那么派生类的实现也不得不发生改变 从超类继承而来的实现是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性 使用原则 满足 “Is-A” 的关系是才可以使用继承 组合却是一种 “Has-A”（整体与部分）的关系 注意点 首选组合，然后才是继承 继承时应该严格的遵守里氏替换原则，必须满足 “Is-A” 的关系是才能使用继承 "},"设计原则/设计模式.html":{"url":"设计原则/设计模式.html","title":"设计模式","keywords":"","body":"一、构造器模式 class Employee { name age constructor(name: string, age: number) { this.name = name this.age = age } say() { console.log(this.name + this.age) } } const employee1 = new Employee(\"ker\", 100) const employee2 = new Employee(\"ker\", 100) employee1.say 二、工厂模式 定义 又名静态工厂模式 根据参数的**不同返回不同类的实例 class User { role pages constructor(role: string, pages: Array) { this.role = role this.pages = pages } static UserFactory(role: string) { switch (role) { case 'user': return new User('user', [1]) case 'admin': return new User('admin', [1, 2]) } } } let a = new User.UserFactory(\"admin\") 优点 将对象创建和对象业务逻辑部分分离，降低系统的耦合性，使修改更加容易 工厂方法是静态的，可以直接通过类名调用 缺点 工厂方法是静态的，不能被派生类继承 如果工厂需要加入新的产品，会对工厂类进行修改，违背了开闭原则 抽象工厂模式 不直接生成实例，而是用对于产品类蔟的创建 //创建基类 class User { name role router constructor(name: string, role: string, router: number[]) { this.name = name this.role = role this.router = router } welcome() { console.log(`欢迎回来${this.name}`) } } //创建对于派生类 class UserAdmin extends User { constructor(name: string) { super(name, 'userRole', [1,]) } dataShow() { console.log(\"重写了方法\") } } //创建对于派生类 class Admin extends User { constructor(name: string) { super(name, 'adminRole', [1, 2, 3]) } dataShow() { console.log(\"重写了方法\") } } //通过传入的值 选择返回对于的派生类 function getRoleFactory(role: string) { switch (role) { case \"userRole\": return UserAdmin case \"adminRole\": return Admin } } let RoleClass: any = getRoleFactory('adminRole') let userInfo = new RoleClass('管理员') 优点 创建基类，根据不同的要求创建不同的派生类，避免修改基类内容 三、建造者模式 侧重点----创建对象的的过程,甚至是每一个细节 //比赛信息--表示层 class MatchInfo { init() { console.log(\"初始化\") } getDate() { let res = { code: 200, data: [], msg: '请求成功' } console.log(res) } editData(res: any) { let data = res.data console.log(data) } } //用户信息--表示层 class UserInfo { init() { console.log(\"初始化\") } getDate() { let res = { code: 200, data: [], msg: '请求成功' } console.log(res) } editData(res: any) { let data = res.data console.log(data) } } //构建层 class Creator { async startBuild(builder: any) { builder.init() const res = await builder.getDate() builder.editData(res) } } //使用类 const op = new Creator() op.startBuild(new MatchInfo()) op.startBuild(new UserInfo()) 优点 将负责对象的构建层和表示层相互分离 构建过程可采用不同的表示层 "},"网络/TCP&IP协议族.html":{"url":"网络/TCP&IP协议族.html","title":"TCP/IP 协议族","keywords":"","body":"TCP/IP 协议族 TCP/IP 协议族是 Internet 最基本的协议，HTTP 协议是它的一个子集 按层次分为应用层、传输层、网络层、链路层 TCP/IP 协议族内预存了各类通用的应用服务协议 概念模型 应用层 负责应用程序间的数据通讯的 FTP File Transfer Protocol，文件传输协议 通常把网页或程序传到 Web 服务器上，由于 FTP 传输效率非常高，传输大的文件时，一般也采用该协议。 FTP 协议默认使用 TCP 端口中的 20 和 21 这两个端口，20 用于传输数据，21 用于传输控制信息 DNS Domain Name System，域名系统 主机名转换成 IP 地址 HTTP HyperText Transfer Protocol，超文本传输协议 采用了请求/响应模型 定义了Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端 传输层 传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议 负责两台主机间的数据传输的 TCP Transmission Control Protocol，传输控制协议 TCP协议是全双工的，即发送数据和接收数据是同步进行的 TCP协议在建立和断开连接时有三次握手和四次挥手, 因此传输的过程中更稳定可靠,但没UDP那么高效 UDP User Data Protocol，用户数据报协议 UDP协议是面向无连接的, 正式传递数据之前不需要先建立连接 UDP 协议不保证有序且不丢失的传递到对端，但是不够稳定，因而UDP协议比TCP更加高效和轻便 数据大小有限制（64k） 网络层 规定了数据通过怎样的传输路线到达对方计算机传送给对方 负责网络上的地址管理和路由选择的 IP 指明了节点被分配到的地址，是网络层及其以上层使用的地址 通信链路层 细分为 物理层 和 数据链路层 数据链路层 负责设备之间的数据帧的传送和识别的 物理层 负责将数据转换成信号，再将信号转换为数据的 处理过程 "},"网络/DNS.html":{"url":"网络/DNS.html","title":"DNS","keywords":"","body":"DNS 将域名转换成网络可以识别的IP地址 作用 正向解析 根据域名查找对应的IP地址，查询hosts文件 FQDN--------IP(一对多)------一般使用正向解析 反向解析 根据IP地址查找对应的域名 IP------------FQDN 反向解析不是很常用，只在一些特殊场合才会用到，比如：邮 件服务器中来阻拦垃圾邮件 域名级别 DNS解析器 可被视为被要求去图书馆的某个地方查找特定图书的图书馆员 负责发出其他请求，以便满足客户端的 DNS 查询 DNS解析器一般集成在客户端中，由客户端中的解析器程序去处理DNS查询请求 根域名服务器 根域名 解释 . 根（默认隐藏） TLD 名称服务器 一级域名 解释 .com 工商企业 .net 网络供应商 .edu 教育机构 .cn 中国国家域名 .org 团体组织 .gov 政府部门 二级域名 .net.cn .edu.cn .com.cn 权威性域名服务器 权威性域名服务器 .baidu.com .wangyi.cn 主机名 主机名 解释 mail 邮箱 www World Wide Web 缓存 浏览器默认也有DNS缓存机制，Chrome和Firefox浏览器默认都是1分钟缓存。 Windows默认的DNS域名老化时间是5分钟，默认开启DNSlient，可以缓存一些常用的域名 Linux(CentOS、FreeBSD)默认无DNS缓存，但可使用nscd或者systemd-resolved开操作系统DNS缓存，但不建议这么，Ubuntu默认运行systemd-resolve daemon 用于名称服务器缓存 查询方式 递归查询 本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。 迭代查询 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。 "},"网络/TCP.html":{"url":"网络/TCP.html","title":"TCP","keywords":"","body":"TCP Transmission Control Protocol，即 传输控制协议 基于两端的ip和端口和协议来建立的，在切换网络场景时，会改变本身的ip，这就导致tcp连接必须重新创建 三次握手期间，任何1次未收到对面的回复，则都会重发 特点 面向链接 使用TCP传输数据前，必须先建立TCP连接欸；传输完成后再释放连接 全双工同行 建立TCP连接后，通信双方都能发送数据 可靠 数据不丢失、无差错、不重复 数据按序到达 面向字节流 流：流入/流出进程的字符序列 TCP一次传输的报文长度有限制，若太大则需分块、分次传输 分块、分次传输的数据，由于TCP连接的可靠性，接收方可按顺序接收数据块并重新组成分开之前的数据流 故TCP看起来就像直接互相传输字节流，所以叫 面向字节流 优缺点 优点 数据传输可靠 缺点 效率慢（因需建立连接、发送确认包等） 名词解释 SYN 建立连接 HIN 终止控制位 ACK 响应 seq 序号 ack 确认号字段 MSL 最长报文段寿命 三次握手 第一次握手 确认客户端发送正常 客户端向服务器发送1个连接请求的报文段 报文段信息 同步标志位：SYN = 1 随机选择一个起始序列：seq = x 不携带数据（SYN位被设置为1不能携带数据,消耗一个序列号） 状态 客户端进入 同步已发送 状态（SYN_SEND） 等待服务器确认 第二次握手 确认服务端接受发送正常 服务器收到请求连接报文段后，同意连接则向客户端发回连接确认的报文段 报文段信息 同步标志位：SYN = 1 确认标志位：ACK = 1 随机选择一个起始序号：seq = y 确认号字段：ack = x + 1 不携带数据（SYN位被设置为1不能携带数据,消耗一个序列号） 状态 服务器进入 同步已接收 状态（SYN_RCVD) 第三次握手 确认客户端接受正常 客户端收到确认报文段后，向服务器再次发出连接确认报文段 报文段信息 确认标志位： ACK = 1 序号：seq = x+1 确认号字段：ack = y+1 可携带数据（SYN != 1,不携带不消耗序列号) 状态 客户端、服务器都进入已创建状态（ESTABLISHED） 可开始发送数据 四次挥手 第一次挥手 客户端向服务器发送连接释放的报文段 客服端停止再主动发送数据 报文段信息 终止控制位: FIN = 1 报文段序号: seq = u (前面传送数据最后1个字节的序号+1) 可携带数据(FIN = 1 ,不携带也消耗一个序号) 状态 客户端进入 终止等待1 状态( FIN-WAIT-1 ) 等待服务器的确认 第二次挥手 服务器收到连接释放报文段,则向客户端发回连接释放确认的报文段 报文段信息 确认标记位: ACK = 1 报文段序号: seq = v ( 前面传送数据最后1个字节的序号+1) 确认号字段: ack = u + 1 状态 服务器进入 关闭等待 状态(CLOSE-WAIT) 客户端收到服务器的确认后,进入 终止等待2 状态(FIN-WAIT-2),等待服务器发出释放连接请求 客户端 !=> 服务器 服务器=>客户端 第三次挥手 服务器已无要向客户端发送数据,则发出释放连接的报文段 报文段信息 终止控制位: FIN = 1 确认标志位: ACK = 1 报文段序号: seq = w 确认号字段: ack = u + 1(重复上次已发送的) 可携带数据(FIN = 1 ,不携带也消耗一个序号) 状态 服务器进入 最后确认 状态(LAST-ACK) 第四次挥手 客户端收到连接释放报文段后,则向服务器发回连接释放确认的报文段 报文段信息 确认标志位: ACK = 1 报文段序号: seq = u + 1 确认号字段: ack = w + 1 可携带数据(FIN = 1 ,不携带也消耗一个序号) 状态 客户端进入 时间等待 状态(TIME-WAIT) 服务器进入 关闭状态 (CLOSED) 经过时间等待计时器设置的时间2MSL后,,客户端才进入 关闭 状态(CLOSED) 为什么客户端关闭要等待2msl时间 保证客户端发送的最后1个连接释放确认报文能到达服务器 防止 早已失效的连接请求报文 出现在本连接中 "},"网络/IP.html":{"url":"网络/IP.html","title":"IP","keywords":"","body":"IP 定义 整个 TCP/IP 协议族的核心，也是构成互联网的基础，位于 TCP/IP 模型的网络层 用于屏蔽下层物理网络的差异，为上层提供统一的 IP 数据报 无连接的投递服务 发送端可任何时候自由发送数据，接收端不知道自己会在何时从哪里接收到数据 每个 IP 数据报独立处理和传输， 一台主机发出的数据报序列，可能会走不同的路径 不可靠的投递服务 IP 协议本身不保证 IP 数据报投递的结果 传输的过程中，IP 数据报可能会丢失、重复、延迟和乱序等 IP 协议不对内容作任何检测，出现问题也不会通知收发双方 尽力投递服务 IP 数据报的长度超过 MTU ( 最大传输单元 )，网络层就会把这些报文分割, 分组进行传送，以适应具体的传输网络 IP 地址 给因特网上的每台设备都规定了其全世界唯一的地址 192.165.11 -- 使用 “.” 分开不同的字节, 叫做点分十进制表示法 IP 地址和 MAC 地址 IP 地址和 MAC 地址是根据网卡（网络适配器）来配置的 在数据传输过程中， 源 IP 地址和目标 IP 地址在传输过程中是不会变化的 ,但是随着数据的传输，源 MAC 地址和目的 MAC 地址会不断的发生变化 IP 地址的分类 A、B、C 类地址主要分为网络号和主机号两个部分 网络号 表示其属于互联网的哪一个网络 网络地址相同，表明接受方在本网络上（本地网络主机），可以直接把数据包发送到目标主机，无需转发给其他的网络 主机号 表示其属于该网络中的哪一台主机 网络号不相同的主机称之为远程网络主机，远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据 主机号全为 1 指定某个网络下的所有主机，用于广播 主机号全为 0 指定某个网络 子网划分 将传统的两级 IP 地址（网络号 + 主机号）转换成粒度更小的三级 IP 地址（网络号 + 子网号 + 主机号） 将主机地址划分为子网号和子网内的主机号 子网掩码 将某个 IP 地址划分成网络地址和主机地址两部分 将 IP 地址与子网掩码做按位 AND（与）运算（只有两个都为 1，结果才为 1，否则为 0），得出的就是网络地址 "},"网络/HTTP/HTTP.html":{"url":"网络/HTTP/HTTP.html","title":"HTTP","keywords":"","body":"HTTP 协议 定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端 客户端向服务器发送请求报文，包含请求方法、URL、协议版本、请求头部和请求数据 服务器返回状态行作为响应，包括协议版本、成功或错误代码、服务器信息、响应头部和响应数据 HTTP 是不保存状态的协议，既无状态协议 HTTP报文 请求报文 请求行（请求方法、协议版本） 请求首部（请求URI、客户端信息等 内容实体（用户信息和资源信息等，可为空） 响应报文 状态行（协议版本、状态码） 响应首部（服务器名称、资源标识等） 内容实体（服务端返回的资源信息） 请求方法 GET get 用于获取服务器资源 POST post 用于传输实体主体 PUT put 用于更新某个较为完整的文件 PATCH patch 用于文件的部分内容的更新 DELETE delete 用于删除文件 HEAD head 用于获取报文首部，不返回报文主体 OPTIONS options 用于询问请求URI资源支持的方法 状态码 2XX 成功（这系列表明请求被正常处理了） 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求成功 3XX 重定向（表明浏览器要执行特殊处理） 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求） 304 not modified，协商缓存，与重定向无关 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 首部字段 通用首部 作用（请求报文和响应报文都可能使用） Cache-Control 控制缓存的行为：no-cache（强制向服务器再次验证）、no-store（不做任何缓存）、max-age=111111（资源可缓存最大时间 秒）、public（客户端、代理服务器都可利用缓存）、private（代理服务器不可用缓存） Connection 浏览器想要优先使用的连接类型： keep-alive close（开启和关闭持久连接） Date 创建报文时间 Pragma 只用于请求报文，客户端要求中间服务器不返回缓存的资源 Via 代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割 Transfer-Encoding 传输编码方式：chunked分块传输 Upgrade 要求客户端使用的升级协议，需配合Connection: Upgrade一起使用：websocket Warning 缓存相关问题的警告 请求首部 作用（请求报文专用） Accept 能正确接收的媒体类型：application/json text/plain Accept-Charset 能正确接收的字符集: unicode-1-1 Accept-Encoding 能正确接收的编码格式列表：gzip deflate Accept-Language 能正确接收的语言列表：zh-cn,zh;1=0.9,en,1=0.8 Authorization 客户端认证信息：Bearer dSdSdFFlsfdjasd123，一般存token用 Cookie 发送给服务器的Cookie信息 Expect 期待服务端的指定行为 From 请求方邮箱地址 Host 服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。 If-Match 两端资源标记比较，只有判断条件为真服务端才会接受请求：If-Mach: \"123456，和服务端文件标记比较 If-Modified-Since 本地资源未修改返回 304（比较时间） If-None-Match 本地资源未修改返回 304（比较标记） User-Agent 客户端信息 Max-Forwards 限制可被代理及网关转发的次数 Proxy-Authorization 向代理服务器发送验证信息 Range 请求某个内容的一部分，配合If-Range使用 Referer 请求发起页面的原始URI TE 传输编码方式 响应首部 作用（响应报文专用） Accept-Ranges 告知客户端服务器是否可接受范围请求，是bytes，否none Age 资源在代理缓存中存在的时间 ETag 资源标识，资源发生变化时标识也会发生改变 Location 客户端重定向到某个 URL Proxy-Authenticate 向代理服务器发送验证信息 Server 服务器名字：Apache Nginx WWW-Authenticate 获取资源需要的认证方案 Set-Cookie 需要存在客户端的信息，一般用于识别用户身份 实体首部 作用（补充请求报文或响应报文相关信息） Allow 资源的正确请求方式：GET HEAD POST Content-Encoding 内容的编码格式：gzip deflate Content-Language 内容使用的语言：zh-CN Content-Length request body 长度（即实体主体的大小）： Content-Location 返回数据的备用地址 Content-MD5 Base64加密格式的内容 MD5检验值 Content-Range 响应主体的内容范围 Content-Type 内容的媒体类型（如'application/json;charset=UTF-8'则会发送预检请求） Expires 内容的过期时间 Last_modified 内容的最后修改时间 URI|URL|URN URI - 统一资源标识符 URI是标识逻辑或物理资源的字符序列 主要用于定义项目的标识 URI不涉及协议规范 作用 通过使用位置，名称或两者来标识Internet上的资源 允许统一识别资源 组成内容 ftp://admin:123@mysite.net:8888/share/movie/Black Gump.mkv 资源的命名机制 - ftp: 存放资源的主机名 - admin:123@mysite.net:8888 资源自身的名称 - share/movie/Black Gump.mkv URL - 统一资源定位符 主要用于链接网页 需要指定要使用的协议类型 组成内容 http://www.baidu.com:888/page/index?id=1&name=daxia#article 用于访问资源的协议 - http: 服务器的位置（IP地址或域名），端口号（可选） - www.baidu.com:888 资源在服务器目录结构中的位置 - page/index 片段标识符（可选） - ?id=1&name=daxia#article URN - 统一资源名称 通过名字来标识资源的 它不包含任何协议 作为特定内容的唯一名称使用的 如图书的编号（ISBN）urn:isbn:0234663 区别 URN 和 URL 都是 URI 的子集 URL：指定位置的 URI URN：指定名称的 URI URI：同时指定名称和位置的 URI HTTP版本 HTTP/1.0 使用在一些较为简单的网页上和网络请求上 串行连接 HTTP/1.0 版本称为串行连接或短连接、短轮询 每次发起请求都必须建立新的tcp连接 每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的连接 HTTP/1.1 用于 -- http:// 引入了更多的缓存控制策略 允许范围请求，即在请求头中加入Range头部 请求消息和响应消息都必须包含Host头部 , 以区分同一个物理主机中的不同虚拟主机的域名 持久连接 HTTP/1.1 实现默认所有连接都是持久连接（ 也叫长连接、长轮询 ） 一定时间内，同一域名下的HTTP请求，只要两端都没有提出断开连接，则持久保持TCP连接状态，其他请求可以复用这个连接通道。 容易造成线头阻塞 --- 持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着 管道化持久连接 不用等待响应返回而发送下个请求并按顺序返回响应 响应必须按顺序返回 现代浏览器并未默认开启管道化 HTTP/2.0 用于 -- https:// 两个重要概念 -- 帧（frame）和流（stream） 帧 -- 数据传输的最小的单位 流 -- 多个帧组成的数据流 , 每个流表示一个请求 协议解析 -- 采用二进制格式 使用encoder来减少需要传输的头部大小, 通讯双方各自cache一份头部 fields表 HTTP/2.0多路复用 每个HTTP请求都有一个序列标识符，这样浏览器可以并发多个请求 服务器接收到数据后，根据序列标识符重新排序成不同的请求报文，就不会导致数据错乱 服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文 同一个域名下的所有请求都复用同一个TCP连接，极大增加了服务器处理并发的上限 当连接中出现了丢包的情况，就会导致整个 TCP 都要开始等待重传，也就导致后面的所有数据都被阻塞了 HTTP/3.0 放弃使用TCP，而使用基于UIC退出的QUIC协议 避免包阻塞 -- 不同的流之间的数据传输真正实现了相互独立互不干扰 快速重启会话 -- QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据 WEB安全防范 XSS 攻击 CSRF 攻击 点击劫持 中间人攻击 "},"网络/HTTP/web缓存.html":{"url":"网络/HTTP/web缓存.html","title":"web 缓存","keywords":"","body":"web 缓存 Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档 优点： 减少不必要的网络传输 更快的加载页面 减少服务器压力 缺点： 占用内存 强制缓存 如果浏览器判断请求的目标资源命中强缓存，则直接从内存中拿去，无需与服务器做任何通讯 基于Expires实现强缓存 Expires过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况 ,故而不被使用 基于Cache-control实现强缓存 //往响应头中写入需要缓存的时间 //从该资源第一次返回的时候开始，往后的10秒钟内如果该资源被再次请求，则从缓存中读取。 res.writeHead(200, { \"Cache-Control\": \"max-age=10\", }); max-age / s-maxage max-age 表示的时间资源在客户端缓存的时长 s-maxage 资源在代理服务端的缓存时长 //N就是需要缓存的秒数 //从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互 'Cache-Control':'max-age=N' 'Cache-Control':'s-maxage=N' s-maxage代理服务端的缓存时长，必须和public属性一起使用 max-age和s-maxage并不互斥 Cache-control:max-age=10000,s-maxage=200000,public no_cache / no-store no_cache 强制进行协商缓存 no-store 禁止所有的缓存策略 当设置no-cache ,那么该资源会直接跳过强缓存的校验，直接去服务器进行协商缓存 no-cache和no-store是一组互斥属性 public / private public 资源在客户端和代理服务器都可以被缓存 private 资源只能在客户端被缓存，拒绝资源在代理服务器缓存 默认 private public和private是一组互斥属性 协商缓存 基于修改的协商缓存 需要在服务器端读出文件修改时间 将读出来的修改时间赋给响应头的last-modified字段 设置Cache-control:no-cache 当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since ( 服务器第一次修改时候给他的时间 ) 之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而服务器端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源 缺点： 因为是更具文件修改时间来判断的 , 在文件内容本身不修改的情况下 , 依然有可能更新文件修改时间（比如修改文件名再改回来） 当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变 基于 ETag 的协商缓存 将原先协商缓存的比较时间戳的形式修改成了比较文件哈希值 缺点： ETag 需要计算哈希值这样意味着，服务端需要更多的计算开销，会影响服务器的性能 ETag 强验证的哈希值深入每个字节，可以保证文件内容的绝对不变，但是非常消耗计算量 Etag 弱验证提取的是文件的部分属性，整体速度提升，但是准确率不高 总结 关于强缓存，cache-control是Expires的完全替代方案 关于协商缓存,etag是last-modified的补充方案， 具体用哪一个，取决于业务场景 有哈希值的文件设置强缓存即可。没有哈希值的文件（比如 index.html）设置协商缓存 所有带 304 的资源都是协商缓存，所有标注（从内存中读取/从磁盘中读取）的资源都是强缓存 "},"服务器端/node/node基础.html":{"url":"服务器端/node/node基础.html","title":"node-基础","keywords":"","body":"nvm指令 nvm list //查看已安装的nodejs版本 nvm on // 启用node.js版本管理 nvm off // 禁用node.js版本管理(不卸载任何东西) nvm install // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0 nvm use //使用某一version的nodejs nvm uninstall // 卸载指定版本的nodejs nvm alias default //切换默认版本 代码工具 lodash npm搜索 官网lodash.com underscore 开源项目CDN package 文件解析 package中的 ^1.12.1的^表示当前版本号需要按语义做适配 major 主版本号 minor 次版本号 patch 补丁号 ^1.12.2 //锁定主版本号（major ） ~1.12.2 //锁定主版本号和次版本号（minor） 1.12.2 //锁定所有版本号（patch） * //最新版本 配置信息： \"name\": \"opipjl\", //发布包的名 \"version\": \"1.0.0\", //版本号 \"description\": \"\", //描述 \"main\": \"index.js\", //包的入口 \"keywords\": [], //关键字 \"author\": \"\", //作者 \"license\": \"MIT\", //许可证协议 \"repository\":{\"type\":\"Git\",\"url\":\"git+ \" } //包的git地址 NPM脚本 package.json中的 scripts 字段 ​ 全局 --> 本地 & //可以连接两个命令行 不分先后 && //依次执行 分先后 test start //可以简写，不写run process.env.npmpackage变量名 //能拿到package里的值(只能在脚本中访问) echo $npm_package_config_dev //window疑似不支持 Cross-env (命令兼容平台) npm install --sava-dev cross-env //安装 简写：npm i -S -D cross-env cross-env NODE_ENV=test1 node ./test1.js //NODE_ENV 为命令中的变量名和变量值 后面为执行命令 process.env.NODE_ENV //在./test1.js中获取NODE_ENV的值 NRM 管理源 npm的镜像源管理工具 npm i -g nrm //安装nrm nrm ls //查看可选源 nrm use taobao //切换源 nrm test //测试源响应速度 NPX npx gulp -D //当galp未安装时，会生成一个临时路径安装gulp npx --on--install http-server //强制使用本地模块 npx --ignore--existing http-server //强制安装远程模块 commonJs 解意：nodeJs的第三方规范 四步骤使用模块 定义模块 --创建文件且写入内容 暴露模块 --将写入内容暴露给外部 引入模块 --其他文件引入模块 使用模块 --使用定义的模块 module.export = {name,age} //对象写法 exprot.name = name //赋值写法 //衍生写法 exports.default = { } module.exports = { default } 五、nodeJs内置模块 JS日志工具(log4js) const log4js = require('log4js') log4js.configure({ appenders: { cheese: { type: 'file', filename: 'cheese.log' } }, categories: { default: { appenders: ['cheese'], level: 'error' } }, }) const logger = log4js.getLogger('cheese') logger.level = 'debug' logger.debug() 1、url const url = require('url') const urlString = 'https://www.baidu.com:443/pathh/index.html?id=1#tag=2' const urlObj = { parse解析出的对象 } url.parse(urlString,true) //parse 数据解析 (true时，query为对象格式) url.format(urlObj) //format 反向编译路径 url.resolve(\"http://www.baiducom/a\",\"../\") //回到上一层 url.resolve(\"http://www.baiducom/a\",\"/b\") //替换a为b const urlParams = new URLSearchParams(url.parse(urlString).search) urlParams.get('id') //获取search指定字段 2、qureySring const querystring = require('querystring') const query = 'id=2&name=tongy&from=上海' querystring.parse(query,':', '/') //解析 第一个参数key和value中的分隔符，第二个是value和key分隔符 querystring.escape(query) //编码 percent-encoded查询字符串 querystring.unescape(queryEscape) //解码 const queryObj = { id: 2, name: 'toingyi', from: '北京' } id=2&name=toingyi&from=%E5%8C%97%E4%BA%AC querystring.stringify(queryObj, ':', '/') //编译对象，后面两个参数替换的=和&符号 const newQuery = querystring.stringify(queryObj, null, null, { encodeURIComponent(string) { //中文保持不变 return querystring.unescape(string) }, }) 3、http //request 本地请求的函数 response服务器返回函数 http.createServer((request, response) => { response.writeHead(404, {\"content-type\":} ) //第一个返回状态码，第二个对象，返回头部的配置 response.write('home111') //返回内容 不会断开 response.end() //返回内容 会断开 }) ​ 3.1、get 请求 https.get( 'https://www.xiaomiyoupin.com/mtop/mf/resource/data/list', //请求的地址 (result) => { let data = '' result.on('data', (chunk) => { //chunk传回的数据 data += chunk }) result.on('end', () => { //利用response返回数据 }) } ) 3.2、post 请求 const postData = querystring.stringify({}) const options = { protocol: 'http:', //协议 hostname: 'localhost', //主机名 method: 'post', //方法类型 port: '3000', //端口号 path: '/data', //路径 headers: { //请求的首部字段 'content-type': 'application/x-www-form-urlencoded', 'content-length': Buffer.byteLength(postData), }, } const server = http.createServer((request, response) => { // const req = http.request(options, (result) => {}) req.write(postData) req.end() response.end() }) server.listen(80808,()=>{}) //监听端口号 请求头部信息 content-type : 对照表 node浏览器调试 // --inspect-brk 第一行打断点 node --inspect --inspect-brk server.js node进程管理工具 supervisor nodemon //热更启动 forever pm2 //部署 insomnia //调试工具 post请求 3.3、跨域（JSONP\\CORS\\middleware\\爬虫） JSONP 原理：利用在浏览器端请求js不跨域的特性 //前端代码 function getData(data){ console.log(data) } //后端代码 const server = http.createServer((request, response) => { let urlStr = request.url let urlObj = url.parse(urlStr, true) switch (urlObj.pathname) { case '/api/data': response.write(`${urlObj.query.cb}(\"hello\")`) //spanp中的p是填充的意思 break default: response.write('page no found') } response.end() }) CORS 原理：设置Access-Control-Allow-Origin白名单 response.writeHead(200, { 'content-type': 'application/json;charser=utf-8', 'Access-Control-Allow-Origin': '*', //后面的是白名单 }) proxy middleware(http-proxy-middleware) 文档地址 if (/\\/wph/.test(urlStr)) { const proxy = createProxyMiddleware('/wph', { //'/wph'确定应该将哪些请求代理到目标主机 target: 'https://mapi-rp.vip.com/', //要代理到的目标主机 changeOrigin: true, //是否确认代理 pathRewrite: { //路径重写 '^/wph': '', }, }) proxy(request, response) 爬虫 cheerio //爬到数据后，可以建立虚拟DOM树来解析 function filterData(data){ const $ = cheerio.load(data) $('.xxxx p').each((index,el)=>{}) //each == foreach } 4、event(自定义事件) const EventEmilter = require('events') class MyEventEmilter extends EventEmilter {} //继承EventEmilter const event = new MyEventEmilter() event.on('play', (value) => { //绑定事件（监听作用） console.log(value) }) event.emit('play', '执行') //触发事件 5、文件操作 注：错误优先的回调函数 5.1 文件夹操作 //创建文件 fs.mkdir('logs', (err) => { if (err) throw err }) // throw 抛出异常 //修改文件名/文件夹名 fs.rename('logs', 'log', (err) => {}) //待修改名 修改名 回调 //删除文件夹 fs.rmdir('./log', (err) => {}) //读取文件夹 fs.readdir('./logs', (err, result) => {}) 5.2 文件操作 //创建文件 fs.writeFile('./logs/log1.log', 'hello\\nwordd', (err) => {}) // 追加文件 fs.appendFile('./logs/log1.log', '!!!', (err) => {}) // 删除文件 fs.unlink('./logs/log1.log', (err) => {}) // 读取文件 fs.readFile('./logs/log1.log', 'utf-8', (err, content) => {}) //读取文件路径 返回内容格式 回调 // 同步读取文件 const content = fs.readFileSync('./logs/log1.log', 'utf-8', (err, content) => {}) //promise同步读取(node版本10以上) const fsPromises = require('fs').promises ;async () => { let result = await fsPromises.readFile('./logs/log1.log') } //判断某个文件是否存在 fs.existsSync(\"./index.html\") 5.3 遍历目录所有文件 function readdir(dir) { fs.readdir(dir, (err, content) => { //读取文件夹 content.forEach((value, index) => { let joinDir = `${dir}/${value}` fs.stat(joinDir, (err, stats) => { // stat获取文件或目录的信息 if (stats.isDirectory()) { //isDirectory 是否为目录 readdir(joinDir) } else { fs.readFile(joinDir, 'utf-8', (err, content) => { console.log(content) }) } }) }) }) } 5.4 监听文件 //文件路径 是否监听文件 是否监视所有子目录 字符编码 //eventType:rename或change（文件名出现或者消失时，触发rename） filename:触发事件的文件名称 fs.watch('./logs/log0',true,true,'utf8' (eventType,filename) => {}) //文件路径 是否为二进制 是否监听文件 监听间隔 fs.watchFile('./logs/log0',true,true,5000 (err) => {}) fs.watch //有一小部分平台文件名出现或者消失时,不触发rename，但是效率更高 fs.watchFile //没有上面的平台问题 5.5 文件流 （zlib压缩文件） const fs = require('fs') const zlib = require('zlib') const gizp = zlib.createGzip() const readStream = fs.createReadStream('./logs.txt') //读取流 const writeStream = fs.createWriteStream('./logs.gzip') //写入流 readStream.pipe(gizp).pipe(writeStream) //pipe 管道注入内容 5.6 逐行读取 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('What do you think of Node.js? ', (answer) => { // TODO：记录答案到数据库中 console.log(`Thank you for your valuable feedback: ${answer}`); rl.close(); }); 6、加密（crypto） const crypto = require('crypto') const passsword = 'abc' const hash = crypto .createHash('sha256') //sha256 加密的算法也可以是md5 .update(passsword) //加密谁 .digest('hex') //加密的形式 hex：十六进制 dec：十进制 oct：八进制 bin：二进制 36集 "},"服务器端/node/包管理器.html":{"url":"服务器端/node/包管理器.html","title":"包管理器","keywords":"","body":"包管理器 最新淘宝源 https://registry.npmmirror.com NPM 命令行 npm init -y //创建package文件 --sava //安装dependenciesd -S 简写 --dev //开发环境使用 devDependencies -D 简写 -g //全局安装 --save-dev //devDependencies添加依赖 install //安装 i 简写 npm uninstall gulp -D //卸载包 npm list //显示包管理的关系 npm list | grep 包名 //显示指定包管理的关系 三层关系 npm i --production //只装生产环境的包 npm view 包名 versions //查看包版本号 -V 简写 npm i 包名@版本号 -S //安装包指定版本号 版本号可不写 npm outdated //查看那些包已过期 npm update //更新包 npm cache clean --force //强制清除缓存 npm config get registry //查看当前源 npm config set registry 地址 //切换源 npm i git+https://git@ (git地址) //下载git项目（当hhs时，把https改成ssh） 使用npm i可以重新直接安装package里的内容 package-lock 显示包依赖关系 __dirname //当前代码所在文件的物理路径 包类型 1.内置的包 2.第三方库 3.自己定义的包 上传包 npm init -y 初始化 npm adduser 添加账户 npm publish 上传包 Yarn Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性 使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作 npm install -g yarn //安装 yarn config set registry https://registry.npmmirror.com -g //设置源 yarn config set sass_binary_site https://registry.npmmirror.com/dist/node-sass -g //设置源 "},"服务器端/代理/ngin.html":{"url":"服务器端/代理/ngin.html","title":"ngin","keywords":"","body":"nginx nginx服务器 nginx-服务器文件夹目录中不能有中文目录 dist 打包文件夹 放入nginx服务器 文件夹目录中 每次改完文件，都需要重新加载 需要在 阿里云 加入安全组 添加80端口 命令行 .\\nginx.exe -c conf\\kerwin.conf //加载kerwin.conf 并启动服务器 .\\nginx.exe -s stop //关闭nginx服务器 .\\nginx.exe -s reload //重新加载 conf/kerwin.conf 文件夹 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream kerwin-server { server localhost:3001 weight=1; server localhost:3002 weight=1; } server { listen 80; //访问域名 server_name localhost; //访问协议 location / { root dist; //加载的文件夹名 index index.html index.htm; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location /ajax/ { //反向代理配置 proxy_pass https://m.maoyan.com; } } } "}}