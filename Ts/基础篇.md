# 基础篇

### 命令行

```js
tsc  xxx    //执行ts文件，编译成js文件
tsc --init   //生成ts配置文件
tsc --watch   //ts自动编译成js文件
tsc --noEmitOnError --watch  //当ts文件有错误时，不自动编译
```

### tsconfig.json

```json
"target":"es5" //降级编译  编译后的js文件符合es5标准
"strict": true //打开严格模式 这个包括下面两个功能
"noImplicitAny": true //类型隐患检查
"strictNullChecks": true //严格的Null检查
"rootDir":"./src"  //根目录
"outDir":"./dist"   //输出目录
```

### 类型

``` js
string //字符串
number //数字
boolean //布尔
null  //不存在
undefined //未初始化的值
never //不应该存在的状态  只能分配给任何类型

//数组
type[] //arr:number[]  数字类型数组
Array<type> //Array<number> 数字类型数组

//任何
any  //obj: any = {} 任何值都可以赋值
```

### 类型注释

> 如果未注释类型，则会根据首次赋值来自动注释类型
>
> 匿名函数自动根据传入的值自动注释

```js
//参数注释
let person: number = 1  //冒号+类型
//函数注释
function gteer(name: string) {} //: string 表示形参类型注释
function gteer(): string {} //string表示返回值类型注释(void表示没有返回值)
() => string  //箭头函数返回值类型
//对象注释
function gteer(pt:{x:number, y?:number}) //问好表示可不传y值
//联合类型
let id: number | string 
```

#### 类型别名

```js
//使用type定义类型
type Point = { x:number,y:number  }
function getData(pt:Point) { }
type ID = number | string
function getData(id:ID) {}

//扩展类型别名
type Bear = Point & { z:number } //通过&扩展
```

#### 接口

```js
//使用interface定义类型
interface Point { 
    x:number
    y:number  
}
const point:Point = {x:1,y:2}

//扩展接口
interface Bear extends Point {  
    z:number
}
const bear:Bear = {x:1,y:2,z:3}

//添加新字段
interface Point { a:numbe } //重复定义，就可以新增加字段
```

#### 类型断言

```js
cosnt myCanvas = document.getElementById("canvas") as HTMLCancasElement
cosnt myCanvas = <HTMLCancasElement>document.getElementById("canvas") 
//string不能直接断言成number,需要有覆盖关系
const x = ('hello' as unknown) as number //unknown 未知的 
//固定类型
let x = {} as const
x!  //断言x不是null或者undefined
```

#### 文字类型

```js
//字符串文字类型
let x: 'true'|'false' = "true" 
//数字文字类型
let x:-1 | 1 | 0 = 0
//布尔文字类型
let x: true | false  = true
```

#### 枚举

```js
enum direction {
    a = 1,
    b,
    c,
    d
}
console.log(direction.a，direction.b) //1 2 3 4 会在每个后面依次加1
```

#### 原语

```js
bigint //非常大的整数
let a:bigint = 100n
symbol //全局唯一引用
let a = Symbol(1)
let b = Symbol(1)
a == b  //答案为false,因为symbol具有全局唯一性
```

## 类型缩小

#### typeof 类型守卫

>object \ string \ number \ bigint \ boolean \ symbol \undefined \ function

```js
if(typeof strs === "object") {}
```

#### 真值缩小

> 条件、&&、||、if语句、！ 
>
> 通过对上方的使用，过滤null和undefined

#### 等值缩小

> ===, !===, ==, !=

```js
function example (x:string | number,y:string | boolean){
    if(x === y){} //当两者都是string时执行里面内容
}
let a: number | null | undefined
if( a != null ){ } //当a等于null或undefined时，都不会执行里面内容
```

#### in 操作符缩小

```js
type a1 = { a: ()=> void }
type b1 = { b: ()=> void }
type c1 = { a?: ()=> void; b?: ()=> void }

function test( value: a1 | b1 | c1 ){
    if( 'a' in a1 ){ //a1对象中是否有a属性
        return (a as a1 ).a() //因为c1也有a属性，所以加个 as a1 缩小范围
    }   
}
```

#### instanceof 操作符缩小

```js
x instanceof  Foo  //检查Foo是否是X的实例
if( x instanceof Date ){] //是否是Date上的实例
```

#### 分配缩小

```js
let x = Math.randow() < 0.5 ? 10 : 'hello' //相等于  let x:string | number
```

#### 类型谓词

```js
type Fish = {
  name:string
  swim: ()=> void
}
type Bird = {
  name: string
  fly: ()=> void
}    

function isFish(pet: Fish | Bird):pet is Fish {
  return (pet as Fish).swim !== undefined 
} 
```

#### 联合类型 unions

```js
interface a {
   name:"a"
   radius:number
}
interface b{
   name:"b"
   leftLength:number
}

type c = a | b //联合类型

function getDate(shape:c){
  switch(share.name){
     case 'a'：
       return shape.radius
     case 'b'：
       return shape.leftLength 
    }
}
```

#### 穷进性检查

```js
type c = a | b   
function getDate(shape:c){
  switch(share.name){
     case 'a'：
       return shape.radius
     case 'b'：
       return shape.leftLength 
     default: //never 任何类型都不能分配给never
       let d: never = shape //never 不应该存在的状态  可以分配给任何类型
       return d
    }
}
```

### 函数

#### 函数类型表达式

```js
//fn : (a: string) => void
type fnType =  (a: string) => void

function greeter(fn : fnType) {
    fn("hello")
}

function prinTo(s:string){
    console.log(s)
}

greeter(prinTo) //结果为 "hello"
```

#### 调用签名

> 创建一个含有普通类型和函数类型的类型别名

```js
type funType = {
    a: string
    (b: number) : booleam //参数列表和返回类型之间是：而不是=>
}

function getData(fn:funType){
    cosnole.log(fn.a + fn(6))
}
function fn1(n:number){
    return true
}
fn1.a = 'hello'

getData(fn1) //结果 hello  true
```

#### 构造签名

> 

```js
class ctor {
  s: string
  newfun(s: string) {
      this.s = s
  }
}

type funType = {
    new (a: string) : ctor //返回类或者构造函数
}

function fn(ctor: funType){
  return new  ctor('hello')
}

const f = fn(ctor)
console.log(f.s) //结果 hello
```

